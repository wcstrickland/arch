'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeCompletionCore = exports.CandidatesCollection = void 0;
const antlr4ts_1 = require("antlr4ts");
const atn_1 = require("antlr4ts/atn");
const IntervalSet_1 = require("antlr4ts/misc/IntervalSet");
class CandidatesCollection {
    constructor() {
        this.tokens = new Map();
        this.rules = new Map();
    }
}
exports.CandidatesCollection = CandidatesCollection;
;
class FollowSetWithPath {
    constructor() {
        this.path = [];
        this.following = [];
    }
}
;
class FollowSetsHolder {
}
;
class PipelineEntry {
}
;
class CodeCompletionCore {
    constructor(parser) {
        this.showResult = false;
        this.showDebugOutput = false;
        this.debugOutputWithTransitions = false;
        this.showRuleStack = false;
        this.translateRulesTopDown = false;
        this.tokenStartIndex = 0;
        this.statesProcessed = 0;
        this.shortcutMap = new Map();
        this.candidates = new CandidatesCollection();
        this.atnStateTypeMap = [
            "invalid",
            "basic",
            "rule start",
            "block start",
            "plus block start",
            "star block start",
            "token start",
            "rule stop",
            "block end",
            "star loop back",
            "star loop entry",
            "plus loop back",
            "loop end"
        ];
        this.parser = parser;
        this.atn = parser.atn;
        this.vocabulary = parser.vocabulary;
        this.ruleNames = parser.ruleNames;
        this.ignoredTokens = new Set();
        this.preferredRules = new Set();
    }
    collectCandidates(caretTokenIndex, context) {
        this.shortcutMap.clear();
        this.candidates.rules.clear();
        this.candidates.tokens.clear();
        this.statesProcessed = 0;
        this.precedenceStack = [];
        this.tokenStartIndex = context ? context.start.tokenIndex : 0;
        let tokenStream = this.parser.inputStream;
        this.tokens = [];
        let offset = this.tokenStartIndex;
        while (true) {
            const token = tokenStream.get(offset++);
            if (token.channel === antlr4ts_1.Token.DEFAULT_CHANNEL) {
                this.tokens.push(token);
                if (token.tokenIndex >= caretTokenIndex || token.type == antlr4ts_1.Token.EOF) {
                    break;
                }
            }
            if (token.type == antlr4ts_1.Token.EOF) {
                break;
            }
        }
        let callStack = [];
        let startRule = context ? context.ruleIndex : 0;
        this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);
        if (this.showResult) {
            console.log("States processed: " + this.statesProcessed);
            console.log("\n\nCollected rules:\n");
            for (let rule of this.candidates.rules) {
                let path = "";
                for (let token of rule[1].ruleList) {
                    path += this.ruleNames[token] + " ";
                }
                console.log(this.ruleNames[rule[0]] + ", path: ", path);
            }
            const sortedTokens = new Set();
            for (let token of this.candidates.tokens) {
                let value = this.vocabulary.getDisplayName(token[0]);
                for (let following of token[1])
                    value += " " + this.vocabulary.getDisplayName(following);
                sortedTokens.add(value);
            }
            console.log("\n\nCollected tokens:\n");
            for (let symbol of sortedTokens) {
                console.log(symbol);
            }
            console.log("\n\n");
        }
        return this.candidates;
    }
    checkPredicate(transition) {
        return transition.predicate.eval(this.parser, antlr4ts_1.ParserRuleContext.emptyContext());
    }
    translateStackToRuleIndex(ruleWithStartTokenList) {
        if (this.preferredRules.size == 0) {
            return false;
        }
        if (this.translateRulesTopDown) {
            for (let i = ruleWithStartTokenList.length - 1; i >= 0; i--) {
                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {
                    return true;
                }
            }
        }
        else {
            for (let i = 0; i < ruleWithStartTokenList.length; i++) {
                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {
                    return true;
                }
            }
        }
        return false;
    }
    translateToRuleIndex(i, ruleWithStartTokenList) {
        const { ruleIndex, startTokenIndex } = ruleWithStartTokenList[i];
        if (this.preferredRules.has(ruleIndex)) {
            const path = ruleWithStartTokenList.slice(0, i).map(({ ruleIndex }) => ruleIndex);
            let addNew = true;
            for (let rule of this.candidates.rules) {
                if (rule[0] != ruleIndex || rule[1].ruleList.length != path.length) {
                    continue;
                }
                if (path.every((v, j) => v === rule[1].ruleList[j])) {
                    addNew = false;
                    break;
                }
            }
            if (addNew) {
                this.candidates.rules.set(ruleIndex, {
                    startTokenIndex,
                    ruleList: path,
                });
                if (this.showDebugOutput) {
                    console.log("=====> collected: ", this.ruleNames[ruleIndex]);
                }
            }
            return true;
        }
        return false;
    }
    getFollowingTokens(transition) {
        const result = [];
        const pipeline = [transition.target];
        while (pipeline.length > 0) {
            const state = pipeline.pop();
            for (let transition of state.getTransitions()) {
                if (transition.serializationType == 5) {
                    if (!transition.isEpsilon) {
                        let list = transition.label.toArray();
                        if (list.length == 1 && !this.ignoredTokens.has(list[0])) {
                            result.push(list[0]);
                            pipeline.push(transition.target);
                        }
                    }
                    else {
                        pipeline.push(transition.target);
                    }
                }
            }
        }
        return result;
    }
    determineFollowSets(start, stop) {
        const result = [];
        const stateStack = [];
        const ruleStack = [];
        this.collectFollowSets(start, stop, result, stateStack, ruleStack);
        return result;
    }
    collectFollowSets(s, stopState, followSets, stateStack, ruleStack) {
        if (stateStack.find(x => x == s)) {
            return;
        }
        stateStack.push(s);
        if (s == stopState || s.stateType == atn_1.ATNStateType.RULE_STOP) {
            let set = new FollowSetWithPath();
            set.intervals = IntervalSet_1.IntervalSet.of(antlr4ts_1.Token.EPSILON);
            set.path = ruleStack.slice();
            followSets.push(set);
            stateStack.pop();
            return;
        }
        for (let transition of s.getTransitions()) {
            if (transition.serializationType == 3) {
                let ruleTransition = transition;
                if (ruleStack.indexOf(ruleTransition.target.ruleIndex) != -1) {
                    continue;
                }
                ruleStack.push(ruleTransition.target.ruleIndex);
                this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);
                ruleStack.pop();
            }
            else if (transition.serializationType == 4) {
                if (this.checkPredicate(transition)) {
                    this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);
                }
            }
            else if (transition.isEpsilon) {
                this.collectFollowSets(transition.target, stopState, followSets, stateStack, ruleStack);
            }
            else if (transition.serializationType == 9) {
                let set = new FollowSetWithPath();
                set.intervals = IntervalSet_1.IntervalSet.of(antlr4ts_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                set.path = ruleStack.slice();
                followSets.push(set);
            }
            else {
                let label = transition.label;
                if (label && label.size > 0) {
                    if (transition.serializationType == 8) {
                        label = label.complement(IntervalSet_1.IntervalSet.of(antlr4ts_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                    }
                    const set = new FollowSetWithPath();
                    set.intervals = label;
                    set.path = ruleStack.slice();
                    set.following = this.getFollowingTokens(transition);
                    followSets.push(set);
                }
            }
        }
        stateStack.pop();
    }
    processRule(startState, tokenListIndex, callStack, precedence, indentation) {
        let positionMap = this.shortcutMap.get(startState.ruleIndex);
        if (!positionMap) {
            positionMap = new Map();
            this.shortcutMap.set(startState.ruleIndex, positionMap);
        }
        else {
            if (positionMap.has(tokenListIndex)) {
                if (this.showDebugOutput) {
                    console.log("=====> shortcut");
                }
                return positionMap.get(tokenListIndex);
            }
        }
        const result = new Set();
        let setsPerState = CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);
        if (!setsPerState) {
            setsPerState = new Map();
            CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);
        }
        let followSets = setsPerState.get(startState.stateNumber);
        if (!followSets) {
            followSets = new FollowSetsHolder();
            setsPerState.set(startState.stateNumber, followSets);
            let stop = this.atn.ruleToStopState[startState.ruleIndex];
            followSets.sets = this.determineFollowSets(startState, stop);
            let combined = new IntervalSet_1.IntervalSet();
            for (let set of followSets.sets) {
                combined.addAll(set.intervals);
            }
            followSets.combined = combined;
        }
        const startTokenIndex = this.tokens[tokenListIndex].tokenIndex;
        callStack.push({
            startTokenIndex,
            ruleIndex: startState.ruleIndex,
        });
        if (tokenListIndex >= this.tokens.length - 1) {
            if (this.preferredRules.has(startState.ruleIndex)) {
                this.translateStackToRuleIndex(callStack);
            }
            else {
                for (let set of followSets.sets) {
                    const fullPath = callStack.slice();
                    const followSetPath = set.path.map(path => ({
                        startTokenIndex,
                        ruleIndex: path,
                    }));
                    fullPath.push(...followSetPath);
                    if (!this.translateStackToRuleIndex(fullPath)) {
                        for (let symbol of set.intervals.toArray())
                            if (!this.ignoredTokens.has(symbol)) {
                                if (this.showDebugOutput) {
                                    console.log("=====> collected: ", this.vocabulary.getDisplayName(symbol));
                                }
                                if (!this.candidates.tokens.has(symbol)) {
                                    this.candidates.tokens.set(symbol, set.following);
                                }
                                else {
                                    if (this.candidates.tokens.get(symbol) != set.following) {
                                        this.candidates.tokens.set(symbol, []);
                                    }
                                }
                            }
                    }
                }
            }
            callStack.pop();
            return result;
        }
        else {
            const currentSymbol = this.tokens[tokenListIndex].type;
            if (!followSets.combined.contains(antlr4ts_1.Token.EPSILON) && !followSets.combined.contains(currentSymbol)) {
                callStack.pop();
                return result;
            }
        }
        if (startState.isPrecedenceRule) {
            this.precedenceStack.push(precedence);
        }
        const statePipeline = [];
        let currentEntry;
        statePipeline.push({ state: startState, tokenListIndex: tokenListIndex });
        while (statePipeline.length > 0) {
            currentEntry = statePipeline.pop();
            ++this.statesProcessed;
            const currentSymbol = this.tokens[currentEntry.tokenListIndex].type;
            const atCaret = currentEntry.tokenListIndex >= this.tokens.length - 1;
            if (this.showDebugOutput) {
                this.printDescription(indentation, currentEntry.state, this.generateBaseDescription(currentEntry.state), currentEntry.tokenListIndex);
                if (this.showRuleStack)
                    this.printRuleState(callStack);
            }
            if (currentEntry.state.stateType == atn_1.ATNStateType.RULE_STOP) {
                result.add(currentEntry.tokenListIndex);
                continue;
            }
            const transitions = currentEntry.state.getTransitions();
            for (let transition of transitions) {
                switch (transition.serializationType) {
                    case 3: {
                        const ruleTransition = transition;
                        const endStatus = this.processRule(transition.target, currentEntry.tokenListIndex, callStack, ruleTransition.precedence, indentation + 1);
                        for (let position of endStatus) {
                            statePipeline.push({
                                state: transition.followState,
                                tokenListIndex: position
                            });
                        }
                        break;
                    }
                    case 4: {
                        if (this.checkPredicate(transition))
                            statePipeline.push({
                                state: transition.target,
                                tokenListIndex: currentEntry.tokenListIndex
                            });
                        break;
                    }
                    case 10: {
                        const predTransition = transition;
                        if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1])
                            statePipeline.push({
                                state: transition.target,
                                tokenListIndex: currentEntry.tokenListIndex
                            });
                        break;
                    }
                    case 9: {
                        if (atCaret) {
                            if (!this.translateStackToRuleIndex(callStack)) {
                                for (let token of IntervalSet_1.IntervalSet.of(antlr4ts_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)
                                    .toArray()) {
                                    if (!this.ignoredTokens.has(token)) {
                                        this.candidates.tokens.set(token, []);
                                    }
                                }
                            }
                        }
                        else {
                            statePipeline.push({
                                state: transition.target,
                                tokenListIndex: currentEntry.tokenListIndex + 1
                            });
                        }
                        break;
                    }
                    default: {
                        if (transition.isEpsilon) {
                            statePipeline.push({
                                state: transition.target,
                                tokenListIndex: currentEntry.tokenListIndex
                            });
                            continue;
                        }
                        let set = transition.label;
                        if (set && set.size > 0) {
                            if (transition.serializationType == 8) {
                                set = set.complement(IntervalSet_1.IntervalSet.of(antlr4ts_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                            }
                            if (atCaret) {
                                if (!this.translateStackToRuleIndex(callStack)) {
                                    let list = set.toArray();
                                    let addFollowing = list.length == 1;
                                    for (let symbol of list)
                                        if (!this.ignoredTokens.has(symbol)) {
                                            if (this.showDebugOutput) {
                                                console.log("=====> collected: ", this.vocabulary.getDisplayName(symbol));
                                            }
                                            if (addFollowing) {
                                                this.candidates.tokens.set(symbol, this.getFollowingTokens(transition));
                                            }
                                            else {
                                                this.candidates.tokens.set(symbol, []);
                                            }
                                        }
                                }
                            }
                            else {
                                if (set.contains(currentSymbol)) {
                                    if (this.showDebugOutput) {
                                        console.log("=====> consumed: ", this.vocabulary.getDisplayName(currentSymbol));
                                    }
                                    statePipeline.push({
                                        state: transition.target,
                                        tokenListIndex: currentEntry.tokenListIndex + 1
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        callStack.pop();
        if (startState.isPrecedenceRule) {
            this.precedenceStack.pop();
        }
        positionMap.set(tokenListIndex, result);
        return result;
    }
    generateBaseDescription(state) {
        const stateValue = state.stateNumber == atn_1.ATNState.INVALID_STATE_NUMBER ? "Invalid" : state.stateNumber;
        return "[" + stateValue + " " + this.atnStateTypeMap[state.stateType] + "] in " +
            this.ruleNames[state.ruleIndex];
    }
    printDescription(indentation, state, baseDescription, tokenIndex) {
        const indent = "  ".repeat(indentation);
        let output = indent;
        let transitionDescription = "";
        if (this.debugOutputWithTransitions) {
            for (let transition of state.getTransitions()) {
                let labels = "";
                let symbols = transition.label ? transition.label.toArray() : [];
                if (symbols.length > 2) {
                    labels = this.vocabulary.getDisplayName(symbols[0]) + " .. " +
                        this.vocabulary.getDisplayName(symbols[symbols.length - 1]);
                }
                else {
                    for (let symbol of symbols) {
                        if (labels.length > 0) {
                            labels += ", ";
                        }
                        labels += this.vocabulary.getDisplayName(symbol);
                    }
                }
                if (labels.length == 0) {
                    labels = "Îµ";
                }
                transitionDescription += "\n" + indent + "\t(" + labels + ") " + "[" +
                    transition.target.stateNumber + " " + this.atnStateTypeMap[transition.target.stateType] + "] in " +
                    this.ruleNames[transition.target.ruleIndex];
            }
        }
        if (tokenIndex >= this.tokens.length - 1) {
            output += "<<" + this.tokenStartIndex + tokenIndex + ">> ";
        }
        else {
            output += "<" + this.tokenStartIndex + tokenIndex + "> ";
        }
        console.log(output + "Current state: " + baseDescription + transitionDescription);
    }
    printRuleState(stack) {
        if (stack.length == 0) {
            console.log("<empty stack>");
            return;
        }
        for (let rule of stack) {
            console.log(this.ruleNames[rule.ruleIndex]);
        }
    }
}
exports.CodeCompletionCore = CodeCompletionCore;
CodeCompletionCore.followSetsByATN = new Map();
//# sourceMappingURL=CodeCompletionCore.js.map