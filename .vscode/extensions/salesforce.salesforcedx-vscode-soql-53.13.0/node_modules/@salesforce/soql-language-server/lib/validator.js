"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const soql_parser_1 = require("@salesforce/soql-common/lib/soql-parser");
const vscode_languageserver_1 = require("vscode-languageserver");
const soqlComments_1 = require("@salesforce/soql-common/lib/soqlComments");
const findLimitRegex = new RegExp(/LIMIT\s+\d+\s*$/, 'i');
const findPositionRegex = new RegExp(/ERROR at Row:(?<row>\d+):Column:(?<column>\d+)/);
const findCauseRegex = new RegExp(/'(?<cause>\S+)'/);
class Validator {
    static validateSoqlText(textDocument) {
        const diagnostics = [];
        const parser = soql_parser_1.SOQLParser({
            isApex: true,
            isMultiCurrencyEnabled: true,
            apiVersion: 50.0,
        });
        const result = parser.parseQuery(soqlComments_1.parseHeaderComments(textDocument.getText()).headerPaddedSoqlText);
        if (!result.getSuccess()) {
            result.getParserErrors().forEach((error) => {
                var _a, _b;
                diagnostics.push({
                    severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                    range: {
                        start: textDocument.positionAt((_a = error.getToken()) === null || _a === void 0 ? void 0 : _a.startIndex),
                        end: textDocument.positionAt((_b = error.getToken()) === null || _b === void 0 ? void 0 : _b.stopIndex),
                    },
                    message: error.getMessage(),
                    source: 'soql',
                });
            });
        }
        return diagnostics;
    }
    static async validateLimit0Query(textDocument, connection) {
        connection.console.log(`validate SOQL query:\n${textDocument.getText()}`);
        const diagnostics = [];
        const soqlWithHeaderComments = soqlComments_1.parseHeaderComments(textDocument.getText());
        const response = await connection.sendRequest("runQuery" /* RunQuery */, appendLimit0(soqlWithHeaderComments.soqlText));
        if (response.error) {
            const { errorMessage, errorRange } = extractErrorRange(soqlWithHeaderComments, response.error.message);
            diagnostics.push({
                severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                range: errorRange || documentRange(textDocument),
                message: errorMessage,
                source: 'soql',
            });
        }
        return diagnostics;
    }
}
exports.Validator = Validator;
function appendLimit0(query) {
    if (findLimitRegex.test(query)) {
        query = query.replace(findLimitRegex, 'LIMIT 0');
    }
    else {
        query = `${query} LIMIT 0`;
    }
    return query;
}
function extractErrorRange(soqlWithComments, errorMessage) {
    const posMatch = findPositionRegex.exec(errorMessage);
    if (posMatch && posMatch.groups) {
        const line = Number(posMatch.groups.row) - 1 + soqlWithComments.commentLineCount;
        const character = Number(posMatch.groups.column) - 1;
        const causeMatch = findCauseRegex.exec(errorMessage);
        const cause = (causeMatch && causeMatch.groups && causeMatch.groups.cause) || ' ';
        return {
            // Strip out the line and column information from the error message
            errorMessage: errorMessage.replace(findPositionRegex, 'Error:'),
            errorRange: {
                start: { line, character },
                end: { line, character: character + cause.length },
            },
        };
    }
    else {
        return { errorMessage, errorRange: undefined };
    }
}
function documentRange(textDocument) {
    return {
        start: { line: 0, character: 0 },
        end: { line: textDocument.lineCount, character: 0 },
    };
}
//# sourceMappingURL=validator.js.map