"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoqlModelUtils = void 0;
const Impl = require("./impl");
// eslint-disable-next-line @typescript-eslint/no-namespace
var SoqlModelUtils;
(function (SoqlModelUtils) {
    /**
     * This method returns quickly as soon as it finds unmodeled syntax.
     *
     * @param model
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function containsUnmodeledSyntax(model) {
        if (isUnmodeledSyntax(model)) {
            return true;
        }
        for (const property in model) {
            if (typeof model[property] === 'object') {
                const hasUnmodeledSyntax = containsUnmodeledSyntax(model[property]);
                if (hasUnmodeledSyntax) {
                    return true;
                }
            }
        }
        return false;
    }
    SoqlModelUtils.containsUnmodeledSyntax = containsUnmodeledSyntax;
    /**
     * This method determins whether the model object is an instance of unmodeled syntax, without checking property objects.
     *
     * @param model
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function isUnmodeledSyntax(model) {
        return 'unmodeledSyntax' in model;
    }
    SoqlModelUtils.isUnmodeledSyntax = isUnmodeledSyntax;
    /**
     * This method collects all the unmodelled syntax it finds into a collection and returns it.
     *
     * @param model
     * @param collector
     */
    function getUnmodeledSyntax(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    model, collector) {
        collector = collector || [];
        if ('unmodeledSyntax' in model) {
            collector.push(model);
            return collector;
        }
        for (const property in model) {
            if (typeof model[property] === 'object') {
                getUnmodeledSyntax(model[property], collector);
            }
        }
        return collector;
    }
    SoqlModelUtils.getUnmodeledSyntax = getUnmodeledSyntax;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function containsError(model) {
        if ('errors' in model && Array.isArray(model.errors) && model.errors.length > 0) {
            return true;
        }
        for (const property in model) {
            if (typeof model[property] === 'object') {
                const hasError = containsError(model[property]);
                if (hasError) {
                    return true;
                }
            }
        }
        return false;
    }
    SoqlModelUtils.containsError = containsError;
    function simpleGroupToArray(condition) {
        if (!isSimpleGroup(condition)) {
            throw Error('not simple group');
        }
        condition = stripNesting(condition);
        let conditions = [];
        let andOr;
        if (condition instanceof Impl.AndOrConditionImpl) {
            conditions = conditions.concat(simpleGroupToArray(condition.leftCondition).conditions);
            conditions = conditions.concat(simpleGroupToArray(condition.rightCondition).conditions);
            andOr = condition.andOr;
        }
        else {
            conditions.push(condition);
        }
        return { conditions, andOr };
    }
    SoqlModelUtils.simpleGroupToArray = simpleGroupToArray;
    function arrayToSimpleGroup(conditions, andOr) {
        if (conditions.length > 1 && andOr === undefined) {
            throw Error('no operator supplied for conditions');
        }
        if (conditions.length === 0) {
            throw Error('no conditions');
        }
        if (conditions.length === 1) {
            return conditions[0];
        }
        else {
            const [left, ...rest] = conditions;
            return new Impl.AndOrConditionImpl(left, andOr, arrayToSimpleGroup(rest, andOr));
        }
    }
    SoqlModelUtils.arrayToSimpleGroup = arrayToSimpleGroup;
    function isSimpleGroup(condition, andOr) {
        // a simple group is a condition that can be expressed as an ANY or ALL group of conditions
        // ANY: simple conditions all joined by OR
        // ALL: simple conditions all joined by AND
        condition = stripNesting(condition);
        if (condition instanceof Impl.AndOrConditionImpl) {
            if (!andOr) {
                andOr = condition.andOr;
            }
            return (condition.andOr === andOr &&
                isSimpleGroup(condition.leftCondition, andOr) &&
                isSimpleGroup(condition.rightCondition, andOr));
        }
        return isSimpleCondition(condition);
    }
    SoqlModelUtils.isSimpleGroup = isSimpleGroup;
    function isSimpleCondition(condition) {
        condition = stripNesting(condition);
        return (condition instanceof Impl.FieldCompareConditionImpl ||
            condition instanceof Impl.IncludesConditionImpl ||
            condition instanceof Impl.InListConditionImpl ||
            condition instanceof Impl.UnmodeledSyntaxImpl);
    }
    SoqlModelUtils.isSimpleCondition = isSimpleCondition;
    function getKeyByValue(object, value) {
        return Object.keys(object).find((key) => object[key] === value);
    }
    SoqlModelUtils.getKeyByValue = getKeyByValue;
    // eslint-disable-next-line no-inner-declarations
    function stripNesting(condition) {
        while (condition instanceof Impl.NestedConditionImpl) {
            condition = condition.condition;
        }
        return condition;
    }
})(SoqlModelUtils = exports.SoqlModelUtils || (exports.SoqlModelUtils = {}));
//# sourceMappingURL=util.js.map