"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const tern_server_1 = require("./tern-server/tern-server");
const indexer_1 = __importDefault(require("./aura-indexer/indexer"));
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
const auraTags_1 = require("./markup/auraTags");
const shared_1 = require("@salesforce/lightning-lsp-common/lib/shared");
const tagAdded = new vscode_languageserver_1.NotificationType('salesforce/tagAdded');
const tagDeleted = new vscode_languageserver_1.NotificationType('salesforce/tagDeleted');
const tagsCleared = new vscode_languageserver_1.NotificationType('salesforce/tagsCleared');
// Create a standard connection and let the caller decide the strategy
// Available strategies: '--node-ipc', '--stdio' or '--socket={number}'
const connection = vscode_languageserver_1.createConnection();
lightning_lsp_common_1.interceptConsoleLogger(connection);
// Create a document namager supporting only full document sync
const documents = new vscode_languageserver_1.TextDocuments();
documents.listen(connection);
let htmlLS;
let context;
function startIndexing() {
    setTimeout(async () => {
        const indexer = context.getIndexingProvider('aura');
        connection.sendNotification('salesforce/indexingStarted');
        await indexer.configureAndIndex();
        connection.sendNotification('salesforce/indexingEnded');
    }, 0);
}
connection.onInitialize(async (params) => {
    const { workspaceFolders } = params;
    const workspaceRoots = [];
    for (const folder of workspaceFolders) {
        workspaceRoots.push(path.resolve(vscode_uri_1.default.parse(folder.uri).fsPath));
    }
    try {
        if (workspaceRoots.length === 0) {
            console.warn(`No workspace found`);
            return { capabilities: {} };
        }
        for (const root of workspaceRoots) {
            console.info(`Starting *AURA* language server at ${root}`);
        }
        const startTime = process.hrtime();
        context = new lightning_lsp_common_1.WorkspaceContext(workspaceRoots);
        if (context.type === shared_1.WorkspaceType.CORE_PARTIAL) {
            await tern_server_1.startServer(path.join(workspaceRoots[0], '..'), path.join(workspaceRoots[0], '..'));
        }
        else {
            await tern_server_1.startServer(workspaceRoots[0], workspaceRoots[0]);
        }
        context.configureProject();
        const auraIndexer = new indexer_1.default(context);
        auraTags_1.setIndexer(auraIndexer);
        auraIndexer.eventEmitter.on('set', (tag) => {
            connection.sendNotification(tagAdded, { taginfo: tag });
        });
        auraIndexer.eventEmitter.on('delete', (tag) => {
            connection.sendNotification(tagDeleted, tag);
        });
        auraIndexer.eventEmitter.on('clear', () => {
            connection.sendNotification(tagsCleared, undefined);
        });
        startIndexing();
        htmlLS = lightning_lsp_common_1.getLanguageService();
        htmlLS.addTagProvider(auraTags_1.getAuraTagProvider());
        console.info('... language server started in ' + lightning_lsp_common_1.utils.elapsedMillis(startTime));
        return {
            capabilities: {
                textDocumentSync: documents.syncKind,
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: ['.', ':', '<', '"', '=', '/', '>'],
                },
                workspace: {
                    workspaceFolders: {
                        supported: true,
                    },
                },
                signatureHelpProvider: {
                    triggerCharacters: ['('],
                },
                referencesProvider: true,
                hoverProvider: true,
                definitionProvider: true,
                typeDefinitionProvider: true,
            },
        };
    }
    catch (e) {
        throw new Error(`Aura Language Server initialization unsuccessful. Error message: ${e.message}`);
    }
});
// Make sure to clear all the diagnostics when a document gets closed
documents.onDidClose(event => {
    connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});
connection.onCompletion(async (completionParams) => {
    const document = documents.get(completionParams.textDocument.uri);
    if (await context.isAuraMarkup(document)) {
        const htmlDocument = htmlLS.parseHTMLDocument(document);
        const list = htmlLS.doComplete(document, completionParams.position, htmlDocument, {
            isSfdxProject: context.type === shared_1.WorkspaceType.SFDX,
            useAttributeValueQuotes: true,
        });
        return list;
    }
    if (await context.isAuraJavascript(document)) {
        return tern_server_1.onCompletion(completionParams);
    }
    return { isIncomplete: false, items: [] };
});
connection.onCompletionResolve((item) => {
    return item;
});
connection.onHover(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (await context.isAuraMarkup(document)) {
        const htmlDocument = htmlLS.parseHTMLDocument(document);
        const hover = htmlLS.doHover(document, textDocumentPosition.position, htmlDocument);
        return hover;
    }
    if (await context.isAuraJavascript(document)) {
        return tern_server_1.onHover(textDocumentPosition);
    }
    return null;
});
connection.onTypeDefinition(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (await context.isAuraJavascript(document)) {
        return tern_server_1.onTypeDefinition(textDocumentPosition);
    }
    return null;
});
function findJavascriptProperty(valueProperty, textDocumentPosition) {
    // couldn't find it within the markup file, try looking for it as a javascript property
    const fsPath = vscode_uri_1.default.parse(textDocumentPosition.textDocument.uri).fsPath;
    const parsedPath = path.parse(fsPath);
    const componentName = parsedPath.name;
    const namespace = path.basename(path.dirname(parsedPath.dir));
    const indexer = context.getIndexingProvider('aura');
    const tag = indexer.getAuraByTag(namespace + ':' + componentName);
    if (tag) {
        // aura tag doesn't contain controller methods yet
        // but, if its not a v.value, its probably fine to just open the controller file
        const controllerPath = path.join(parsedPath.dir, componentName + 'Controller.js');
        return {
            uri: vscode_uri_1.default.file(controllerPath).toString(),
            range: {
                start: {
                    character: 0,
                    line: 1,
                },
                end: {
                    character: 0,
                    line: 1,
                },
            },
        };
    }
    return null;
}
connection.onDefinition(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (await context.isAuraMarkup(document)) {
        const htmlDocument = htmlLS.parseHTMLDocument(document);
        let def = htmlLS.findDefinition(document, textDocumentPosition.position, htmlDocument);
        if (!def) {
            def = htmlLS.getAuraBindingTemplateDeclaration(document, textDocumentPosition.position, htmlDocument);
            if (!def) {
                const valueProperty = htmlLS.getAuraBindingValue(document, textDocumentPosition.position, htmlDocument);
                if (valueProperty) {
                    def = findJavascriptProperty(valueProperty, textDocumentPosition);
                }
            }
        }
        return def;
    }
    if (await context.isAuraJavascript(document)) {
        return tern_server_1.onDefinition(textDocumentPosition);
    }
    return null;
});
connection.onDidChangeWatchedFiles(async (change) => {
    console.info('aura onDidChangeWatchedFiles...');
    const changes = change.changes;
    try {
        if (lightning_lsp_common_1.utils.isAuraRootDirectoryCreated(context, changes)) {
            await context.getIndexingProvider('aura').resetIndex();
            await context.getIndexingProvider('aura').configureAndIndex();
            // re-index everything on directory deletions as no events are reported for contents of deleted directories
            const startTime = process.hrtime();
            console.info('reindexed workspace in ' + lightning_lsp_common_1.utils.elapsedMillis(startTime) + ', directory was deleted:', changes);
            return;
        }
        else {
            for (const event of changes) {
                if (event.type === vscode_languageserver_1.FileChangeType.Deleted && lightning_lsp_common_1.utils.isAuraWatchedDirectory(context, event.uri)) {
                    const dir = utils_1.toResolvedPath(event.uri);
                    const indexer = context.getIndexingProvider('aura');
                    indexer.clearTagsforDirectory(dir, context.type === shared_1.WorkspaceType.SFDX);
                }
                else {
                    const file = utils_1.toResolvedPath(event.uri);
                    if (/.*(.app|.cmp|.intf|.evt|.lib)$/.test(file)) {
                        const indexer = context.getIndexingProvider('aura');
                        await indexer.indexFile(file, context.type === shared_1.WorkspaceType.SFDX);
                    }
                }
            }
        }
    }
    catch (e) {
        connection.sendNotification(vscode_languageserver_1.ShowMessageNotification.type, { type: vscode_languageserver_1.MessageType.Error, message: `Error re-indexing workspace: ${e.message}` });
    }
});
connection.onRequest('salesforce/listComponents', () => {
    const indexer = context.getIndexingProvider('aura');
    const tags = indexer.getAuraTags();
    const result = JSON.stringify([...tags]);
    return result;
});
connection.onRequest('salesforce/listNamespaces', () => {
    const indexer = context.getIndexingProvider('aura');
    const tags = indexer.getAuraNamespaces();
    const result = JSON.stringify(tags);
    return result;
});
// eslint-disable-next-line @typescript-eslint/no-unused-vars
connection.onRequest((method, ...params) => {
    // debugger
    console.log(method);
});
documents.onDidOpen(tern_server_1.addFile);
documents.onDidChangeContent(tern_server_1.addFile);
documents.onDidClose(tern_server_1.delFile);
connection.onReferences(tern_server_1.onReferences);
connection.onSignatureHelp(tern_server_1.onSignatureHelp);
// Listen on the connection
connection.listen();
//# sourceMappingURL=server.js.map