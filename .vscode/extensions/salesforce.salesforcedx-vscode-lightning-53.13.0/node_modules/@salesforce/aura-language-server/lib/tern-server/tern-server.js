"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importStar(require("fs"));
const tern = __importStar(require("../tern/lib/tern"));
const path_1 = __importDefault(require("path"));
const util = __importStar(require("util"));
const infer = __importStar(require("../tern/lib/infer"));
const line_column_1 = __importDefault(require("line-column"));
const string_util_1 = require("./string-util");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
let theRootPath;
let ternServer;
let asyncTernRequest;
let asyncFlush;
const defaultLibs = ['browser', 'ecmascript'];
const defaultPlugins = { modules: {}, aura: {}, doc_comment: {} };
const defaultConfig = {
    ecmaVersion: 6,
    stripCRs: false,
    disableLoadingLocal: true,
    verbose: true,
    debug: true,
    async: true,
    dependencyBudget: 20000,
};
function readJSON(fileName) {
    const file = fs_1.default.readFileSync(fileName, 'utf-8');
    try {
        return JSON.parse(file);
    }
    catch (e) {
        console.warn('Bad JSON in ' + fileName + ': ' + e.message);
    }
}
function findDefs(libs) {
    const ternlibpath = require.resolve('../tern/lib/tern');
    const ternbasedir = path_1.default.join(ternlibpath, '..', '..');
    const defs = [];
    const src = libs.slice();
    for (let file of src) {
        console.log(`Loading support library: ${file}`);
        if (!/\.json$/.test(file)) {
            file = file + '.json';
        }
        const def = path_1.default.join(ternbasedir, 'defs', file);
        if (fs_1.default.existsSync(def)) {
            defs.push(readJSON(def));
        }
        else {
            console.log(`Not found: ${file}`);
        }
    }
    return defs;
}
async function loadLocal(plugin, rootPath) {
    let found;
    try {
        // local resolution only here
        found = require.resolve('./tern-' + plugin);
    }
    catch (e) {
        return false;
    }
    const mod = await Promise.resolve().then(() => __importStar(require(found)));
    if (mod.hasOwnProperty('initialize')) {
        mod.initialize(rootPath);
    }
    return true;
}
async function loadBuiltIn(plugin, rootPath) {
    const ternlibpath = require.resolve('../tern/lib/tern');
    const ternbasedir = path_1.default.join(ternlibpath, '..', '..');
    const def = path_1.default.join(ternbasedir, 'plugin', plugin);
    let found;
    try {
        // local resolution only here
        found = require.resolve(def);
    }
    catch (e) {
        process.stderr.write('Failed to find plugin ' + plugin + '.\n');
        return false;
    }
    const mod = await Promise.resolve().then(() => __importStar(require(found)));
    if (mod.hasOwnProperty('initialize')) {
        mod.initialize(rootPath);
    }
    return true;
}
async function loadPlugins(plugins, rootPath) {
    const options = {};
    for (const plugin of Object.keys(plugins)) {
        const val = plugins[plugin];
        if (!val) {
            continue;
        }
        if (!(await loadLocal(plugin, rootPath))) {
            if (!(await loadBuiltIn(plugin, rootPath))) {
                process.stderr.write('Failed to find plugin ' + plugin + '.\n');
            }
        }
        options[path_1.default.basename(plugin)] = true;
    }
    return options;
}
function* walkSync(dir) {
    const files = fs_1.readdirSync(dir);
    for (const file of files) {
        const pathToFile = path_1.default.join(dir, file);
        const isDirectory = fs_1.statSync(pathToFile).isDirectory();
        if (isDirectory) {
            yield* walkSync(pathToFile);
        }
        else {
            yield pathToFile;
        }
    }
}
async function ternInit() {
    await asyncTernRequest({
        query: {
            type: 'ideInit',
            unloadDefs: true,
        },
    });
    const resources = path_1.default.join(__dirname, '..', '..', 'resources', 'aura');
    const found = [...walkSync(resources)];
    let [lastFile, lastText] = [undefined, undefined];
    for (const file of found) {
        if (file.endsWith('.js')) {
            const data = fs_1.readFileSync(file, 'utf-8');
            // HACK HACK HACK - glue it all together baby!
            if (file.endsWith('AuraInstance.js')) {
                lastFile = file;
                lastText = data.concat(`\nwindow['$A'] = new AuraInstance();\n`);
            }
            else {
                ternServer.addFile(file, data);
            }
        }
    }
    ternServer.addFile(lastFile, lastText);
}
const init = utils_1.memoize(ternInit);
async function startServer(rootPath, wsroot) {
    const defs = findDefs(defaultLibs);
    const plugins = await loadPlugins(defaultPlugins, rootPath);
    const config = Object.assign(Object.assign({}, defaultConfig), { defs,
        plugins, projectDir: rootPath, getFile(filename, callback) {
            // note: this isn't invoked
            fs_1.default.readFile(path_1.default.resolve(rootPath, filename), 'utf8', callback);
        } });
    theRootPath = wsroot;
    ternServer = new tern.Server(config);
    asyncTernRequest = util.promisify(ternServer.request.bind(ternServer));
    asyncFlush = util.promisify(ternServer.flush.bind(ternServer));
    init();
    return ternServer;
}
exports.startServer = startServer;
function lsp2ternPos({ line, character }) {
    return { line, ch: character };
}
function tern2lspPos({ line, ch }) {
    return { line, character: ch };
}
function fileToUri(file) {
    if (path_1.default.isAbsolute(file)) {
        return vscode_uri_1.default.file(file).toString();
    }
    else {
        return vscode_uri_1.default.file(path_1.default.join(theRootPath, file)).toString();
    }
}
function tern2lspRange({ start, end }) {
    return {
        start: tern2lspPos(start),
        end: tern2lspPos(end),
    };
}
function tern2lspLocation({ file, start, end }) {
    return {
        uri: fileToUri(file),
        range: tern2lspRange({ start, end }),
    };
}
function uriToFile(uri) {
    return vscode_uri_1.default.parse(uri).fsPath;
}
async function ternRequest(event, type, options = {}) {
    return await asyncTernRequest({
        query: Object.assign({ type, file: uriToFile(event.textDocument.uri), end: lsp2ternPos(event.position), lineCharPositions: true }, options),
    });
}
exports.addFile = (event) => {
    const { document } = event;
    ternServer.addFile(uriToFile(document.uri), document.getText());
};
exports.delFile = (close) => {
    const { document } = close;
    ternServer.delFile(uriToFile(document.uri));
};
exports.onCompletion = async (completionParams) => {
    try {
        await init();
        await asyncFlush();
        const { completions } = await ternRequest(completionParams, 'completions', {
            types: true,
            docs: true,
            depths: true,
            guess: true,
            origins: true,
            urls: true,
            expandWordForward: true,
            caseInsensitive: true,
        });
        const items = completions.map(completion => {
            let kind = 18;
            if (completion.type && completion.type.startsWith('fn')) {
                kind = 3;
            }
            return {
                documentation: completion.doc,
                detail: completion.type,
                label: completion.name,
                kind,
            };
        });
        return {
            isIncomplete: true,
            items,
        };
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
        return {
            isIncomplete: true,
            items: [],
        };
    }
};
exports.onHover = async (textDocumentPosition) => {
    try {
        await init();
        await asyncFlush();
        const info = await ternRequest(textDocumentPosition, 'type');
        const out = [];
        out.push(`${info.exprName || info.name}: ${info.type}`);
        if (info.doc) {
            out.push(info.doc);
        }
        if (info.url) {
            out.push(info.url);
        }
        return { contents: out };
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
    }
};
exports.onTypeDefinition = async (textDocumentPosition) => {
    const info = await ternRequest(textDocumentPosition, 'type');
    if (info && info.origin) {
        const contents = fs_1.default.readFileSync(info.origin, 'utf-8');
        const endCol = new line_column_1.default(contents, { origin: 0 }).fromIndex(contents.length - 1);
        return {
            uri: fileToUri(info.origin),
            range: {
                start: {
                    line: 0,
                    character: 0,
                },
                end: {
                    line: endCol.line,
                    character: endCol.col,
                },
            },
        };
    }
};
exports.onDefinition = async (textDocumentPosition) => {
    try {
        await init();
        await asyncFlush();
        const { file, start, end } = await ternRequest(textDocumentPosition, 'definition', { preferFunction: false, doc: false });
        if (file) {
            const responseURI = fileToUri(file);
            // check to see if the request position is inside the response object
            const requestURI = textDocumentPosition.textDocument.uri;
            if (responseURI === requestURI &&
                start.line === textDocumentPosition.position.line &&
                textDocumentPosition.position.character >= start.ch &&
                textDocumentPosition.position.character <= end.ch) {
                return exports.onTypeDefinition(textDocumentPosition);
            }
            if (file === 'Aura') {
                return;
            }
            else if (file.indexOf('/resources/aura/') >= 0) {
                const slice = file.slice(file.indexOf('/resources/aura/'));
                const real = path_1.default.join(__dirname, '..', '..', slice);
                return {
                    uri: vscode_uri_1.default.file(real).toString(),
                    range: tern2lspRange({ start, end }),
                };
            }
            return tern2lspLocation({ file, start, end });
        }
    }
    catch (e) {
        if (e.message && e.message.startsWith('No type found')) {
            return;
        }
    }
};
exports.onReferences = async (reference) => {
    await init();
    await asyncFlush();
    const { refs } = await ternRequest(reference, 'refs');
    if (refs && refs.length > 0) {
        return refs.map(ref => tern2lspLocation(ref));
    }
};
exports.onSignatureHelp = async (signatureParams) => {
    const { position, textDocument: { uri }, } = signatureParams;
    try {
        await init();
        await asyncFlush();
        const files = ternServer.files;
        const fileName = ternServer.normalizeFilename(uriToFile(uri));
        const file = files.find(f => f.name === fileName);
        const contents = file.text;
        const offset = new line_column_1.default(contents, { origin: 0 }).toIndex(position.line, position.character);
        const left = string_util_1.findPreviousLeftParan(contents, offset - 1);
        const word = string_util_1.findPreviousWord(contents, left);
        const info = await asyncTernRequest({
            query: {
                type: 'type',
                file: file.name,
                end: word.start,
                docs: true,
            },
        });
        const commas = string_util_1.countPreviousCommas(contents, offset - 1);
        const cx = ternServer.cx;
        let parsed;
        infer.withContext(cx, () => {
            const parser = new infer.def.TypeParser(info.type);
            parsed = parser.parseType(true);
        });
        const params = parsed.args.map((arg, index) => {
            const type = arg.getType();
            return {
                label: parsed.argNames[index],
                documentation: type.toString() + '\n' + (type.doc || ''),
            };
        });
        const sig = {
            label: parsed.argNames[commas] || 'unknown param',
            documentation: `${info.exprName || info.name}: ${info.doc}`,
            parameters: params,
        };
        const sigs = {
            signatures: [sig],
            activeSignature: 0,
            activeParameter: commas,
        };
        return sigs;
    }
    catch (e) {
        // ignore
    }
};
//# sourceMappingURL=tern-server.js.map