"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TagType;
(function (TagType) {
    TagType[TagType["STANDARD"] = 0] = "STANDARD";
    TagType[TagType["SYSTEM"] = 1] = "SYSTEM";
    TagType[TagType["CUSTOM"] = 2] = "CUSTOM";
})(TagType = exports.TagType || (exports.TagType = {}));
class TagInfo {
    constructor(file, type, lwc, attributes, location, documentation, name, namespace, properties, methods) {
        this.file = file;
        this.type = type;
        this.lwc = lwc;
        this.attributes = attributes;
        this.location = location;
        this.documentation = documentation;
        this.name = name;
        this.namespace = namespace;
        this.properties = properties;
        this.methods = methods;
        this.attributes = attributes;
        this.location = location;
        this.documentation = documentation;
        this.name = name;
        this.namespace = namespace;
        if (!this.documentation) {
            this.documentation = '';
        }
        this.properties = properties;
        this.methods = methods;
    }
    getAttributeInfo(attribute) {
        attribute = attribute.toLowerCase();
        for (const info of this.attributes) {
            if (attribute === info.name.toLowerCase()) {
                return info;
            }
        }
        return null;
    }
    getHover(hideComponentLibraryLink) {
        let retVal = this.documentation + '\n' + this.getComponentLibraryLink() + '\n### Attributes\n';
        if (hideComponentLibraryLink || this.type === TagType.CUSTOM) {
            retVal = this.documentation + '\n### Attributes\n';
        }
        for (const info of this.attributes) {
            retVal += this.getAttributeMarkdown(info);
            retVal += '\n';
        }
        const methods = (this.methods && this.methods.filter(m => m.decorator === 'api')) || [];
        if (methods.length > 0) {
            retVal += this.documentation + '\n### Methods\n';
            for (const info of methods) {
                retVal += this.getMethodMarkdown(info);
                retVal += '\n';
            }
        }
        return retVal;
    }
    getComponentLibraryLink() {
        return '[View in Component Library](https://developer.salesforce.com/docs/component-library/bundle/' + this.name + ')';
    }
    getAttributeMarkdown(attribute) {
        if (attribute.name && attribute.type && attribute.documentation) {
            return '* **' + attribute.name + '**: *' + attribute.type + '* ' + attribute.documentation;
        }
        if (attribute.name && attribute.type) {
            return '* **' + attribute.name + '**: *' + attribute.type + '*';
        }
        if (attribute.name) {
            return '* **' + attribute.name + '**';
        }
        return '';
    }
    getMethodMarkdown(method) {
        if (method.name && method.doc) {
            return '* **' + method.name + '()**: ' + method.doc;
        }
        if (method.name) {
            return '* **' + method.name + '()**';
        }
        return '';
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static createFromJSON(json) {
        return new TagInfo(json.file, json.type, json.lwc, json.attributes, json.location, json.documentation, json.name, json.namespace, json.properties, json.methods);
    }
}
exports.TagInfo = TagInfo;
//# sourceMappingURL=tagInfo.js.map