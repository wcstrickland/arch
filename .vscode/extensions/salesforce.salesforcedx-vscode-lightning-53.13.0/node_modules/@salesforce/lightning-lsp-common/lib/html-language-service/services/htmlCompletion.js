/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const htmlScanner_1 = require("../parser/htmlScanner");
const htmlTags_1 = require("../parser/htmlTags");
const tagProviders_1 = require("./tagProviders");
const htmlLanguageTypes_1 = require("../htmlLanguageTypes");
const htmlEntities_1 = require("../parser/htmlEntities");
const vscode_uri_1 = require("vscode-uri");
const componentUtil = __importStar(require("../../component-util"));
const nls = __importStar(require("vscode-nls"));
const strings_1 = require("../utils/strings");
let localize = nls.loadMessageBundle();
class HTMLCompletion {
    constructor() {
        this.completionParticipants = [];
    }
    setCompletionParticipants(registeredCompletionParticipants) {
        this.completionParticipants = registeredCompletionParticipants || [];
    }
    doComplete(document, position, htmlDocument, settings) {
        let result = {
            isIncomplete: false,
            items: [],
        };
        let completionParticipants = this.completionParticipants;
        let tagProviders = tagProviders_1.getTagProviders().filter(p => p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false));
        let text = document.getText();
        let offset = document.offsetAt(position);
        let node = htmlDocument.findNodeBefore(offset);
        if (!node) {
            return result;
        }
        let scanner = htmlScanner_1.createScanner(text, node.start);
        let currentTag = '';
        let currentAttributeName;
        function getReplaceRange(replaceStart, replaceEnd = offset) {
            if (replaceStart > offset) {
                replaceStart = offset;
            }
            return { start: document.positionAt(replaceStart), end: document.positionAt(replaceEnd) };
        }
        function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {
            let range = getReplaceRange(afterOpenBracket, tagNameEnd);
            tagProviders.forEach(provider => {
                provider.collectTags((tag, label, info) => {
                    result.items.push({
                        label: tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        detail: 'Lightning',
                        documentation: { kind: vscode_languageserver_types_1.MarkupKind.Markdown, value: info.getHover(true) },
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, tag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    });
                });
            });
            return result;
        }
        function getLineIndent(offset) {
            let start = offset;
            while (start > 0) {
                let ch = text.charAt(start - 1);
                if ('\n\r'.indexOf(ch) >= 0) {
                    return text.substring(start, offset);
                }
                if (!isWhiteSpace(ch)) {
                    return null;
                }
                start--;
            }
            return text.substring(0, offset);
        }
        function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd = offset) {
            let range = getReplaceRange(afterOpenBracket, tagNameEnd);
            let closeTag = isFollowedBy(text, tagNameEnd, htmlLanguageTypes_1.ScannerState.WithinEndTag, htmlLanguageTypes_1.TokenType.EndTagClose) ? '' : '>';
            let curr = node;
            if (inOpenTag) {
                curr = curr.parent; // don't suggest the own tag, it's not yet open
            }
            while (curr) {
                let tag = curr.tag;
                if (tag && (!curr.closed || (curr.endTagStart && curr.endTagStart > offset))) {
                    let item = {
                        label: '/' + tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        filterText: '/' + tag + closeTag,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    };
                    let startIndent = getLineIndent(curr.start);
                    let endIndent = getLineIndent(afterOpenBracket - 1);
                    if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {
                        let insertText = startIndent + '</' + tag + closeTag;
                        item.textEdit = vscode_languageserver_types_1.TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);
                        item.filterText = endIndent + '</' + tag + closeTag;
                    }
                    result.items.push(item);
                    5;
                    return result;
                }
                curr = curr.parent;
            }
            if (inOpenTag) {
                return result;
            }
            tagProviders.forEach(provider => {
                provider.collectTags((tag, label, info) => {
                    result.items.push({
                        label: '/' + tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        detail: 'Lightning',
                        documentation: { kind: vscode_languageserver_types_1.MarkupKind.Markdown, value: info.getHover(true) },
                        filterText: '/' + tag + closeTag,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    });
                });
            });
            return result;
        }
        function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {
            if (settings && settings.hideAutoCompleteProposals) {
                return result;
            }
            if (!htmlTags_1.isEmptyElement(tag)) {
                let pos = document.positionAt(tagCloseEnd);
                result.items.push({
                    label: '</' + tag + '>',
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    filterText: '</' + tag + '>',
                    textEdit: vscode_languageserver_types_1.TextEdit.insert(pos, '$0</' + tag + '>'),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                });
            }
            return result;
        }
        function collectTagSuggestions(tagStart, tagEnd) {
            collectOpenTagSuggestions(tagStart, tagEnd);
            collectCloseTagSuggestions(tagStart, true, tagEnd);
            return result;
        }
        function collectAttributeNameSuggestions(nameStart, nameEnd = offset) {
            let replaceEnd = offset;
            while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {
                // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.
                replaceEnd++;
            }
            let range = getReplaceRange(nameStart, replaceEnd);
            // LWC doesn't want quotes but aura does
            const c = settings && settings.useAttributeValueQuotes ? '="$1"' : '=$1';
            let value = isFollowedBy(text, nameEnd, htmlLanguageTypes_1.ScannerState.AfterAttributeName, htmlLanguageTypes_1.TokenType.DelimiterAssign) ? '' : c;
            let tag = currentTag; // currentTag.toLowerCase();
            let seenAttributes = Object.create(null);
            tagProviders.forEach(provider => {
                provider.collectAttributes(tag, (attribute, info, type) => {
                    if (seenAttributes[attribute]) {
                        return;
                    }
                    seenAttributes[attribute] = true;
                    let codeSnippet = attribute;
                    let command;
                    if (type !== 'v' && value.length) {
                        codeSnippet = codeSnippet + value;
                        if (type) {
                            command = {
                                title: 'Suggest',
                                command: 'editor.action.triggerSuggest',
                            };
                        }
                    }
                    let retVal = {
                        label: attribute,
                        kind: type === 'handler' ? vscode_languageserver_types_1.CompletionItemKind.Function : vscode_languageserver_types_1.CompletionItemKind.Value,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, codeSnippet),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        command,
                    };
                    if (info.documentation) {
                        retVal.documentation = info.documentation;
                        retVal.detail = info.detail;
                    }
                    result.items.push(retVal);
                });
            });
            collectDataAttributesSuggestions(range, seenAttributes);
            return result;
        }
        function collectDataAttributesSuggestions(range, seenAttributes) {
            const dataAttr = 'data-';
            let dataAttributes = {};
            dataAttributes[dataAttr] = `${dataAttr}$1="$2"`;
            function addNodeDataAttributes(node) {
                node.attributeNames.forEach(attr => {
                    if (strings_1.startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {
                        dataAttributes[attr] = attr + '="$1"';
                    }
                });
                node.children.forEach(child => addNodeDataAttributes(child));
            }
            if (htmlDocument) {
                htmlDocument.roots.forEach(root => addNodeDataAttributes(root));
            }
            Object.keys(dataAttributes).forEach(attr => result.items.push({
                label: attr,
                kind: vscode_languageserver_types_1.CompletionItemKind.Value,
                textEdit: vscode_languageserver_types_1.TextEdit.replace(range, dataAttributes[attr]),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
            }));
        }
        /**
         * If current offset is inside curly brackets expression, add public properties, private properties, handler
         * methods etc. to the suggestions list
         * @param valueStart starting index of the current text token
         * @returns returns true if expression suggestions are being provided, false otherwise
         */
        function collectExpressionSuggestions(valueStart) {
            if (valueStart >= 0 && offset < text.length && (text[offset] === '}' || text[offset] === '>')) {
                const expressionEnd = offset - 1;
                for (let i = expressionEnd; i >= valueStart; i--) {
                    if (text[i] === '{') {
                        const templateTag = componentUtil.tagFromFile(vscode_uri_1.URI.parse(document.uri).fsPath, settings.isSfdxProject);
                        if (templateTag) {
                            const range = getReplaceRange(i + 1, offset);
                            tagProviders.forEach(provider => {
                                provider.collectExpressionValues(templateTag, value => {
                                    result.items.push({
                                        label: value,
                                        kind: vscode_languageserver_types_1.CompletionItemKind.Reference,
                                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, value + (text[offset] === '}' ? '' : '}')),
                                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                                    });
                                });
                            });
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function collectAttributeValueSuggestions(valueStart, valueEnd = offset) {
            let range;
            let addQuotes;
            if (collectExpressionSuggestions(valueStart)) {
                return result;
            }
            let valuePrefix;
            if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {
                // inside quoted attribute
                let valueContentStart = valueStart + 1;
                let valueContentEnd = valueEnd;
                // valueEnd points to the char after quote, which encloses the replace range
                if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {
                    valueContentEnd--;
                }
                let wsBefore = getWordStart(text, offset, valueContentStart);
                let wsAfter = getWordEnd(text, offset, valueContentEnd);
                range = getReplaceRange(wsBefore, wsAfter);
                valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';
                addQuotes = false;
            }
            else {
                range = getReplaceRange(valueStart, valueEnd);
                valuePrefix = text.substring(valueStart, offset);
                addQuotes = true;
            }
            let tag = currentTag.toLowerCase();
            let attribute = currentAttributeName.toLowerCase();
            if (completionParticipants.length > 0) {
                let fullRange = getReplaceRange(valueStart, valueEnd);
                for (let participant of completionParticipants) {
                    if (participant.onHtmlAttributeValue) {
                        participant.onHtmlAttributeValue({ document, position, tag, attribute, value: valuePrefix, range: fullRange });
                    }
                }
            }
            let value = scanner.getTokenText();
            tagProviders.forEach(provider => {
                provider.collectValues(tag, attribute, value => {
                    let insertText = addQuotes ? '"' + value + '"' : value;
                    result.items.push({
                        label: value,
                        filterText: insertText,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Unit,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, insertText),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                    });
                });
            });
            collectCharacterEntityProposals();
            return result;
        }
        function scanNextForEndPos(nextToken) {
            if (offset === scanner.getTokenEnd()) {
                token = scanner.scan();
                if (token === nextToken && scanner.getTokenOffset() === offset) {
                    return scanner.getTokenEnd();
                }
            }
            return offset;
        }
        function collectInsideContent() {
            for (let participant of completionParticipants) {
                if (participant.onHtmlContent) {
                    participant.onHtmlContent({ document, position });
                }
            }
            return collectCharacterEntityProposals();
        }
        function collectCharacterEntityProposals() {
            // character entities
            let k = offset - 1;
            let characterStart = position.character;
            while (k >= 0 && strings_1.isLetterOrDigit(text, k)) {
                k--;
                characterStart--;
            }
            if (k >= 0 && text[k] === '&') {
                let range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(position.line, characterStart - 1), position);
                for (let entity in htmlEntities_1.entities) {
                    if (strings_1.endsWith(entity, ';')) {
                        const label = '&' + entity;
                        result.items.push({
                            label,
                            kind: vscode_languageserver_types_1.CompletionItemKind.Keyword,
                            documentation: localize('entity.propose', `Character entity representing '${htmlEntities_1.entities[entity]}'`),
                            textEdit: vscode_languageserver_types_1.TextEdit.replace(range, label),
                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,
                        });
                    }
                }
            }
            return result;
        }
        let token = scanner.scan();
        while (token !== htmlLanguageTypes_1.TokenType.EOS && scanner.getTokenOffset() <= offset) {
            switch (token) {
                case htmlLanguageTypes_1.TokenType.StartTagOpen:
                    if (scanner.getTokenEnd() === offset) {
                        let endPos = scanNextForEndPos(htmlLanguageTypes_1.TokenType.StartTag);
                        return collectTagSuggestions(offset, endPos);
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.StartTag:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    currentTag = scanner.getTokenText();
                    break;
                case htmlLanguageTypes_1.TokenType.AttributeName:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    currentAttributeName = scanner.getTokenText();
                    break;
                case htmlLanguageTypes_1.TokenType.DelimiterAssign:
                    if (scanner.getTokenEnd() === offset) {
                        let endPos = scanNextForEndPos(htmlLanguageTypes_1.TokenType.AttributeValue);
                        return collectAttributeValueSuggestions(offset, endPos);
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.AttributeValue:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.Whitespace:
                    if (offset <= scanner.getTokenEnd()) {
                        switch (scanner.getScannerState()) {
                            case htmlLanguageTypes_1.ScannerState.AfterOpeningStartTag:
                                let startPos = scanner.getTokenOffset();
                                let endTagPos = scanNextForEndPos(htmlLanguageTypes_1.TokenType.StartTag);
                                return collectTagSuggestions(startPos, endTagPos);
                            case htmlLanguageTypes_1.ScannerState.WithinTag:
                            case htmlLanguageTypes_1.ScannerState.AfterAttributeName:
                                return collectAttributeNameSuggestions(scanner.getTokenEnd());
                            case htmlLanguageTypes_1.ScannerState.BeforeAttributeValue:
                                return collectAttributeValueSuggestions(scanner.getTokenEnd());
                            case htmlLanguageTypes_1.ScannerState.AfterOpeningEndTag:
                                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                            case htmlLanguageTypes_1.ScannerState.WithinContent:
                                return collectInsideContent();
                        }
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.EndTagOpen:
                    if (offset <= scanner.getTokenEnd()) {
                        let afterOpenBracket = scanner.getTokenOffset() + 1;
                        let endOffset = scanNextForEndPos(htmlLanguageTypes_1.TokenType.EndTag);
                        return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.EndTag:
                    if (offset <= scanner.getTokenEnd()) {
                        let start = scanner.getTokenOffset() - 1;
                        while (start >= 0) {
                            let ch = text.charAt(start);
                            if (ch === '/') {
                                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());
                            }
                            else if (!isWhiteSpace(ch)) {
                                break;
                            }
                            start--;
                        }
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.StartTagClose:
                    if (offset <= scanner.getTokenEnd()) {
                        if (currentTag) {
                            return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);
                        }
                    }
                    break;
                case htmlLanguageTypes_1.TokenType.Content:
                    // TODO move this to a completion participant
                    if (collectExpressionSuggestions(scanner.getTokenLength())) {
                        return result;
                    }
                    if (offset <= scanner.getTokenEnd()) {
                        return collectInsideContent();
                    }
                    break;
                default:
                    if (collectExpressionSuggestions(scanner.getTokenLength())) {
                        return result;
                    }
                    if (offset <= scanner.getTokenEnd()) {
                        return result;
                    }
                    break;
            }
            token = scanner.scan();
        }
        return result;
    }
    doTagComplete(document, position, htmlDocument) {
        let offset = document.offsetAt(position);
        if (offset <= 0) {
            return null;
        }
        let char = document.getText().charAt(offset - 1);
        if (char === '>') {
            let node = htmlDocument.findNodeBefore(offset);
            if (node && node.tag && !htmlTags_1.isEmptyElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {
                let scanner = htmlScanner_1.createScanner(document.getText(), node.start);
                let token = scanner.scan();
                while (token !== htmlLanguageTypes_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                    if (token === htmlLanguageTypes_1.TokenType.StartTagClose && scanner.getTokenEnd() === offset) {
                        return `$0</${node.tag}>`;
                    }
                    token = scanner.scan();
                }
            }
        }
        else if (char === '/') {
            let node = htmlDocument.findNodeBefore(offset);
            while (node && node.closed) {
                node = node.parent;
            }
            if (node && node.tag) {
                let scanner = htmlScanner_1.createScanner(document.getText(), node.start);
                let token = scanner.scan();
                while (token !== htmlLanguageTypes_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                    if (token === htmlLanguageTypes_1.TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {
                        return `${node.tag}>`;
                    }
                    token = scanner.scan();
                }
            }
        }
        return null;
    }
}
exports.HTMLCompletion = HTMLCompletion;
function isQuote(s) {
    return /^["']*$/.test(s);
}
function isWhiteSpace(s) {
    return /^\s*$/.test(s);
}
function isFollowedBy(s, offset, intialState, expectedToken) {
    let scanner = htmlScanner_1.createScanner(s, offset, intialState);
    let token = scanner.scan();
    while (token === htmlLanguageTypes_1.TokenType.Whitespace) {
        token = scanner.scan();
    }
    return token === expectedToken;
}
function getWordStart(s, offset, limit) {
    while (offset > limit && !isWhiteSpace(s[offset - 1])) {
        offset--;
    }
    return offset;
}
function getWordEnd(s, offset, limit) {
    while (offset < limit && !isWhiteSpace(s[offset])) {
        offset++;
    }
    return offset;
}
//# sourceMappingURL=htmlCompletion.js.map