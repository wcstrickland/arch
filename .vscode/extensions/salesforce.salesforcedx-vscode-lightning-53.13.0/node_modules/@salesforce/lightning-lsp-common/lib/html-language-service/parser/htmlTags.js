"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*!
BEGIN THIRD PARTY
*/
/*--------------------------------------------------------------------------------------------
 *  This file is based on or incorporates material from the projects listed below (Third Party IP).
 *  The original copyright notice and the license under which Microsoft received such Third Party IP,
 *  are set forth below. Such licenses and notices are provided for informational purposes only.
 *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.
 *  Microsoft reserves all other rights not expressly granted under this agreement, whether by implication,
 *  estoppel or otherwise.
 *--------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------
 *  Copyright © 2015 W3C® (MIT, ERCIM, Keio, Beihang). This software or document includes includes material copied
 *  from or derived from HTML 5.1 W3C Working Draft (http://www.w3.org/TR/2015/WD-html51-20151008/.)"
 *--------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------
 *  Ionic Main Site (https://github.com/driftyco/ionic-site).
 *  Copyright Drifty Co. http://drifty.com/.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 *  except in compliance with the License. You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
 *  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 *  MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 *  See the Apache Version 2.0 License for specific language governing permissions
 *  and limitations under the License.
 *--------------------------------------------------------------------------------------------*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const strings = __importStar(require("../utils/strings"));
const arrays = __importStar(require("../utils/arrays"));
const nls = __importStar(require("vscode-nls"));
let localize = nls.loadMessageBundle();
exports.EMPTY_ELEMENTS = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'menuitem',
    'meta',
    'param',
    'source',
    'track',
    'wbr',
];
function isEmptyElement(e) {
    return !!e && arrays.binarySearch(exports.EMPTY_ELEMENTS, e.toLowerCase(), (s1, s2) => s1.localeCompare(s2)) >= 0;
}
exports.isEmptyElement = isEmptyElement;
class HTMLTagSpecification {
    constructor(label, attributes = []) {
        this.label = label;
        this.attributes = attributes;
    }
}
exports.HTMLTagSpecification = HTMLTagSpecification;
function collectTagsDefault(collector, tagSet) {
    for (var tag in tagSet) {
        collector(tag, tagSet[tag].label);
    }
}
function collectValuesDefault(tag, attribute, collector, tagSet, globalAttributes, valueSets, customTags) {
    var prefix = attribute + ':';
    var processAttributes = (attributes) => {
        attributes.forEach(attr => {
            if (attr.length > prefix.length && strings.startsWith(attr, prefix)) {
                var typeInfo = attr.substr(prefix.length);
                if (typeInfo === 'v') {
                    collector(attribute);
                }
                else {
                    var values = valueSets[typeInfo];
                    if (values) {
                        values.forEach(collector);
                    }
                }
            }
        });
    };
    if (tag) {
        var tags = tagSet[tag];
        if (tags) {
            var attributes = tags.attributes;
            if (attributes) {
                processAttributes(attributes);
            }
        }
    }
    processAttributes(globalAttributes);
    if (customTags) {
        var customTagAttributes = customTags[tag];
        if (customTagAttributes) {
            processAttributes(customTagAttributes);
        }
    }
}
/*!
END THIRD PARTY
*/
//# sourceMappingURL=htmlTags.js.map