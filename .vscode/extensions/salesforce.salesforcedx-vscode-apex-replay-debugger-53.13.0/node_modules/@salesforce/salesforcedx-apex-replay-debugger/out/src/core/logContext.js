"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/cli");
const requestService_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/requestService");
const path = require("path");
const breakpoints_1 = require("../breakpoints");
const commands_1 = require("../commands");
const constants_1 = require("../constants");
const messages_1 = require("../messages");
const states_1 = require("../states");
const handles_1 = require("./handles");
const heapDump_1 = require("./heapDump");
const logContextUtil_1 = require("./logContextUtil");
class LogContext {
    constructor(launchArgs, session) {
        this.util = new logContextUtil_1.LogContextUtil();
        this.logLines = [];
        this.frameHandles = new handles_1.Handles();
        this.staticVariablesClassMap = new Map();
        this.refsMap = new Map();
        this.variableHandles = new handles_1.Handles();
        this.stackFrameInfos = [];
        this.logLinePosition = -1;
        this.execAnonMapping = new Map();
        this.apexHeapDumps = [];
        this.lastSeenHeapDumpClass = '';
        this.lastSeenHeapDumpLine = -1;
        this.backupStackFrameInfos = this.stackFrameInfos;
        this.backupFrameHandles = this.frameHandles;
        this.backupRefsMap = this.refsMap;
        this.backupStaticVariablesClassMap = this.staticVariablesClassMap;
        this.backupVariableHandles = this.variableHandles;
        this.launchArgs = launchArgs;
        this.session = session;
        this.logLines = this.util.readLogFile(launchArgs.logFile);
        this.logSize = this.util.getFileSize(launchArgs.logFile);
    }
    getUtil() {
        return this.util;
    }
    getLaunchArgs() {
        return this.launchArgs;
    }
    getSession() {
        return this.session;
    }
    getLogLines() {
        return this.logLines;
    }
    getLogSize() {
        return this.logSize;
    }
    hasLogLines() {
        return (this.logLines &&
            this.logLines.length > 0 &&
            this.logLinePosition < this.logLines.length);
    }
    meetsLogLevelRequirements() {
        return (this.logLines &&
            this.logLines.length > 0 &&
            this.logLines[0].match(/(\d{2}.*APEX_CODE,FINEST;.*VISUALFORCE,FINER;.*|\d{2}.*APEX_CODE,FINEST;.*VISUALFORCE,FINEST;.*)/) !== null);
    }
    getHeapDumps() {
        return this.apexHeapDumps;
    }
    hasHeapDump() {
        return this.apexHeapDumps.length > 0;
    }
    getHeapDumpForThisLocation(frameName, lineNumber) {
        for (const heapdump of this.apexHeapDumps) {
            if (frameName.includes(heapdump.getClassName()) &&
                lineNumber === heapdump.getLine()) {
                return heapdump;
            }
        }
    }
    hasHeapDumpForTopFrame() {
        const topFrame = this.getTopFrame();
        if (topFrame) {
            const heapDump = this.getHeapDumpForThisLocation(topFrame.name, topFrame.line);
            if (heapDump &&
                topFrame.name.includes(this.lastSeenHeapDumpClass) &&
                topFrame.line === this.lastSeenHeapDumpLine) {
                return heapDump.getHeapDumpId();
            }
        }
    }
    resetLastSeenHeapDumpLogLine() {
        this.lastSeenHeapDumpClass = '';
        this.lastSeenHeapDumpLine = -1;
    }
    isRunningApexTrigger() {
        const topFrame = this.getTopFrame();
        if (topFrame &&
            topFrame.source &&
            topFrame.source.name.toLowerCase().endsWith('.trigger')) {
            return true;
        }
        return false;
    }
    copyStateForHeapDump() {
        this.backupStackFrameInfos = JSON.parse(JSON.stringify(this.stackFrameInfos));
        this.backupFrameHandles = this.frameHandles.copy();
        this.backupRefsMap = new Map();
        this.backupVariableHandles = new handles_1.Handles();
        this.cloneStaticVariablesClassMap();
        for (const backupFrame of this.backupStackFrameInfos) {
            const frameInfo = this.backupFrameHandles.get(backupFrame.id);
            this.copyVariableContainers(frameInfo.locals);
            this.copyVariableContainers(frameInfo.statics);
        }
    }
    copyVariableContainers(variables) {
        variables.forEach((value, key) => {
            const variableContainer = value;
            if (variableContainer.ref) {
                this.backupRefsMap.set(variableContainer.ref, variableContainer);
                const newRef = this.backupVariableHandles.create(variableContainer);
                variableContainer.variablesRef = newRef;
                this.copyVariableContainers(variableContainer.variables);
            }
        });
    }
    cloneStaticVariablesClassMap() {
        this.backupStaticVariablesClassMap = new Map();
        this.staticVariablesClassMap.forEach((value, key) => {
            const varMap = value;
            const newMap = new Map();
            varMap.forEach((innerValue, innerKey) => {
                const variable = innerValue;
                newMap.set(innerKey, variable.copy());
            });
            this.backupStaticVariablesClassMap.set(key, newMap);
        });
    }
    revertStateAfterHeapDump() {
        this.staticVariablesClassMap = this.backupStaticVariablesClassMap;
        this.stackFrameInfos = this.backupStackFrameInfos;
        this.frameHandles = this.backupFrameHandles;
        this.refsMap = this.backupRefsMap;
        this.variableHandles = this.backupVariableHandles;
    }
    scanLogForHeapDumpLines() {
        const heapDumpRegex = RegExp(/\|HEAP_DUMP\|/);
        this.logLines.forEach((line, index) => {
            if (heapDumpRegex.test(line)) {
                const splitLine = line.split('|');
                if (splitLine.length >= 7) {
                    const heapDump = new heapDump_1.ApexHeapDump(splitLine[3] /* heapDumpId */, splitLine[4] /* className */, splitLine[5] /* namespace */, Number(splitLine[6]) /* line */);
                    this.apexHeapDumps.push(heapDump);
                }
                else {
                    // With the way log lines are, this would only happen
                    // if the user manually edited the log file.
                    this.session.printToDebugConsole(messages_1.nls.localize('malformed_log_line', index + 1, line));
                }
            }
        });
        return this.apexHeapDumps.length > 0;
    }
    fetchOverlayResultsForApexHeapDumps(projectPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let success = true;
            try {
                const orgInfo = yield new cli_1.ForceOrgDisplay().getOrgInfo(projectPath);
                const requestService = new requestService_1.RequestService();
                requestService.instanceUrl = orgInfo.instanceUrl;
                requestService.accessToken = orgInfo.accessToken;
                for (const heapDump of this.apexHeapDumps) {
                    this.session.printToDebugConsole(messages_1.nls.localize('fetching_heap_dump', heapDump.toString()));
                    const overlayActionCommand = new commands_1.ApexExecutionOverlayResultCommand(heapDump.getHeapDumpId());
                    let errorString;
                    let returnString;
                    yield requestService
                        .execute(overlayActionCommand, requestService_1.RestHttpMethodEnum.Get)
                        .then(value => {
                        returnString = value;
                    }, reason => {
                        errorString = reason;
                    });
                    if (returnString) {
                        heapDump.setOverlaySuccessResult(JSON.parse(returnString));
                    }
                    else if (errorString) {
                        try {
                            success = false;
                            const error = JSON.parse(errorString);
                            const errorMessage = messages_1.nls.localize('heap_dump_error', error[0].message, error[0].errorCode, heapDump.toString());
                            this.session.errorToDebugConsole(errorMessage);
                        }
                        catch (error) {
                            const errorMessage = `${error}. ${errorString}. ${heapDump.toString()}`;
                            this.session.errorToDebugConsole(errorMessage);
                        }
                    }
                }
            }
            catch (error) {
                success = false;
                const result = JSON.parse(error);
                const errorMessage = `${messages_1.nls.localize('unable_to_retrieve_org_info')} : ${result.message}`;
                this.session.errorToDebugConsole(errorMessage);
            }
            return success;
        });
    }
    getLogFileName() {
        return path.basename(this.launchArgs.logFile);
    }
    getLogFilePath() {
        return this.launchArgs.logFile;
    }
    getLogLinePosition() {
        return this.logLinePosition;
    }
    incrementLogLinePosition() {
        this.logLinePosition += 1;
    }
    getFrames() {
        return this.stackFrameInfos;
    }
    getNumOfFrames() {
        return this.stackFrameInfos.length;
    }
    getTopFrame() {
        if (this.stackFrameInfos.length > 0) {
            return this.stackFrameInfos[this.stackFrameInfos.length - 1];
        }
    }
    getRefsMap() {
        return this.refsMap;
    }
    getStaticVariablesClassMap() {
        return this.staticVariablesClassMap;
    }
    getFrameHandler() {
        return this.frameHandles;
    }
    getVariableHandler() {
        return this.variableHandles;
    }
    setState(state) {
        this.state = state;
    }
    hasState() {
        return this.state !== undefined;
    }
    getExecAnonScriptLocationInDebugLog(scriptLine) {
        return this.execAnonMapping.get(scriptLine) || 0;
    }
    getExecAnonScriptMapping() {
        return this.execAnonMapping;
    }
    getUriFromSignature(signature) {
        if (signature === constants_1.EXEC_ANON_SIGNATURE) {
            return this.getLogFilePath();
        }
        const processedSignature = signature.endsWith(')')
            ? signature.substring(0, signature.substring(0, signature.indexOf('(')).lastIndexOf('.'))
            : signature;
        const typerefMapping = breakpoints_1.breakpointUtil.getTyperefMapping();
        let uri = '';
        typerefMapping.forEach((value, key) => {
            let processedKey = '';
            if (key.startsWith(constants_1.SFDC_TRIGGER)) {
                processedKey = key;
            }
            else {
                processedKey = key.replace('/', '.').replace('$', '.');
            }
            if (processedKey === processedSignature) {
                uri = value;
                return;
            }
        });
        return uri;
    }
    hasFrames() {
        return this.stackFrameInfos && this.stackFrameInfos.length > 0;
    }
    updateFrames() {
        if (this.hasHeapDump()) {
            this.revertStateAfterHeapDump();
        }
        if (this.state instanceof states_1.LogEntryState) {
            this.stackFrameInfos.pop();
        }
        while (++this.logLinePosition < this.logLines.length) {
            const logLine = this.logLines[this.logLinePosition];
            if (logLine) {
                this.setState(this.parseLogEvent(logLine));
                if (this.session.shouldTraceLogFile() &&
                    !(this.state instanceof states_1.UserDebugState)) {
                    this.session.printToDebugConsole(logLine);
                }
                if (this.state && this.state.handle(this)) {
                    break;
                }
            }
        }
    }
    parseLogEvent(logLine) {
        if (this.state === undefined) {
            return new states_1.LogEntryState();
        }
        if (logLine.startsWith(constants_1.EVENT_EXECUTE_ANONYMOUS)) {
            this.execAnonMapping.set(this.execAnonMapping.size + 1, this.logLinePosition + 1);
        }
        const fields = logLine.split('|');
        if (fields.length >= 3) {
            switch (fields[1]) {
                case constants_1.EVENT_CODE_UNIT_STARTED:
                case constants_1.EVENT_CONSTRUCTOR_ENTRY:
                case constants_1.EVENT_METHOD_ENTRY:
                    return new states_1.FrameEntryState(fields);
                case constants_1.EVENT_VF_APEX_CALL_START:
                    if (states_1.FrameStateUtil.isExtraneousVFGetterOrSetterLogLine(fields[fields.length - 2])) {
                        return new states_1.NoOpState();
                    }
                    else {
                        return new states_1.FrameEntryState(fields);
                    }
                case constants_1.EVENT_CODE_UNIT_FINISHED:
                case constants_1.EVENT_CONSTRUCTOR_EXIT:
                case constants_1.EVENT_METHOD_EXIT:
                    return new states_1.FrameExitState(fields);
                case constants_1.EVENT_VARIABLE_SCOPE_BEGIN:
                    return new states_1.VariableBeginState(fields);
                case constants_1.EVENT_VARIABLE_ASSIGNMENT:
                    return new states_1.VariableAssignmentState(fields);
                case constants_1.EVENT_VF_APEX_CALL_END:
                    if (states_1.FrameStateUtil.isExtraneousVFGetterOrSetterLogLine(fields[fields.length - 2])) {
                        return new states_1.NoOpState();
                    }
                    else {
                        return new states_1.FrameExitState(fields);
                    }
                case constants_1.EVENT_STATEMENT_EXECUTE:
                    if (logLine.match(/.*\|.*\|\[\d{1,}\]/)) {
                        fields[2] = this.util.stripBrackets(fields[2]);
                        return new states_1.StatementExecuteState(fields);
                    }
                    break;
                case constants_1.EVENT_USER_DEBUG:
                    if (logLine.match(/.*\|.*\|\[\d{1,}\]\|.*\|.*/)) {
                        fields[2] = this.util.stripBrackets(fields[2]);
                        return new states_1.UserDebugState(fields);
                    }
                    break;
                case constants_1.EVENT_HEAP_DUMP:
                    if (logLine.match(/.+\|HEAP_DUMP|\[\d+\]|.+\|.+\|\d+/)) {
                        const splitLine = logLine.split('|');
                        this.lastSeenHeapDumpClass = splitLine[4];
                        this.lastSeenHeapDumpLine = Number(splitLine[6]);
                    }
                    break;
                default:
                    return new states_1.NoOpState();
            }
        }
        return new states_1.NoOpState();
    }
}
exports.LogContext = LogContext;
//# sourceMappingURL=logContext.js.map