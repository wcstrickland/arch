"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
class BreakpointUtil {
    constructor() {
        this.lineNumberMapping = new Map();
        this.typerefMapping = new Map();
    }
    setValidLines(lineNumberMapping, typerefMapping) {
        this.lineNumberMapping = lineNumberMapping;
        this.typerefMapping = typerefMapping;
    }
    static getInstance() {
        if (!BreakpointUtil.instance) {
            BreakpointUtil.instance = new BreakpointUtil();
        }
        return BreakpointUtil.instance;
    }
    static setInstance(inputInstance) {
        BreakpointUtil.instance = inputInstance;
    }
    hasLineNumberMapping() {
        return this.lineNumberMapping && this.lineNumberMapping.size > 0;
    }
    getLineNumberMapping() {
        return this.lineNumberMapping;
    }
    getTyperefMapping() {
        return this.typerefMapping;
    }
    canSetLineBreakpoint(uri, line) {
        return (this.lineNumberMapping.has(uri) &&
            this.lineNumberMapping.get(uri).indexOf(line) !== -1);
    }
    createMappingsFromLineBreakpointInfo(lineBpInfo) {
        // clear out any existing mapping
        this.lineNumberMapping.clear();
        this.typerefMapping.clear();
        // set the mapping from the source line info
        for (const info of lineBpInfo) {
            if (!this.lineNumberMapping.has(info.uri)) {
                this.lineNumberMapping.set(info.uri, []);
            }
            this.lineNumberMapping.set(info.uri, this.lineNumberMapping.get(info.uri).concat(info.lines));
            this.typerefMapping.set(info.typeref, info.uri);
        }
    }
    returnLinesForLoggingFromBreakpointArgs(bpArr) {
        return bpArr.map(bp => bp.line).join(',');
    }
    getTopLevelTyperefForUri(uriInput) {
        let returnValue = '';
        this.typerefMapping.forEach((value, key) => {
            if (value === uriInput) {
                if (key.indexOf('$') === -1) {
                    returnValue = key;
                    return;
                }
            }
        });
        return returnValue;
    }
}
exports.BreakpointUtil = BreakpointUtil;
//# sourceMappingURL=breakpointUtil.js.map