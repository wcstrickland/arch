"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const vscode_debugadapter_1 = require("vscode-debugadapter");
const breakpoints_1 = require("../breakpoints");
const constants_1 = require("../constants");
const heapDumpService_1 = require("../core/heapDumpService");
const logContext_1 = require("../core/logContext");
const messages_1 = require("../messages");
const TRACE_ALL = 'all';
const TRACE_CATEGORY_PROTOCOL = 'protocol';
const TRACE_CATEGORY_LOGFILE = 'logfile';
const TRACE_CATEGORY_LAUNCH = 'launch';
const TRACE_CATEGORY_BREAKPOINTS = 'breakpoints';
var Step;
(function (Step) {
    Step[Step["Over"] = 0] = "Over";
    Step[Step["In"] = 1] = "In";
    Step[Step["Out"] = 2] = "Out";
    Step[Step["Run"] = 3] = "Run";
})(Step = exports.Step || (exports.Step = {}));
class ApexVariable extends vscode_debugadapter_1.Variable {
    constructor(name, value, type, ref = 0, apexRef) {
        super(name, value, ref);
        this.type = type;
        this.apexRef = apexRef;
        this.evaluateName = value;
    }
}
exports.ApexVariable = ApexVariable;
class ApexDebugStackFrameInfo {
    constructor(frameNumber, signature) {
        this.frameNumber = frameNumber;
        this.signature = signature;
        this.statics = new Map();
        this.locals = new Map();
        this.globals = new Map();
    }
    copy() {
        const me = new ApexDebugStackFrameInfo(this.frameNumber, this.signature);
        this.statics.forEach((value, key) => {
            me.statics.set(key, value.copy());
        });
        this.locals.forEach((value, key) => {
            me.locals.set(key, value.copy());
        });
        return me;
    }
}
exports.ApexDebugStackFrameInfo = ApexDebugStackFrameInfo;
var SCOPE_TYPES;
(function (SCOPE_TYPES) {
    SCOPE_TYPES["LOCAL"] = "local";
    SCOPE_TYPES["STATIC"] = "static";
    SCOPE_TYPES["GLOBAL"] = "global";
})(SCOPE_TYPES = exports.SCOPE_TYPES || (exports.SCOPE_TYPES = {}));
class VariableContainer {
    constructor(variables = new Map()) {
        this.variables = variables;
    }
    getAllVariables() {
        const result = [];
        this.variables.forEach(container => {
            const avc = container;
            result.push(new ApexVariable(avc.name, avc.value, avc.type, avc.variablesRef));
        });
        return result;
    }
    copy() {
        const me = Object.assign(Object.create(Object.getPrototypeOf(this)));
        me.variables = new Map();
        this.variables.forEach((value, key) => {
            me.variables.set(key, value.copy());
        });
        return me;
    }
}
exports.VariableContainer = VariableContainer;
class ApexVariableContainer extends VariableContainer {
    constructor(name, value, type, ref, variablesRef = 0) {
        super();
        this.name = name;
        this.value = value;
        this.type = type;
        this.ref = ref;
        this.variablesRef = variablesRef;
    }
    copy() {
        const me = super.copy();
        me.name = this.name;
        me.value = this.value;
        me.type = this.type;
        me.ref = this.ref;
        me.variablesRef = this.variablesRef;
        return me;
    }
}
exports.ApexVariableContainer = ApexVariableContainer;
class ScopeContainer extends VariableContainer {
    constructor(type, variables) {
        super(variables);
        this.type = type;
    }
    getAllVariables() {
        const apexVariables = [];
        this.variables.forEach(entry => {
            const avc = entry;
            apexVariables.push(new ApexVariable(avc.name, avc.value, avc.type, avc.variablesRef));
        });
        return apexVariables;
    }
}
exports.ScopeContainer = ScopeContainer;
class ApexReplayDebug extends vscode_debugadapter_1.LoggingDebugSession {
    constructor() {
        super('apex-replay-debug-adapter.log');
        this.trace = [];
        this.traceAll = false;
        this.breakpoints = new Map();
        this.setDebuggerLinesStartAt1(true);
        this.setDebuggerPathFormat('uri');
    }
    initializeRequest(response, args) {
        this.initializedResponse = response;
        this.initializedResponse.body = {
            supportsConfigurationDoneRequest: true,
            supportsCompletionsRequest: false,
            supportsConditionalBreakpoints: true,
            supportsDelayedStackTraceLoading: false,
            supportsEvaluateForHovers: false,
            supportsExceptionInfoRequest: false,
            supportsExceptionOptions: false,
            supportsFunctionBreakpoints: false,
            supportsHitConditionalBreakpoints: false,
            supportsLoadedSourcesRequest: false,
            supportsRestartFrame: false,
            supportsSetVariable: false,
            supportsStepBack: false,
            supportsStepInTargetsRequest: false
        };
        this.initializedResponse.success = true;
        this.sendResponse(this.initializedResponse);
    }
    launchRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let lineBreakpointInfoAvailable = false;
            if (args && args.lineBreakpointInfo) {
                lineBreakpointInfoAvailable = true;
                breakpoints_1.breakpointUtil.createMappingsFromLineBreakpointInfo(args.lineBreakpointInfo);
                delete args.lineBreakpointInfo;
            }
            this.projectPath = args.projectPath;
            response.success = false;
            this.setupLogger(args);
            this.log(TRACE_CATEGORY_LAUNCH, `launchRequest: args=${JSON.stringify(args)}`);
            this.logContext = new logContext_1.LogContext(args, this);
            this.heapDumpService = new heapDumpService_1.HeapDumpService(this.logContext);
            if (!this.logContext.hasLogLines()) {
                response.message = messages_1.nls.localize('no_log_file_text');
            }
            else if (!this.logContext.meetsLogLevelRequirements()) {
                response.message = messages_1.nls.localize('incorrect_log_levels_text');
            }
            else if (!lineBreakpointInfoAvailable) {
                response.message = messages_1.nls.localize('session_language_server_error_text');
            }
            else {
                this.printToDebugConsole(messages_1.nls.localize('session_started_text', this.logContext.getLogFileName()));
                if (this.projectPath &&
                    this.logContext.scanLogForHeapDumpLines() &&
                    !(yield this.logContext.fetchOverlayResultsForApexHeapDumps(this.projectPath))) {
                    response.message = messages_1.nls.localize('heap_dump_error_wrap_up_text');
                    this.errorToDebugConsole(messages_1.nls.localize('heap_dump_error_wrap_up_text'));
                }
                response.success = true;
            }
            this.sendResponse(response);
            this.sendEvent(new vscode_debugadapter_1.InitializedEvent());
            this.sendEvent(new vscode_debugadapter_1.Event(constants_1.SEND_METRIC_LAUNCH_EVENT, {
                logSize: this.logContext.getLogSize(),
                error: {
                    subject: response.message
                }
            }));
        });
    }
    setupLogger(args) {
        if (typeof args.trace === 'boolean') {
            this.trace = args.trace ? [TRACE_ALL] : [];
            this.traceAll = args.trace;
        }
        else if (typeof args.trace === 'string') {
            this.trace = args.trace.split(',').map(category => category.trim());
            this.traceAll = this.trace.indexOf(TRACE_ALL) >= 0;
        }
        if (this.trace && this.trace.indexOf(TRACE_CATEGORY_PROTOCOL) >= 0) {
            vscode_debugadapter_1.logger.setup(vscode_debugadapter_1.Logger.LogLevel.Verbose, false);
        }
        else {
            vscode_debugadapter_1.logger.setup(vscode_debugadapter_1.Logger.LogLevel.Stop, false);
        }
    }
    configurationDoneRequest(response, args) {
        if (this.logContext.getLaunchArgs().stopOnEntry) {
            // Stop in the debug log
            this.logContext.updateFrames();
            this.sendEvent(new vscode_debugadapter_1.StoppedEvent('entry', ApexReplayDebug.THREAD_ID));
        }
        else {
            // Set breakpoints first, then try to continue to the next breakpoint
            this.continueRequest({}, {
                threadId: ApexReplayDebug.THREAD_ID
            });
        }
    }
    disconnectRequest(response, args) {
        this.printToDebugConsole(messages_1.nls.localize('session_terminated_text'));
        response.success = true;
        this.sendResponse(response);
    }
    threadsRequest(response) {
        response.body = {
            threads: [new vscode_debugadapter_1.Thread(ApexReplayDebug.THREAD_ID, '')]
        };
        response.success = true;
        this.sendResponse(response);
    }
    stackTraceRequest(response, args) {
        response.body = {
            stackFrames: this.logContext
                .getFrames()
                .slice()
                .reverse()
        };
        response.success = true;
        this.sendResponse(response);
    }
    scopesRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const heapDumpId = this.logContext.hasHeapDumpForTopFrame();
            if (heapDumpId) {
                try {
                    this.logContext.copyStateForHeapDump();
                    this.heapDumpService.replaceVariablesWithHeapDump();
                }
                catch (error) {
                    this.sendEvent(new vscode_debugadapter_1.Event(constants_1.SEND_METRIC_ERROR_EVENT, {
                        subject: error.message,
                        callstack: error.stack
                    }));
                    this.logContext.revertStateAfterHeapDump();
                    this.warnToDebugConsole(messages_1.nls.localize('reconcile_heapdump_error', error, heapDumpId, heapDumpId));
                }
                finally {
                    this.logContext.resetLastSeenHeapDumpLogLine();
                }
            }
            response.success = true;
            const frameInfo = this.logContext.getFrameHandler().get(args.frameId);
            if (!frameInfo) {
                response.body = { scopes: [] };
                this.sendResponse(response);
                return;
            }
            const scopes = new Array();
            scopes.push(new vscode_debugadapter_1.Scope('Local', this.logContext
                .getVariableHandler()
                .create(new ScopeContainer(SCOPE_TYPES.LOCAL, frameInfo.locals)), false));
            scopes.push(new vscode_debugadapter_1.Scope('Static', this.logContext
                .getVariableHandler()
                .create(new ScopeContainer(SCOPE_TYPES.STATIC, frameInfo.statics)), false));
            scopes.push(new vscode_debugadapter_1.Scope('Global', this.logContext
                .getVariableHandler()
                .create(new ScopeContainer(SCOPE_TYPES.GLOBAL, frameInfo.globals)), false));
            response.body = { scopes };
            this.sendResponse(response);
        });
    }
    variablesRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = true;
            const scopesContainer = this.logContext
                .getVariableHandler()
                .get(args.variablesReference);
            response.body = {
                variables: scopesContainer ? scopesContainer.getAllVariables() : []
            };
            this.sendResponse(response);
        });
    }
    evaluateRequest(response, args) {
        response.body = {
            result: args.expression,
            variablesReference: 0
        };
        response.success = true;
        this.sendResponse(response);
    }
    continueRequest(response, args) {
        this.executeStep(response, Step.Run);
    }
    nextRequest(response, args) {
        this.executeStep(response, Step.Over);
    }
    stepInRequest(response, args) {
        this.executeStep(response, Step.In);
    }
    stepOutRequest(response, args) {
        this.executeStep(response, Step.Out);
    }
    executeStep(response, stepType) {
        response.success = true;
        this.sendResponse(response);
        const prevNumOfFrames = this.logContext.getNumOfFrames();
        while (this.logContext.hasLogLines()) {
            this.logContext.updateFrames();
            const curNumOfFrames = this.logContext.getNumOfFrames();
            if ((stepType === Step.Over &&
                curNumOfFrames !== 0 &&
                curNumOfFrames <= prevNumOfFrames) ||
                (stepType === Step.In && curNumOfFrames >= prevNumOfFrames) ||
                (stepType === Step.Out &&
                    curNumOfFrames !== 0 &&
                    curNumOfFrames < prevNumOfFrames)) {
                return this.sendEvent(new vscode_debugadapter_1.StoppedEvent('step', ApexReplayDebug.THREAD_ID));
            }
            if (this.shouldStopForBreakpoint()) {
                return;
            }
        }
        this.sendEvent(new vscode_debugadapter_1.TerminatedEvent());
    }
    shouldStopForBreakpoint() {
        const topFrame = this.logContext.getTopFrame();
        if (topFrame && topFrame.source) {
            const topFrameUri = this.convertClientPathToDebugger(topFrame.source.path);
            const topFrameLine = this.convertClientLineToDebugger(topFrame.line);
            if (this.breakpoints.has(topFrameUri) &&
                this.breakpoints.get(topFrameUri).indexOf(topFrameLine) !== -1) {
                this.sendEvent(new vscode_debugadapter_1.StoppedEvent('breakpoint', ApexReplayDebug.THREAD_ID));
                return true;
            }
        }
        return false;
    }
    setBreakPointsRequest(response, args) {
        response.body = { breakpoints: [] };
        if (args.source.path && args.breakpoints) {
            const uri = this.convertClientPathToDebugger(args.source.path);
            this.log(TRACE_CATEGORY_BREAKPOINTS, `setBreakPointsRequest: path=${args.source.path} uri=${uri} lines=${breakpoints_1.breakpointUtil.returnLinesForLoggingFromBreakpointArgs(args.breakpoints)}`);
            this.breakpoints.set(uri, []);
            for (const bp of args.breakpoints) {
                const isVerified = breakpoints_1.breakpointUtil.canSetLineBreakpoint(uri, this.convertClientLineToDebugger(bp.line));
                response.body.breakpoints.push({
                    verified: isVerified,
                    source: args.source,
                    line: bp.line
                });
                if (isVerified) {
                    this.breakpoints
                        .get(uri)
                        .push(this.convertClientLineToDebugger(bp.line));
                }
            }
            this.log(TRACE_CATEGORY_BREAKPOINTS, `setBreakPointsRequest: path=${args.source.path} verified lines=${this.breakpoints.get(uri).join(',')}`);
        }
        response.success = true;
        this.sendResponse(response);
    }
    log(traceCategory, message) {
        if (this.trace &&
            (this.traceAll || this.trace.indexOf(traceCategory) >= 0)) {
            this.printToDebugConsole(`${process.pid}: ${message}`);
        }
    }
    shouldTraceLogFile() {
        return this.traceAll || this.trace.indexOf(TRACE_CATEGORY_LOGFILE) !== -1;
    }
    printToDebugConsole(msg, sourceFile, sourceLine, category = 'stdout') {
        if (msg && msg.length !== 0) {
            const event = new vscode_debugadapter_1.OutputEvent(`${msg}${os_1.EOL}`, category);
            event.body.source = sourceFile;
            event.body.line = sourceLine;
            event.body.column = 0;
            this.sendEvent(event);
        }
    }
    warnToDebugConsole(msg, sourceFile, sourceLine) {
        this.printToDebugConsole(msg, sourceFile, sourceLine, 'console');
    }
    errorToDebugConsole(msg, sourceFile, sourceLine) {
        this.printToDebugConsole(msg, sourceFile, sourceLine, 'stderr');
    }
}
exports.ApexReplayDebug = ApexReplayDebug;
ApexReplayDebug.THREAD_ID = 1;
vscode_debugadapter_1.DebugSession.run(ApexReplayDebug);
//# sourceMappingURL=apexReplayDebug.js.map