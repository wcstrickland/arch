"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const vscode_debugadapter_1 = require("vscode-debugadapter");
const vscode_uri_1 = require("vscode-uri");
const apexReplayDebug_1 = require("../adapter/apexReplayDebug");
const frameState_1 = require("./frameState");
class FrameEntryState extends frameState_1.FrameState {
    constructor(fields) {
        super(fields);
    }
    handle(logContext) {
        const sourceUri = logContext.getUriFromSignature(this._signature);
        const frame = new apexReplayDebug_1.ApexDebugStackFrameInfo(logContext.getFrames().length, this._signature);
        const id = logContext.getFrameHandler().create(frame);
        const className = this._signature.indexOf('.') > -1
            ? this._signature.substring(0, this._signature.lastIndexOf('.'))
            : this._signature;
        if (logContext.getStaticVariablesClassMap().has(className)) {
            frame.statics = logContext.getStaticVariablesClassMap().get(className);
        }
        else {
            logContext.getStaticVariablesClassMap().set(className, frame.statics);
        }
        logContext
            .getFrames()
            .push(new vscode_debugadapter_1.StackFrame(id, this._frameName, sourceUri
            ? new vscode_debugadapter_1.Source(path_1.basename(sourceUri), vscode_uri_1.default.parse(sourceUri).fsPath)
            : undefined, undefined));
        return false;
    }
}
exports.FrameEntryState = FrameEntryState;
//# sourceMappingURL=frameEntryState.js.map