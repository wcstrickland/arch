/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See OSSREADME.json in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const htmlScanner_1 = require("../parser/htmlScanner");
const htmlTags_1 = require("../parser/htmlTags");
const tagProviders_1 = require("./tagProviders");
function doComplete(document, position, htmlDocument, settings) {
    const result = {
        isIncomplete: false,
        items: []
    };
    const tagProviders = tagProviders_1.allTagProviders.filter(p => p.isApplicable(document.languageId) &&
        (!settings || settings[p.getId()] !== false));
    const offset = document.offsetAt(position);
    const node = htmlDocument.findNodeBefore(offset);
    if (!node) {
        return result;
    }
    const text = document.getText();
    const scanner = htmlScanner_1.createScanner(text, node.start);
    let currentTag;
    let currentAttributeName;
    function getReplaceRange(replaceStart, replaceEnd = offset) {
        if (replaceStart > offset) {
            replaceStart = offset;
        }
        return {
            start: document.positionAt(replaceStart),
            end: document.positionAt(replaceEnd)
        };
    }
    function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {
        const range = getReplaceRange(afterOpenBracket, tagNameEnd);
        tagProviders.forEach(provider => {
            provider.collectTags((tag, label) => {
                result.items.push({
                    label: tag,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    documentation: label,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, tag),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                });
            });
        });
        return result;
    }
    // tslint:disable-next-line:no-shadowed-variable
    function getLineIndent(offset) {
        let start = offset;
        while (start > 0) {
            const ch = text.charAt(start - 1);
            if ('\n\r'.indexOf(ch) >= 0) {
                return text.substring(start, offset);
            }
            if (!isWhiteSpace(ch)) {
                return null;
            }
            start--;
        }
        return text.substring(0, offset);
    }
    function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd = offset) {
        const range = getReplaceRange(afterOpenBracket, tagNameEnd);
        const closeTag = isFollowedBy(text, tagNameEnd, htmlScanner_1.ScannerState.WithinEndTag, htmlScanner_1.TokenType.EndTagClose)
            ? ''
            : '>';
        let curr = node;
        if (inOpenTag) {
            curr = curr.parent; // don't suggest the own tag, it's not yet open
        }
        while (curr) {
            const tag = curr.tag;
            if (tag && (!curr.closed || curr.endTagStart > offset)) {
                const item = {
                    label: '/' + tag,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    filterText: '/' + tag + closeTag,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                };
                const startIndent = getLineIndent(curr.start);
                const endIndent = getLineIndent(afterOpenBracket - 1);
                if (startIndent !== null &&
                    endIndent !== null &&
                    startIndent !== endIndent) {
                    const insertText = startIndent + '</' + tag + closeTag;
                    item.textEdit = vscode_languageserver_types_1.TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);
                    item.filterText = endIndent + '</' + tag + closeTag;
                }
                result.items.push(item);
                return result;
            }
            curr = curr.parent;
        }
        if (inOpenTag) {
            return result;
        }
        tagProviders.forEach(provider => {
            provider.collectTags((tag, label) => {
                result.items.push({
                    label: '/' + tag,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    documentation: label,
                    filterText: '/' + tag + closeTag,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                });
            });
        });
        return result;
    }
    function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {
        if (settings && settings.hideAutoCompleteProposals) {
            return result;
        }
        if (!htmlTags_1.isEmptyElement(tag)) {
            const pos = document.positionAt(tagCloseEnd);
            result.items.push({
                label: '</' + tag + '>',
                kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                filterText: '</' + tag + '>',
                textEdit: vscode_languageserver_types_1.TextEdit.insert(pos, '$0</' + tag + '>'),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
            });
        }
        return result;
    }
    function collectTagSuggestions(tagStart, tagEnd) {
        collectOpenTagSuggestions(tagStart, tagEnd);
        collectCloseTagSuggestions(tagStart, true, tagEnd);
        return result;
    }
    function collectAttributeNameSuggestions(nameStart, nameEnd = offset) {
        let replaceEnd = offset;
        while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {
            // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.
            replaceEnd++;
        }
        const range = getReplaceRange(nameStart, replaceEnd);
        const value = isFollowedBy(text, nameEnd, htmlScanner_1.ScannerState.AfterAttributeName, htmlScanner_1.TokenType.DelimiterAssign)
            ? ''
            : '="$1"';
        const tag = currentTag.toLowerCase();
        tagProviders.forEach(provider => {
            provider.collectAttributes(tag, (attribute, type) => {
                let codeSnippet = attribute;
                if (type !== 'v' && value.length) {
                    codeSnippet = codeSnippet + value;
                }
                result.items.push({
                    label: attribute,
                    kind: type === 'handler'
                        ? vscode_languageserver_types_1.CompletionItemKind.Function
                        : vscode_languageserver_types_1.CompletionItemKind.Value,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, codeSnippet),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
                });
            });
        });
        return result;
    }
    function collectAttributeValueSuggestions(valueStart, valueEnd) {
        let range;
        let addQuotes;
        if (offset > valueStart && offset <= valueEnd && text[valueStart] === '"') {
            // inside attribute
            if (valueEnd > offset && text[valueEnd - 1] === '"') {
                valueEnd--;
            }
            const wsBefore = getWordStart(text, offset, valueStart + 1);
            const wsAfter = getWordEnd(text, offset, valueEnd);
            range = getReplaceRange(wsBefore, wsAfter);
            addQuotes = false;
        }
        else {
            range = getReplaceRange(valueStart, valueEnd);
            addQuotes = true;
        }
        const tag = currentTag.toLowerCase();
        const attribute = currentAttributeName.toLowerCase();
        tagProviders.forEach(provider => {
            provider.collectValues(tag, attribute, value => {
                const insertText = addQuotes ? '"' + value + '"' : value;
                result.items.push({
                    label: value,
                    filterText: insertText,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Unit,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, insertText),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                });
            });
        });
        return result;
    }
    function scanNextForEndPos(nextToken) {
        if (offset === scanner.getTokenEnd()) {
            token = scanner.scan();
            if (token === nextToken && scanner.getTokenOffset() === offset) {
                return scanner.getTokenEnd();
            }
        }
        return offset;
    }
    let token = scanner.scan();
    while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenOffset() <= offset) {
        switch (token) {
            case htmlScanner_1.TokenType.StartTagOpen:
                if (scanner.getTokenEnd() === offset) {
                    const endPos = scanNextForEndPos(htmlScanner_1.TokenType.StartTag);
                    return collectTagSuggestions(offset, endPos);
                }
                break;
            case htmlScanner_1.TokenType.StartTag:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                currentTag = scanner.getTokenText();
                break;
            case htmlScanner_1.TokenType.AttributeName:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                currentAttributeName = scanner.getTokenText();
                break;
            case htmlScanner_1.TokenType.DelimiterAssign:
                if (scanner.getTokenEnd() === offset) {
                    return collectAttributeValueSuggestions(scanner.getTokenEnd());
                }
                break;
            case htmlScanner_1.TokenType.AttributeValue:
                if (scanner.getTokenOffset() <= offset &&
                    offset <= scanner.getTokenEnd()) {
                    return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                }
                break;
            case htmlScanner_1.TokenType.Whitespace:
                if (offset <= scanner.getTokenEnd()) {
                    switch (scanner.getScannerState()) {
                        case htmlScanner_1.ScannerState.AfterOpeningStartTag:
                            const startPos = scanner.getTokenOffset();
                            const endTagPos = scanNextForEndPos(htmlScanner_1.TokenType.StartTag);
                            return collectTagSuggestions(startPos, endTagPos);
                        case htmlScanner_1.ScannerState.WithinTag:
                        case htmlScanner_1.ScannerState.AfterAttributeName:
                            return collectAttributeNameSuggestions(scanner.getTokenEnd());
                        case htmlScanner_1.ScannerState.BeforeAttributeValue:
                            return collectAttributeValueSuggestions(scanner.getTokenEnd());
                        case htmlScanner_1.ScannerState.AfterOpeningEndTag:
                            return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                    }
                }
                break;
            case htmlScanner_1.TokenType.EndTagOpen:
                if (offset <= scanner.getTokenEnd()) {
                    const afterOpenBracket = scanner.getTokenOffset() + 1;
                    const endOffset = scanNextForEndPos(htmlScanner_1.TokenType.EndTag);
                    return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);
                }
                break;
            case htmlScanner_1.TokenType.EndTag:
                if (offset <= scanner.getTokenEnd()) {
                    let start = scanner.getTokenOffset() - 1;
                    while (start >= 0) {
                        const ch = text.charAt(start);
                        if (ch === '/') {
                            return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());
                        }
                        else if (!isWhiteSpace(ch)) {
                            break;
                        }
                        start--;
                    }
                }
                break;
            case htmlScanner_1.TokenType.StartTagClose:
                if (offset <= scanner.getTokenEnd()) {
                    if (currentTag) {
                        return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);
                    }
                }
                break;
            default:
                if (offset <= scanner.getTokenEnd()) {
                    return result;
                }
                break;
        }
        token = scanner.scan();
    }
    return result;
}
exports.doComplete = doComplete;
function doTagComplete(document, position, htmlDocument) {
    const offset = document.offsetAt(position);
    if (offset <= 0) {
        return;
    }
    const char = document.getText().charAt(offset - 1);
    if (char === '>') {
        const node = htmlDocument.findNodeBefore(offset);
        if (node &&
            node.tag &&
            !htmlTags_1.isEmptyElement(node.tag) &&
            node.start < offset &&
            (!node.endTagStart || node.endTagStart > offset)) {
            const scanner = htmlScanner_1.createScanner(document.getText(), node.start);
            let token = scanner.scan();
            while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                if (token === htmlScanner_1.TokenType.StartTagClose &&
                    scanner.getTokenEnd() === offset) {
                    return `$0</${node.tag}>`;
                }
                token = scanner.scan();
            }
        }
    }
    else if (char === '/') {
        let node = htmlDocument.findNodeBefore(offset);
        while (node && node.closed) {
            node = node.parent;
        }
        if (node && node.tag) {
            const scanner = htmlScanner_1.createScanner(document.getText(), node.start);
            let token = scanner.scan();
            while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                if (token === htmlScanner_1.TokenType.EndTagOpen &&
                    scanner.getTokenEnd() === offset) {
                    return `${node.tag}>`;
                }
                token = scanner.scan();
            }
        }
    }
    return null;
}
exports.doTagComplete = doTagComplete;
function isWhiteSpace(s) {
    return /^\s*$/.test(s);
}
function isFollowedBy(s, offset, intialState, expectedToken) {
    const scanner = htmlScanner_1.createScanner(s, offset, intialState);
    let token = scanner.scan();
    while (token === htmlScanner_1.TokenType.Whitespace) {
        token = scanner.scan();
    }
    return token === expectedToken;
}
function getWordStart(s, offset, limit) {
    while (offset > limit && !isWhiteSpace(s[offset - 1])) {
        offset--;
    }
    return offset;
}
function getWordEnd(s, offset, limit) {
    while (offset < limit && !isWhiteSpace(s[offset])) {
        offset++;
    }
    return offset;
}
//# sourceMappingURL=htmlCompletion.js.map