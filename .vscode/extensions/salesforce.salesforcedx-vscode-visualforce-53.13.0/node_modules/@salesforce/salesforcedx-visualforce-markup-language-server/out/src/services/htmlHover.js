/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See OSSREADME.json in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const htmlScanner_1 = require("../parser/htmlScanner");
const tagProviders_1 = require("./tagProviders");
function doHover(document, position, htmlDocument) {
    const offset = document.offsetAt(position);
    const node = htmlDocument.findNodeAt(offset);
    if (!node || !node.tag) {
        return void 0;
    }
    const tagProviders = tagProviders_1.allTagProviders.filter(p => p.isApplicable(document.languageId));
    function getTagHover(tag, range, open) {
        tag = tag.toLowerCase();
        for (const provider of tagProviders) {
            let hover;
            provider.collectTags((t, label) => {
                if (t === tag) {
                    const tagLabel = open ? '<' + tag + '>' : '</' + tag + '>';
                    hover = {
                        contents: [
                            { language: 'html', value: tagLabel },
                            vscode_languageserver_types_1.MarkedString.fromPlainText(label)
                        ],
                        range
                    };
                }
            });
            if (hover) {
                return hover;
            }
        }
        return void 0;
    }
    function getTagNameRange(tokenType, startOffset) {
        const scanner = htmlScanner_1.createScanner(document.getText(), startOffset);
        let token = scanner.scan();
        while (token !== htmlScanner_1.TokenType.EOS &&
            (scanner.getTokenEnd() < offset ||
                (scanner.getTokenEnd() === offset && token !== tokenType))) {
            token = scanner.scan();
        }
        if (token === tokenType && offset <= scanner.getTokenEnd()) {
            return {
                start: document.positionAt(scanner.getTokenOffset()),
                end: document.positionAt(scanner.getTokenEnd())
            };
        }
        return null;
    }
    if (node.endTagStart && offset >= node.endTagStart) {
        const tagNameRange = getTagNameRange(htmlScanner_1.TokenType.EndTag, node.endTagStart);
        if (tagNameRange) {
            return getTagHover(node.tag, tagNameRange, false);
        }
        return void 0;
    }
    const tagRange = getTagNameRange(htmlScanner_1.TokenType.StartTag, node.start);
    if (tagRange) {
        return getTagHover(node.tag, tagRange, true);
    }
    return void 0;
}
exports.doHover = doHover;
//# sourceMappingURL=htmlHover.js.map