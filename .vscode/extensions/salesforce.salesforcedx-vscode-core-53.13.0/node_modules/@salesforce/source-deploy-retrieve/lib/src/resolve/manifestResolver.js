"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestResolver = void 0;
const registry_1 = require("../registry");
const treeContainers_1 = require("./treeContainers");
const fast_xml_parser_1 = require("fast-xml-parser");
const utils_1 = require("../utils");
/**
 * Resolve MetadataComponents from a manifest file (package.xml)
 */
class ManifestResolver {
    constructor(tree = new treeContainers_1.NodeFSTreeContainer(), registry = new registry_1.RegistryAccess()) {
        this.tree = tree;
        this.registry = registry;
    }
    resolve(manifestPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const components = [];
            const file = yield this.tree.readFile(manifestPath);
            const parsedManifest = fast_xml_parser_1.parse(file.toString(), {
                stopNodes: ['version'],
            }).Package;
            const packageTypeMembers = utils_1.normalizeToArray(parsedManifest.types);
            const apiVersion = parsedManifest.version;
            for (const typeMembers of packageTypeMembers) {
                const typeName = typeMembers.name;
                const type = this.registry.getTypeByName(typeName);
                const parentType = type.folderType ? this.registry.getTypeByName(type.folderType) : undefined;
                const members = utils_1.normalizeToArray(typeMembers.members);
                for (const fullName of members) {
                    let mdType = type;
                    if (this.isNestedInFolder(fullName, type, parentType, members)) {
                        mdType = parentType;
                    }
                    components.push({ fullName, type: mdType });
                }
            }
            return { components, apiVersion };
        });
    }
    // Use the folderType instead of the type from the manifest when:
    //  1. InFolder types: (report, dashboard, emailTemplate, document)
    //    1a. type.inFolder === true (from registry.json) AND
    //    1b. The fullName doesn't contain a forward slash character AND
    //    1c. The fullName with a slash appended is contained in another member entry
    // OR
    //  2. Non-InFolder, folder types: (territory2, territory2Model, territory2Type, territory2Rule)
    //    2a. type.inFolder !== true (from registry.json) AND
    //    2b. type.folderType has a value (from registry.json) AND
    //    2c. This type's parent type has a folderType that doesn't match its ID.
    isNestedInFolder(fullName, type, parentType, members) {
        // Quick short-circuit for non-folderTypes
        if (!type.folderType) {
            return false;
        }
        const isInFolderType = type.inFolder;
        const isNestedInFolder = !fullName.includes('/') || members.some((m) => m.includes(`${fullName}/`));
        const isNonMatchingFolder = parentType && parentType.folderType !== parentType.id;
        return (isInFolderType && isNestedInFolder) || (!isInFolderType && isNonMatchingFolder);
    }
}
exports.ManifestResolver = ManifestResolver;
//# sourceMappingURL=manifestResolver.js.map