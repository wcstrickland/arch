"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposedSourceAdapter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const mixedContentSourceAdapter_1 = require("./mixedContentSourceAdapter");
const sourceComponent_1 = require("../sourceComponent");
const utils_1 = require("../../utils");
const errors_1 = require("../../errors");
/**
 * Handles decomposed types. A flavor of mixed content where a component can
 * have additional -meta.xml files that represent child components of the main
 * component.
 *
 * __Example Types__:
 *
 * CustomObject, CustomObjectTranslation
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── MyFoo__c/
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── bars/
 * |      ├── a.bar-meta.xml
 * |      ├── b.bar-meta.xml
 * |      ├── c.bar-meta.xml
 *
 * foos/
 * ├── MyFoo__c/
 * |   ├── a.bar-meta.xml
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── b.bar-meta.xml
 * |   ├── c.bar-meta.xml
 *```
 */
class DecomposedSourceAdapter extends mixedContentSourceAdapter_1.MixedContentSourceAdapter {
    constructor() {
        super(...arguments);
        this.ownFolder = true;
        this.metadataWithContent = false;
    }
    getComponent(path, isResolvingSource = true) {
        let rootMetadata = super.parseAsRootMetadataXml(path);
        if (!rootMetadata) {
            const rootMetadataPath = this.getRootMetadataXmlPath(path);
            if (rootMetadataPath) {
                rootMetadata = utils_1.parseMetadataXml(rootMetadataPath);
            }
        }
        let component;
        if (rootMetadata) {
            const componentName = this.type.folderType
                ? `${utils_1.parentName(rootMetadata.path)}/${rootMetadata.fullName}`
                : rootMetadata.fullName;
            component = new sourceComponent_1.SourceComponent({
                name: componentName,
                type: this.type,
                xml: rootMetadata.path,
            }, this.tree, this.forceIgnore);
        }
        return this.populate(path, component, isResolvingSource);
    }
    /**
     * If the trigger turns out to be part of a child component, `populate` will build
     * the child component, set its parent property to the one created by the
     * `BaseSourceAdapter`, and return the child component instead.
     */
    populate(trigger, component, isResolvingSource) {
        const metaXml = utils_1.parseMetadataXml(trigger);
        if (metaXml) {
            const pathToContent = this.trimPathToContent(trigger);
            const childTypeId = this.type.children.suffixes[metaXml.suffix];
            // If the child is explicitly not addressable, return the parent SourceComponent.
            const triggerIsAChild = !!childTypeId && this.type.children.types[childTypeId].isAddressable !== false;
            const strategy = this.type.strategies.decomposition;
            if (triggerIsAChild &&
                (strategy === "folderPerType" /* FolderPerType */ || isResolvingSource)) {
                let parent = component;
                if (!parent) {
                    parent = new sourceComponent_1.SourceComponent({
                        name: utils_1.baseName(pathToContent),
                        type: this.type,
                    }, this.tree, this.forceIgnore);
                }
                parent.content = pathToContent;
                return new sourceComponent_1.SourceComponent({
                    name: metaXml.fullName,
                    type: this.type.children.types[childTypeId],
                    xml: trigger,
                    parent,
                }, this.tree, this.forceIgnore);
            }
            if (!triggerIsAChild) {
                if (!component) {
                    // This is most likely metadata found within a CustomObject folder that is not a
                    // child type of CustomObject. E.g., Layout, SharingRules, ApexClass.
                    throw new errors_1.TypeInferenceError('error_unexpected_child_type', [trigger, this.type.name]);
                }
                component.content = pathToContent;
            }
        }
        return component;
    }
}
exports.DecomposedSourceAdapter = DecomposedSourceAdapter;
//# sourceMappingURL=decomposedSourceAdapter.js.map