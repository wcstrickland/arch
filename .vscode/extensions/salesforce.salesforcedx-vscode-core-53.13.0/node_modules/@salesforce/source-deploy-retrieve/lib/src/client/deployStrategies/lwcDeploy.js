"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LwcDeploy = void 0;
const baseDeploy_1 = require("./baseDeploy");
const types_1 = require("../types");
const graceful_fs_1 = require("graceful-fs");
const utils_1 = require("../../utils");
const path_1 = require("path");
const toolingApi_1 = require("../toolingApi");
const diagnosticUtil_1 = require("../diagnosticUtil");
class LwcDeploy extends baseDeploy_1.BaseDeploy {
    deploy(component, namespace) {
        return __awaiter(this, void 0, void 0, function* () {
            this.component = component;
            this.namespace = namespace;
            const lwcResources = yield this.buildResourceList();
            const componentDeployment = yield this.upsert(lwcResources);
            let status = "Completed" /* Completed */;
            if (componentDeployment.diagnostics.length > 0) {
                status =
                    componentDeployment.status !== types_1.ComponentStatus.Failed
                        ? "CompletedPartial" /* CompletedPartial */
                        : "Failed" /* Failed */;
            }
            return {
                id: undefined,
                status,
                success: status === "Completed" /* Completed */,
                components: [componentDeployment],
            };
        });
    }
    buildResourceList() {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceFiles = this.component.walkContent();
            sourceFiles.push(this.component.xml);
            const lightningResources = [];
            const existingResources = yield this.findLightningResources();
            const lightningBundle = existingResources[0]
                ? yield this.upsertBundle(existingResources[0].LightningComponentBundleId)
                : yield this.upsertBundle();
            const bundleId = lightningBundle.id;
            sourceFiles.forEach((sourceFile) => __awaiter(this, void 0, void 0, function* () {
                const source = graceful_fs_1.readFileSync(sourceFile, 'utf8');
                const isMetaSource = sourceFile === this.component.xml;
                const format = isMetaSource ? 'js' : utils_1.extName(sourceFile);
                let match;
                if (existingResources.length > 0) {
                    match = existingResources.find((resource) => sourceFile.endsWith(path_1.normalize(resource.FilePath)));
                }
                // If resource exists in org, assign the matching Id
                // else, assign the id of the bundle it's associated with
                const lightningResource = Object.assign({ FilePath: sourceFile, Source: source, Format: format }, (match ? { Id: match.Id } : { LightningComponentBundleId: bundleId }));
                // This is to ensure that the base file is deployed first for lwc
                // otherwise there is a `no base file found` error
                lightningResource.Format === 'js' && !isMetaSource
                    ? lightningResources.unshift(lightningResource)
                    : lightningResources.push(lightningResource);
            }));
            return lightningResources;
        });
    }
    upsert(lightningResources) {
        return __awaiter(this, void 0, void 0, function* () {
            const type = this.component.type.name;
            const deployment = {
                status: types_1.ComponentStatus.Unchanged,
                component: this.component,
                diagnostics: [],
            };
            const diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('tooling');
            let partialSuccess = false;
            let allCreate = true;
            // first resource needs to be created first, so force sync
            for (const resource of lightningResources) {
                try {
                    if (resource.Id) {
                        const formattedDef = {
                            Source: resource.Source,
                            Id: resource.Id,
                        };
                        yield this.connection.tooling.update(toolingApi_1.deployTypes.get(type), formattedDef);
                        allCreate = false;
                        partialSuccess = true;
                    }
                    else {
                        const formattedDef = {
                            LightningComponentBundleId: resource.LightningComponentBundleId,
                            Format: resource.Format,
                            Source: resource.Source,
                            FilePath: this.getFormattedPaths(resource.FilePath)[0],
                        };
                        yield this.toolingCreate(toolingApi_1.deployTypes.get(type), formattedDef);
                    }
                }
                catch (e) {
                    const diagnostic = diagnosticUtil.parseDeployDiagnostic(this.component, e.message);
                    deployment.diagnostics.push(diagnostic);
                }
            }
            if (deployment.diagnostics.length > 0) {
                deployment.status = partialSuccess ? types_1.ComponentStatus.Changed : types_1.ComponentStatus.Failed;
            }
            else if (allCreate) {
                deployment.status = types_1.ComponentStatus.Created;
            }
            else {
                deployment.status = types_1.ComponentStatus.Changed;
            }
            return deployment;
        });
    }
    findLightningResources() {
        return __awaiter(this, void 0, void 0, function* () {
            const lightningResourceResult = yield this.connection.tooling.query(`Select LightningComponentBundleId, Id, Format, Source, FilePath from LightningComponentResource where LightningComponentBundle.DeveloperName = '${this.component.fullName}' and LightningComponentBundle.NamespacePrefix = '${this.namespace}'`);
            return lightningResourceResult.records;
        });
    }
}
exports.LwcDeploy = LwcDeploy;
//# sourceMappingURL=lwcDeploy.js.map