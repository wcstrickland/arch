"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerDeploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const graceful_fs_1 = require("graceful-fs");
const toolingApi_1 = require("../toolingApi");
const errors_1 = require("../../errors");
const types_1 = require("../types");
const path_1 = require("../../utils/path");
const baseDeploy_1 = require("./baseDeploy");
class ContainerDeploy extends baseDeploy_1.BaseDeploy {
    deploy(component, namespace) {
        return __awaiter(this, void 0, void 0, function* () {
            this.component = component;
            this.namespace = namespace;
            const sourcePath = component.content;
            const metadataPath = component.xml;
            const container = yield this.createMetadataContainer();
            yield this.createContainerMember([sourcePath, metadataPath], container);
            const asyncRequest = yield this.createContainerAsyncRequest(container);
            const containerRequestStatus = yield this.pollContainerStatus(asyncRequest.id);
            return this.buildSourceDeployResult(containerRequestStatus);
        });
    }
    createMetadataContainer() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataContainer = yield this.toolingCreate(ContainerDeploy.METADATA_CONTAINER, {
                Name: `Deploy_MDC_${Date.now()}`,
            });
            if (!metadataContainer.success) {
                throw new errors_1.DeployError('beta_tapi_mdcontainer_error');
            }
            return metadataContainer;
        });
    }
    createContainerMember(outboundFiles, container) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = container.id;
            const metadataContent = graceful_fs_1.readFileSync(outboundFiles[1], 'utf8');
            const metadataField = this.buildMetadataField(metadataContent);
            const body = graceful_fs_1.readFileSync(outboundFiles[0], 'utf8');
            const fileName = path_1.baseName(outboundFiles[0]);
            const entityId = yield this.getContentEntity(this.component.type.name, fileName, this.namespace);
            const containerMemberObject = Object.assign({ MetadataContainerId: id, FullName: fileName, Body: body, Metadata: metadataField }, (entityId ? { contentEntityId: entityId } : {}));
            const containerMember = yield this.toolingCreate(toolingApi_1.deployTypes.get(this.component.type.name), containerMemberObject);
            if (!containerMember.success) {
                throw new errors_1.DeployError('beta_tapi_membertype_error', this.component.type.name);
            }
            return containerMember;
        });
    }
    getContentEntity(metadataType, fileName, namespace) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryResult = (yield this.connection.tooling.query(`Select Id from ${metadataType} where Name = '${fileName}' and NamespacePrefix = '${namespace}'`));
            return queryResult && queryResult.records.length === 1 ? queryResult.records[0].Id : undefined;
        });
    }
    createContainerAsyncRequest(container) {
        return __awaiter(this, void 0, void 0, function* () {
            const contAsyncRequest = yield this.toolingCreate(ContainerDeploy.CONTAINER_ASYNC_REQUEST, {
                MetadataContainerId: container.id,
            });
            if (!contAsyncRequest.success) {
                throw new errors_1.DeployError('beta_tapi_car_error');
            }
            return contAsyncRequest;
        });
    }
    pollContainerStatus(containerId) {
        return __awaiter(this, void 0, void 0, function* () {
            let count = 0;
            let containerStatus;
            do {
                if (count > 0) {
                    yield this.sleep(100);
                }
                containerStatus = (yield this.connection.tooling.retrieve(ContainerDeploy.CONTAINER_ASYNC_REQUEST, containerId));
                count++;
            } while (containerStatus.State === "Queued" /* Queued */ && count <= 30);
            return containerStatus;
        });
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    buildSourceDeployResult(containerRequest) {
        const componentDeployment = {
            component: this.component,
            status: types_1.ComponentStatus.Unchanged,
            diagnostics: [],
        };
        const messages = [];
        const { componentSuccesses, componentFailures } = containerRequest.DeployDetails;
        if (componentSuccesses) {
            if (Array.isArray(componentSuccesses)) {
                messages.push(...componentSuccesses);
            }
            else {
                messages.push(componentSuccesses);
            }
        }
        if (componentFailures) {
            if (Array.isArray(componentFailures)) {
                messages.push(...componentFailures);
            }
            else {
                messages.push(componentFailures);
            }
        }
        for (const message of messages) {
            if (message.changed) {
                componentDeployment.status = types_1.ComponentStatus.Changed;
            }
            else if (message.created) {
                componentDeployment.status = types_1.ComponentStatus.Created;
            }
            else if (message.deleted) {
                componentDeployment.status = types_1.ComponentStatus.Deleted;
            }
            else if (!message.success) {
                componentDeployment.status = types_1.ComponentStatus.Failed;
                componentDeployment.diagnostics.push({
                    error: message.problem,
                    problemType: message.problemType,
                    filePath: this.component.content,
                    lineNumber: Number(message.lineNumber),
                    columnNumber: Number(message.columnNumber),
                });
            }
        }
        return {
            id: containerRequest.Id,
            status: containerRequest.State,
            success: containerRequest.State === "Completed" /* Completed */,
            components: [componentDeployment],
        };
    }
}
exports.ContainerDeploy = ContainerDeploy;
ContainerDeploy.CONTAINER_ASYNC_REQUEST = 'ContainerAsyncRequest';
ContainerDeploy.METADATA_CONTAINER = 'MetadataContainer';
//# sourceMappingURL=containerDeploy.js.map