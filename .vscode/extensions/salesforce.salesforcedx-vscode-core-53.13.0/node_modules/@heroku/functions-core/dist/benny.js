"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Benny = void 0;
const child_process_1 = require("child_process");
const debug_1 = require("debug");
const events = require("events");
const readline_1 = require("readline");
const path = require("path");
const process = require("process");
const config = require('../package.json').benny;
const debug = debug_1.default('evergreen:benny:message');
class Benny {
    constructor() {
        this.cancelled = false;
        this.name = config.name;
        this.bucket = config.bucket;
        this.platform = process.platform;
        this.version = config['major-version'];
        this.binPath = this.localPath;
        this.emitter = new events.EventEmitter();
        this.childProcesses = new Array();
    }
    on(event, listener) {
        this.getEmitter().on(event, listener);
    }
    build(image, options) {
        const buildArgs = ['build', image];
        Object.entries(options).forEach(([flagName, flagVal]) => {
            if (flagName === 'verbose')
                return;
            if (flagVal === undefined)
                return;
            if (Array.isArray(flagVal)) {
                flagVal.forEach((arrVal) => {
                    buildArgs.push(`--${flagName}`);
                    buildArgs.push(arrVal);
                });
            }
            else if (flagVal !== true) {
                buildArgs.push(`--${flagName}`);
                buildArgs.push(flagVal);
            }
            else {
                buildArgs.push(`--${flagName}`);
            }
        });
        return this.exec(buildArgs);
    }
    run(containerName, flags) {
        const { port = 8080, 'debug-port': debugPort = 9229, env } = flags;
        const runArgs = ['run', containerName];
        if (port) {
            runArgs.push('--port');
            runArgs.push(port.toString());
        }
        if (debugPort !== undefined) {
            runArgs.push('--debug-port');
            runArgs.push(debugPort.toString() || '');
        }
        if (env) {
            env.forEach((env) => {
                runArgs.push('-e');
                runArgs.push(env);
            });
        }
        return this.exec(runArgs);
    }
    push(image, spaceId, registryPassword) {
        const pushArgs = ['push', image, '--space-id', spaceId];
        return this.exec(pushArgs, registryPassword);
    }
    cancel() {
        this.cancelled = true;
        this.emitter.removeAllListeners();
        this.childProcesses.forEach((process) => process.kill());
        this.childProcesses = [];
    }
    exec(args, input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cancelled) {
                console.debug('Benny execution cancelled');
                return false;
            }
            debug(this.binPath, args);
            const cmd = child_process_1.spawn(this.binPath, args);
            this.childProcesses.push(cmd);
            this.handleInput(input, cmd);
            const rl = readline_1.createInterface({
                input: cmd.stdout,
                crlfDelay: Infinity,
            });
            rl.on('line', (line) => {
                debug(line);
                const payload = JSON.parse(line);
                this.getEmitter().emit('message', payload);
                if (payload.type) {
                    this.getEmitter().emit(payload.type, payload);
                }
            });
            // return a promise that resolves when the child process has exited
            return new Promise(function (resolve, reject) {
                cmd.addListener('error', reject);
                cmd.addListener('exit', (code) => {
                    if (code !== 0) {
                        reject(new Error('Build exited with: ' + cmd.stderr.read()));
                    }
                    else {
                        resolve(code);
                    }
                });
            });
        });
    }
    handleInput(input, command) {
        var _a;
        if (!input)
            return;
        const isStream = typeof input === 'object' && typeof input.pipe === 'function';
        if (isStream) {
            input.pipe(command.stdin);
        }
        else {
            (_a = command === null || command === void 0 ? void 0 : command.stdin) === null || _a === void 0 ? void 0 : _a.end(input);
        }
    }
    getEmitter() {
        return this.emitter;
    }
    suffix() {
        if (this.platform === 'win32') {
            return 'windows.exe';
        }
        else if (this.platform === 'darwin') {
            return 'darwin';
        }
        else if (this.platform === 'linux') {
            return 'linux';
        }
        else {
            throw new Error(`Unsupported platform: ${this.platform}`);
        }
    }
    get os() {
        const platform = this.suffix();
        if (platform === 'windows.exe')
            return 'windows';
        else
            return platform;
    }
    majorVersion() {
        return this.version;
    }
    get binDir() {
        return path.join(__dirname, '../bin');
    }
    get tmpDir() {
        return path.join(__dirname, '../tmp');
    }
    get keyDir() {
        return path.join(__dirname, '../priv');
    }
    get localFilename() {
        return `${this.name}-${this.suffix()}`;
    }
    get localPath() {
        return process.env.BENNY_PATH || path.join(this.binDir, this.localFilename);
    }
    get tmpPath() {
        return path.join(this.binDir, `tmp-${this.localFilename}`);
    }
    get latestPath() {
        return path.join(this.tmpDir, 'latest.json');
    }
    get latestSigPath() {
        return path.join(this.tmpDir, 'latest.asc');
    }
    get publicKeyPath() {
        return path.join(this.keyDir, 'public.key');
    }
    get etagPath() {
        return path.join(this.tmpDir, 'etag');
    }
    get expirePath() {
        return path.join(this.tmpDir, 'expire');
    }
    get url() {
        return `https://${this.bucket}.s3.amazonaws.com/benny`;
    }
    get latestUrl() {
        return `${this.url}/latest`;
    }
    get latestSigUrl() {
        return `${this.url}/latest.asc`;
    }
}
exports.Benny = Benny;
