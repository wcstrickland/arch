"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFunction = void 0;
const core_1 = require("@salesforce/core");
const fs_extra_1 = require("fs-extra");
const color_1 = require("@heroku-cli/color");
const path = require("path");
const templates_1 = require("./templates");
const functions_error_1 = require("../util/functions-error");
const path_utils_1 = require("../util/path-utils");
function isFirstFunction(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // if we're able to actually resolve function paths here, it means that:
            // 1. a functions directory already exists
            // 2. it contains at least once function
            // which means this is definitely is not the first function
            yield path_utils_1.resolveFunctionsPaths(sourcePath);
            return false;
        }
        catch (error) {
            // If `resolveFunctionsPaths` errors, it most likely means it IS their first function, but
            // we verify the error message to be sure
            if ([
                'No functions directory found.',
                'The functions directory does contain any functions.',
            ].includes(error.message)) {
                return true;
            }
            // If we've made it here, something completely unexpected has happened and we should throw
            throw error;
        }
    });
}
function generateFunction(name, language, sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (name.length > 47) {
            throw new functions_error_1.FunctionsError('Function names cannot contain more than 47 characters.', 'InvalidFunctionName');
        }
        const functionNameRegex = /^[a-z][a-z0-9]*$/;
        if (!functionNameRegex.test(name)) {
            throw new functions_error_1.FunctionsError('Function names must:\n' +
                '1. Start with a letter\n' +
                '2. Contain only lowercase letters and numbers', 'InvalidFunctionName');
        }
        let sfdxProjectPath;
        try {
            sfdxProjectPath = yield core_1.SfdxProject.resolveProjectPath(sourcePath);
        }
        catch (error) {
            if (error.name === 'InvalidProjectWorkspace') {
                throw new functions_error_1.FunctionsError('You can only generate a function inside an sfdx project', 'InvalidProjectWorkspace');
            }
            throw error;
        }
        // before we go any further, check to see if this is the first function generated or not
        // so that we can set the welcome text for later if applicable
        let welcomeText = '';
        if (yield isFirstFunction(sourcePath)) {
            welcomeText =
                'Before creating Scratch Orgs for development, please ensure that:\n' +
                    '1. Enable Functions in your DevHub org\n' +
                    `2. Add ${color_1.default.green('Functions')} to the "features" list in your scratch org definition JSON file, e.g. "features": ["Functions"]`;
        }
        const fnNameCased = name.charAt(0).toUpperCase() + name.slice(1);
        // We construct `fnDir` this way because `sfdxProjectPath` will be a relative
        // filepath (e.g. `../../sfdx-project.json`)
        // This allows the user to generate a function from anywhere inside their project and still have the
        // new function actually get created in the root
        const fnDir = path.join(sfdxProjectPath, templates_1.FUNCTIONS_DIR, name);
        if (fs_extra_1.existsSync(fnDir)) {
            throw new functions_error_1.FunctionsError(`A function named ${name} already exists.`, 'FunctionExists');
        }
        // Find and write language template
        const template = templates_1.TEMPLATE_REGISTRY.getTemplate(language);
        if (!template) {
            throw new Error(`Language '${name}' not supported.`);
        }
        template.write({
            fnDir: fnDir,
            fnName: name,
            fnNameCased: fnNameCased,
        });
        return {
            name,
            path: fnDir,
            language,
            welcomeText,
        };
    });
}
exports.generateFunction = generateFunction;
