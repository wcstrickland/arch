"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runFunction = void 0;
const core_1 = require("@salesforce/core");
const axios_1 = require("axios");
const cloudevents_1 = require("cloudevents");
const constants_1 = require("cloudevents/dist/constants");
const uuid_1 = require("uuid");
const install_benny_1 = require("../install-benny");
const HEADER_REQUEST = 'X-Request-Id';
function runFunction(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, payload, targetusername, headers, structured = false } = options;
        yield install_benny_1.updateBennyWithRetries(3);
        const cloudevent = yield buildCloudevent(payload, targetusername, structured);
        const response = sendRequest(cloudevent, url, headers, structured);
        return response;
    });
}
exports.runFunction = runFunction;
function buildSfContexts(targetusername, requestId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // auth to scratch org using targetusername
            const org = yield core_1.Org.create({
                aliasOrUsername: targetusername,
            });
            // refresh to get the access Token
            yield org.refreshAuth();
            const orgusername = org.getUsername();
            const orgId18 = org.getOrgId().slice(0, 18);
            const connection = org.getConnection();
            const userContext = {
                salesforceBaseUrl: connection.instanceUrl,
                orgId: orgId18,
                orgDomainUrl: connection.instanceUrl,
                username: orgusername || '',
                userId: connection.getAuthInfoFields().userId || '',
                onBehalfOfUserId: '', // onBehalfOfUserId not set
            };
            const sfcontext = Buffer.from(JSON.stringify({
                apiVersion: connection.version,
                payloadVersion: 'invoke-v0.1',
                userContext,
            })).toString('base64');
            const sffncontext = Buffer.from(JSON.stringify({
                accessToken: connection.accessToken,
                requestId,
            })).toString('base64');
            return { sfcontext, sffncontext };
        }
        catch (err) {
            if (err.name === 'AuthInfoCreationError' || err.name === 'NoUsername') {
                const fakeUserContext = {
                    orgId: '000000000000000000',
                    orgDomainUrl: '',
                    salesforceBaseUrl: '',
                    username: '',
                    userId: '',
                    onBehalfOfUserId: '',
                };
                const fakeSFcontext = Buffer.from(JSON.stringify({
                    payloadVersion: 'invoke-v0.1',
                    userContext: fakeUserContext,
                })).toString('base64');
                const fakeSFFNContext = Buffer.from(JSON.stringify({
                    accessToken: '',
                    requestId,
                })).toString('base64');
                return {
                    sfcontext: fakeSFcontext,
                    sffncontext: fakeSFFNContext,
                };
            }
            throw err;
        }
    });
}
function buildCloudevent(userdata, targetusername, structured) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestId = uuid_1.v4();
        const data = toCloudEventData(userdata, structured);
        // Base64(JSON) encoded `sfcontext` and `sffncontext` keys/values if possible.  Empty object otherwise.
        const contexts = yield buildSfContexts(targetusername, requestId);
        // Create a Cloudevent 1.0-compliant object with sfcontext and sffncontext extensions
        return new cloudevents_1.CloudEvent(Object.assign(Object.assign({ id: requestId, specversion: '1.0', source: 'urn:event:from:local', type: 'com.evergreen.functions.test', subject: 'test-subject', datacontenttype: 'application/json; charset=utf-8' }, contexts), { data }));
    });
}
function sendRequest(cloudevent, url, headers, structured) {
    return __awaiter(this, void 0, void 0, function* () {
        const sendHeaders = buildRequestHeaders(headers, cloudevent.id, structured); // rm structured?
        // formerly protocol: structured ? 1 : 0
        const protocolFn = structured ? cloudevents_1.HTTP.structured : cloudevents_1.HTTP.binary;
        const message = protocolFn(cloudevent);
        return axios_1.default({
            method: 'post',
            url: url,
            data: message.body,
            headers: Object.assign(Object.assign({}, sendHeaders), message.headers),
        });
    });
}
function buildRequestHeaders(headers, requestId, structured) {
    const requestHeaders = {};
    if (headers) {
        headers.forEach((h) => {
            const headerSplits = h.split(':');
            requestHeaders[headerSplits[0]] = headerSplits[1];
        });
    }
    // set the request id header to be used by function logger initialization
    requestHeaders[HEADER_REQUEST] = requestId;
    // set structured cloudevents content-type if needed, should be handled by StructuredEmitter - bug?
    if (structured) {
        requestHeaders[constants_1.default.HEADER_CONTENT_TYPE] = constants_1.default.DEFAULT_CE_CONTENT_TYPE;
    }
    return requestHeaders;
}
// wrap userdata as a Buffer if sending via HttpBinary (!structured), optionally json-
// escaping before wrapping.
function bufferIfHttpBinary(userdata, structured, escape) {
    return structured ? userdata : Buffer.from(escape ? JSON.stringify(userdata) : userdata, 'utf-8');
}
// CloudEvents 1.0 data element must be either a well-formed JSON `object` or a properly-
// quoted JSON `string`.  Try to parse into JSON object first - if parsing fails or we
// get an unsupported type (boolean or number), return as a properly-escaped string.
// When sending via HTTPBinary (!structure), that properly-escaped string must be in a Buffer
// to be posted without modification by the cloudevents http binary emitter.
function toCloudEventData(userdata, structured) {
    let eventData;
    try {
        const parsedData = JSON.parse(userdata);
        // tslint:disable-next-line:triple-equals
        if (typeof parsedData === 'object' && parsedData != null) {
            // successfully parsed as js object that will be serialized properly as cloudevents data
            eventData = parsedData;
        }
        else if (typeof parsedData === 'string') {
            // successfully parsed a json-quoted string, wrap original userdata string w/buffer
            eventData = bufferIfHttpBinary(userdata, structured, false);
        }
        else {
            console.debug(`payload data not string|object (${typeof parsedData}), treating as string`);
            eventData = bufferIfHttpBinary(userdata, structured, true);
        }
    }
    catch (parseErr) {
        console.debug('debug', `payload data not parseable as json, treating as string: ${parseErr}`);
        // If given a raw string that was not json, escape/buffer if necessary
        eventData = bufferIfHttpBinary(userdata, structured, true);
    }
    return eventData;
}
