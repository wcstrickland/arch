"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateBennyWithRetries = exports.updateBenny = void 0;
const benny_1 = require("./benny");
const child_process_1 = require("child_process");
const fs = require("fs");
const ftch = require('node-fetch');
const kbpgp = require('kbpgp');
const sha256File = require('sha256-file');
const util = require('util');
const benny = new benny_1.Benny();
// matching behavior of the evergreen-base (https://github.com/heroku/evergreen-base/blob/master/src/apollo-links/http.ts#L1-L2)
process.env.GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE = '';
require('global-agent/bootstrap');
function downloadFile(url, path, contentType) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: contentType };
        const response = yield ftch(url, { headers, redirect: 'manual' });
        if (response.status === 302 || response.status === 301) {
            const redirectUrl = response.headers.get('location');
            const redirectResponse = yield ftch(redirectUrl);
            return streamToFile(redirectResponse, path);
        }
        else {
            return streamToFile(response, path);
        }
    });
}
function streamToFile(res, path) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (res.status === 200) {
                const fileStream = fs.createWriteStream(path);
                res.body.pipe(fileStream);
                res.body.on('error', (err) => reject(err));
                fileStream.on('finish', () => resolve());
            }
            else {
                reject(`Could not download file (${res.status}).`);
            }
        });
    });
}
function downloadLatest(cache) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = benny.latestUrl;
        if (process.env.DEBUG === '*') {
            process.stderr.write(`Downloading latest file from ${url}\n`);
        }
        const headers = {};
        headers.Accept = 'application/json';
        if (cache.etag !== '') {
            headers['If-None-Match'] = cache.etag;
        }
        const response = yield ftch(url, { headers, redirect: 'manual' });
        if (response.status === 302 || response.status === 301) {
            const redirectUrl = response.headers.get('location');
            const redirectResponse = yield ftch(redirectUrl);
            return streamToLatest(redirectResponse, cache);
        }
        else {
            return streamToLatest(response, cache);
        }
    });
}
function streamToLatest(res, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (res.status === 200) {
                const fileStream = fs.createWriteStream(benny.latestPath);
                res.body.pipe(fileStream);
                res.body.on('error', (err) => reject(err));
                fileStream.on('finish', () => {
                    updateCacheVar(res.headers, cache);
                    resolve(res.status);
                });
            }
            else if (res.status === 304) {
                // not modified
                updateCacheVar(res.headers, cache);
                resolve(res.status);
            }
            else {
                reject(`Could not download latest file (${res.status}).`);
            }
        });
    });
}
function updateCacheVar(header, cache) {
    cache.etag = header.get('etag').toString();
    const maxage = Number(header.get('Cache-Control').toString().split('=')[1]);
    cache.expireAt = Date.now() + maxage * 1000;
}
function parseVersion() {
    let output = child_process_1.execSync(`${benny.localPath} -version`, {
        stdio: ['pipe', 'pipe', 'ignore'],
    }).toString();
    const arr = output.split(' ');
    output = arr[arr.length - 1].trim();
    return output;
}
function handleError(err, bennyExists) {
    if (bennyExists) {
        return;
    }
    else {
        console.error(err);
        throw err;
    }
}
function readCacheFile(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const readFile = util.promisify(fs.readFile);
        let str = '';
        if (fs.existsSync(path)) {
            try {
                str = yield readFile(path, { encoding: 'utf8', flag: 'r' });
            }
            catch (_a) { }
        }
        return str;
    });
}
function readCache(cache) {
    return __awaiter(this, void 0, void 0, function* () {
        cache.etag = yield readCacheFile(benny.etagPath);
        cache.expireAt = Number(yield readCacheFile(benny.expirePath));
        if (isNaN(cache.expireAt))
            cache.expireAt = 0;
    });
}
function writeCache(cache) {
    return __awaiter(this, void 0, void 0, function* () {
        const writeFile = util.promisify(fs.writeFile);
        try {
            yield writeFile(benny.etagPath, cache.etag, 'utf8');
            yield writeFile(benny.expirePath, cache.expireAt.toString(), 'utf8');
        }
        catch (_a) { }
    });
}
function deleteFile(path) {
    return __awaiter(this, void 0, void 0, function* () {
        if (fs.existsSync(path)) {
            try {
                const unlink = util.promisify(fs.unlink);
                yield unlink(path);
            }
            catch (_a) { }
        }
    });
}
function deleteCache() {
    return __awaiter(this, void 0, void 0, function* () {
        yield deleteFile(benny.etagPath);
        yield deleteFile(benny.expirePath);
    });
}
function deleteBinary(bennyPath, version, bennyExists) {
    return __awaiter(this, void 0, void 0, function* () {
        if (bennyExists) {
            if (process.env.DEBUG === '*') {
                process.stderr.write(`Deleting ${benny.name} binary ${version}\n`);
            }
            yield deleteFile(bennyPath);
        }
    });
}
function deleteLatest() {
    return __awaiter(this, void 0, void 0, function* () {
        yield deleteFile(benny.latestPath);
        yield deleteFile(benny.latestSigPath);
    });
}
function verifyGPG(msgPath, keyPath, sigPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const publicKeyArmored = fs.readFileSync(keyPath, 'utf8');
        const detachedSignature = fs.readFileSync(sigPath, 'utf8');
        const messageBinary = fs.readFileSync(msgPath);
        return new Promise((resolve, reject) => {
            kbpgp.KeyManager.import_from_armored_pgp({
                armored: publicKeyArmored,
            }, function (err, km) {
                if (err) {
                    reject('Failed to load public key');
                }
                else {
                    const ring = new kbpgp.keyring.KeyRing();
                    ring.add_key_manager(km);
                    // verify detached signature
                    kbpgp.unbox({
                        strict: false,
                        armored: detachedSignature,
                        data: messageBinary,
                        keyfetch: ring,
                    }, (err) => {
                        if (err) {
                            reject('Invalid latest file signature\n' + err);
                        }
                        else {
                            resolve();
                        }
                    });
                }
            });
        });
    });
}
function verifyChecksum(filepath, sha) {
    const checksum = sha256File(filepath);
    return checksum === sha;
}
function updateBenny() {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = {
            etag: '',
            expireAt: 0,
        };
        let latestVersion = '';
        let currentVersion = '';
        const bennyPath = benny.localPath;
        let bennyExists = fs.existsSync(bennyPath);
        [benny.tmpDir, benny.binDir].forEach((dir) => {
            if (!fs.existsSync(dir))
                fs.mkdirSync(dir);
        });
        // obtain local benny version
        try {
            currentVersion = parseVersion();
            yield readCache(cache);
            // within cache control max age, early termination
            if (Date.now() < cache.expireAt) {
                return;
            }
        }
        catch (_a) {
            // no or broken local binary
            yield deleteCache();
            yield deleteBinary(bennyPath, currentVersion, bennyExists);
            bennyExists = false;
        }
        // download latest file from S3 and verify signature
        try {
            // download latest file
            const status = yield downloadLatest(cache);
            if (status === 304) {
                // cached, early termination
                yield writeCache(cache);
                return;
            }
            // download latest.asc
            if (process.env.DEBUG === '*') {
                process.stderr.write('Downloading latest.asc\n');
            }
            yield downloadFile(benny.latestSigUrl, benny.latestSigPath, 'text/plain');
            yield verifyGPG(benny.latestPath, benny.publicKeyPath, benny.latestSigPath);
        }
        catch (err) {
            yield deleteLatest();
            handleError(err, bennyExists);
            return;
        }
        // read latest version binary info from latest file
        const json = JSON.parse(fs.readFileSync(benny.latestPath, { encoding: 'utf8' }));
        const data = json[benny.majorVersion()][benny.os];
        latestVersion = data.version;
        if (latestVersion !== currentVersion) {
            // current binary is outdated
            // download new binary from S3 and verify checksum
            try {
                const url = data.url;
                if (process.env.DEBUG === '*') {
                    process.stderr.write(`Downloading latest ${benny.name} binary V-${latestVersion} from ${url}\n`);
                }
                yield downloadFile(url, benny.tmpPath, 'application/octet-stream');
                const valid = verifyChecksum(benny.tmpPath, data.checksum);
                if (!valid) {
                    throw new Error('Invalid benny binary checksum');
                }
            }
            catch (err) {
                yield deleteBinary(benny.tmpPath, latestVersion, true);
                handleError(err, bennyExists);
                return;
            }
            // delete old binary
            yield deleteBinary(bennyPath, currentVersion, bennyExists);
            // move new binary
            fs.renameSync(benny.tmpPath, bennyPath);
            fs.chmodSync(bennyPath, 0o765);
            // write etag header and cache only when download successfully
            yield writeCache(cache);
        }
        else {
            // has up-to-date local binary, not modified
            yield writeCache(cache);
        }
    });
}
exports.updateBenny = updateBenny;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function updateBennyWithRetries(maxRetries) {
    return __awaiter(this, void 0, void 0, function* () {
        let attempts = 0;
        while (attempts <= maxRetries) {
            try {
                attempts += 1;
                yield updateBenny();
                return;
            }
            catch (error) {
                if (attempts == maxRetries)
                    return error;
                // Clean up for next run
                yield deleteLatest();
                yield deleteCache();
                const jitter = Math.random() * 1000;
                yield sleep(500 + jitter);
            }
        }
    });
}
exports.updateBennyWithRetries = updateBennyWithRetries;
