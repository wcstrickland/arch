"use strict";
/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const faye_1 = require("faye");
const os = require("os");
const constants_1 = require("../constants");
const messages_1 = require("../messages");
var ApexDebuggerEventType;
(function (ApexDebuggerEventType) {
    ApexDebuggerEventType[ApexDebuggerEventType["ApexException"] = 0] = "ApexException";
    ApexDebuggerEventType[ApexDebuggerEventType["Debug"] = 1] = "Debug";
    ApexDebuggerEventType[ApexDebuggerEventType["HeartBeat"] = 2] = "HeartBeat";
    ApexDebuggerEventType[ApexDebuggerEventType["LogLine"] = 3] = "LogLine";
    ApexDebuggerEventType[ApexDebuggerEventType["OrgChange"] = 4] = "OrgChange";
    ApexDebuggerEventType[ApexDebuggerEventType["Ready"] = 5] = "Ready";
    ApexDebuggerEventType[ApexDebuggerEventType["RequestStarted"] = 6] = "RequestStarted";
    ApexDebuggerEventType[ApexDebuggerEventType["RequestFinished"] = 7] = "RequestFinished";
    ApexDebuggerEventType[ApexDebuggerEventType["Resumed"] = 8] = "Resumed";
    ApexDebuggerEventType[ApexDebuggerEventType["SessionTerminated"] = 9] = "SessionTerminated";
    ApexDebuggerEventType[ApexDebuggerEventType["Stopped"] = 10] = "Stopped";
    ApexDebuggerEventType[ApexDebuggerEventType["SystemInfo"] = 11] = "SystemInfo";
    ApexDebuggerEventType[ApexDebuggerEventType["SystemGack"] = 12] = "SystemGack";
    ApexDebuggerEventType[ApexDebuggerEventType["SystemWarning"] = 13] = "SystemWarning";
})(ApexDebuggerEventType = exports.ApexDebuggerEventType || (exports.ApexDebuggerEventType = {}));
class StreamingClientInfo {
    constructor(builder) {
        this.channel = builder.channel;
        this.timeout = builder.timeout;
        this.errorHandler = builder.errorHandler;
        this.connectedHandler = builder.connectedHandler;
        this.disconnectedHandler = builder.disconnectedHandler;
        this.messageHandler = builder.messageHandler;
    }
}
exports.StreamingClientInfo = StreamingClientInfo;
class StreamingClientInfoBuilder {
    constructor() {
        this.timeout = constants_1.DEFAULT_STREAMING_TIMEOUT_MS;
        this.errorHandler = () => { };
        this.connectedHandler = () => { };
        this.disconnectedHandler = () => { };
        this.messageHandler = () => { };
    }
    forChannel(channel) {
        this.channel = channel;
        return this;
    }
    withTimeout(durationInSeconds) {
        this.timeout = durationInSeconds || constants_1.DEFAULT_STREAMING_TIMEOUT_MS;
        return this;
    }
    withErrorHandler(handler) {
        this.errorHandler = handler;
        return this;
    }
    withConnectedHandler(handler) {
        this.connectedHandler = handler;
        return this;
    }
    withDisconnectedHandler(handler) {
        this.disconnectedHandler = handler;
        return this;
    }
    withMsgHandler(handler) {
        this.messageHandler = handler;
        return this;
    }
    build() {
        return new StreamingClientInfo(this);
    }
}
exports.StreamingClientInfoBuilder = StreamingClientInfoBuilder;
class StreamingClient {
    constructor(url, requestService, clientInfo) {
        this.connected = false;
        this.shouldDisconnect = false;
        this.isReplaySupported = false;
        this.replayId = -1;
        this.clientInfo = clientInfo;
        this.client = new faye_1.Client(url, {
            timeout: this.clientInfo.timeout,
            proxy: {
                origin: requestService.proxyUrl,
                auth: requestService.proxyAuthorization
            }
        });
        this.client.setHeader('Authorization', `OAuth ${requestService.accessToken}`);
        this.client.setHeader('Content-Type', 'application/json');
    }
    subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            let subscribeAccept;
            let subscribeReject;
            const returnPromise = new Promise((resolve, reject) => {
                subscribeAccept = resolve;
                subscribeReject = reject;
            });
            this.client.on('transport:down', () => __awaiter(this, void 0, void 0, function* () {
                if (!this.connected) {
                    this.clientInfo.errorHandler(messages_1.nls.localize('streaming_handshake_timeout_text'));
                    subscribeReject();
                }
            }));
            this.client.addExtension({
                incoming: (message, callback) => {
                    if (message.channel === '/meta/handshake') {
                        if (message.successful === true) {
                            if (message.ext && message.ext['replay'] === true) {
                                this.isReplaySupported = true;
                            }
                            this.shouldDisconnect = false;
                        }
                        else {
                            this.connected = false;
                            this.clientInfo.errorHandler(`${messages_1.nls.localize('streaming_handshake_error_text')}:${os.EOL}${JSON.stringify(message)}${os.EOL}`);
                            subscribeReject();
                        }
                    }
                    else if (message.channel === '/meta/connect' &&
                        !this.shouldDisconnect) {
                        const wasConnected = this.connected;
                        this.connected = message.successful;
                        if (!wasConnected && this.connected) {
                            this.clientInfo.connectedHandler();
                            subscribeAccept();
                        }
                        else if (wasConnected && !this.connected) {
                            this.clientInfo.disconnectedHandler();
                            this.sendSubscribeRequest();
                        }
                    }
                    else if (message.channel === '/meta/disconnect') {
                        this.shouldDisconnect = true;
                    }
                    callback(message);
                },
                outgoing: (message, callback) => {
                    if (message.channel === '/meta/subscribe' && this.isReplaySupported) {
                        if (!message.ext) {
                            message.ext = {};
                        }
                        const replayFrom = {};
                        replayFrom[this.clientInfo.channel] = this.replayId;
                        message.ext['replay'] = replayFrom;
                    }
                    callback(message);
                }
            });
            this.sendSubscribeRequest();
            return returnPromise;
        });
    }
    disconnect() {
        this.shouldDisconnect = true;
        if (this.client && this.connected) {
            this.client.disconnect();
            this.clientInfo.disconnectedHandler();
        }
        this.connected = false;
    }
    isConnected() {
        return this.connected;
    }
    getReplayId() {
        return this.replayId;
    }
    setReplayId(replayId) {
        this.replayId = replayId;
    }
    getClientInfo() {
        return this.clientInfo;
    }
    sendSubscribeRequest() {
        this.client.subscribe(this.clientInfo.channel, this.clientInfo.messageHandler);
    }
}
exports.StreamingClient = StreamingClient;
//# sourceMappingURL=streamingClient.js.map