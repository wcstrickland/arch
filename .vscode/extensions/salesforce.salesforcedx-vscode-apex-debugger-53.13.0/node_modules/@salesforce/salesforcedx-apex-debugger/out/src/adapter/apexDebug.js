"use strict";
/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/cli");
const helpers_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/helpers");
const requestService_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/requestService");
const types_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/types");
const AsyncLock = require("async-lock");
const path_1 = require("path");
const vscode_debugadapter_1 = require("vscode-debugadapter");
const commands_1 = require("../commands");
const constants_1 = require("../constants");
const core_1 = require("../core");
const index_1 = require("../index");
const messages_1 = require("../messages");
const os = require("os");
const TRACE_ALL = 'all';
const TRACE_CATEGORY_VARIABLES = 'variables';
const TRACE_CATEGORY_LAUNCH = 'launch';
const TRACE_CATEGORY_PROTOCOL = 'protocol';
const TRACE_CATEGORY_BREAKPOINTS = 'breakpoints';
const TRACE_CATEGORY_STREAMINGAPI = 'streaming';
const CONNECT_TYPE_ISV_DEBUGGER = 'ISV_DEBUGGER';
class ApexDebugStackFrameInfo {
    constructor(requestId, frameNumber) {
        this.globals = [];
        this.statics = [];
        this.locals = [];
        this.references = [];
        this.requestId = requestId;
        this.frameNumber = frameNumber;
    }
}
exports.ApexDebugStackFrameInfo = ApexDebugStackFrameInfo;
var ApexVariableKind;
(function (ApexVariableKind) {
    ApexVariableKind[ApexVariableKind["Global"] = 10] = "Global";
    ApexVariableKind[ApexVariableKind["Static"] = 20] = "Static";
    ApexVariableKind[ApexVariableKind["Local"] = 30] = "Local";
    ApexVariableKind[ApexVariableKind["Field"] = 40] = "Field";
    ApexVariableKind[ApexVariableKind["Collection"] = 50] = "Collection";
})(ApexVariableKind = exports.ApexVariableKind || (exports.ApexVariableKind = {}));
class ApexVariable extends vscode_debugadapter_1.Variable {
    constructor(value, kind, variableReference, numOfChildren) {
        super(value.name, ApexVariable.valueAsString(value), variableReference, numOfChildren);
        this.declaredTypeRef = value.declaredTypeRef;
        this.kind = kind;
        this.type = value.nameForMessages;
        this.evaluateName = this.value;
        if (value.slot !== undefined) {
            this.slot = value.slot;
        }
        else {
            this.slot = Number.MAX_SAFE_INTEGER;
        }
    }
    static valueAsString(value) {
        if (typeof value.value === 'undefined' || value.value === null) {
            // We want to explicitly display null for null values (no type info for strings).
            return 'null';
        }
        if (ApexVariable.isString(value)) {
            // We want to explicitly quote string values like in Java. This allows us to differentiate null from 'null'.
            return `'${value.value}'`;
        }
        return `${value.value}`;
    }
    static compareVariables(v1, v2) {
        // group by kind
        if (v1.kind !== v2.kind) {
            return v1.kind - v2.kind;
        }
        // use slots when available
        if (ApexVariable.isLocalOrField(v1)) {
            return v1.slot - v2.slot;
        }
        // compare names
        let n1 = v1.name;
        let n2 = v2.name;
        // convert [n], [n..m] -> n
        n1 = ApexVariable.extractNumber(n1);
        n2 = ApexVariable.extractNumber(n2);
        const i1 = parseInt(n1, 10);
        const i2 = parseInt(n2, 10);
        const isNum1 = !isNaN(i1);
        const isNum2 = !isNaN(i2);
        if (isNum1 && !isNum2) {
            return 1; // numbers after names
        }
        if (!isNum1 && isNum2) {
            return -1; // names before numbers
        }
        if (isNum1 && isNum2) {
            return i1 - i2;
        }
        return n1.localeCompare(n2);
    }
    static extractNumber(s) {
        if (s[0] === '[' && s[s.length - 1] === ']') {
            return s.substring(1, s.length - 1);
        }
        return s;
    }
    static isLocalOrField(v1) {
        return (v1.kind === ApexVariableKind.Local || v1.kind === ApexVariableKind.Field);
    }
    static isString(value) {
        return value.declaredTypeRef === 'java/lang/String';
    }
}
exports.ApexVariable = ApexVariable;
class ScopeContainer {
    constructor(type, frameInfo) {
        this.type = type;
        this.frameInfo = frameInfo;
    }
    expand(session, filter, start, count) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.frameInfo.locals &&
                !this.frameInfo.statics &&
                !this.frameInfo.globals) {
                yield session.fetchFrameVariables(this.frameInfo);
            }
            let values = [];
            let variableKind;
            switch (this.type) {
                case 'local':
                    values = this.frameInfo.locals ? this.frameInfo.locals : [];
                    variableKind = ApexVariableKind.Local;
                    break;
                case 'static':
                    values = this.frameInfo.statics ? this.frameInfo.statics : [];
                    variableKind = ApexVariableKind.Static;
                    break;
                case 'global':
                    values = this.frameInfo.globals ? this.frameInfo.globals : [];
                    variableKind = ApexVariableKind.Global;
                    break;
                default:
                    return [];
            }
            return Promise.all(values.map((value) => __awaiter(this, void 0, void 0, function* () {
                const variableReference = yield session.resolveApexIdToVariableReference(this.frameInfo.requestId, value.ref);
                return new ApexVariable(value, variableKind, variableReference, session.getNumberOfChildren(variableReference));
            })));
        });
    }
    getNumberOfChildren() {
        return undefined;
    }
}
exports.ScopeContainer = ScopeContainer;
class ObjectReferenceContainer {
    constructor(reference, requestId) {
        this.reference = reference;
        this.requestId = requestId;
        this.size = reference.size;
    }
    expand(session, filter, start, count) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.reference.fields) {
                // this object is empty
                return [];
            }
            return Promise.all(this.reference.fields.map((value) => __awaiter(this, void 0, void 0, function* () {
                const variableReference = yield session.resolveApexIdToVariableReference(this.requestId, value.ref);
                return new ApexVariable(value, ApexVariableKind.Field, variableReference, session.getNumberOfChildren(variableReference));
            })));
        });
    }
    getNumberOfChildren() {
        return this.size;
    }
}
exports.ObjectReferenceContainer = ObjectReferenceContainer;
class CollectionReferenceContainer extends ObjectReferenceContainer {
    expand(session, filter, start, count) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.reference.value) {
                // this object is empty
                return [];
            }
            if (start === undefined) {
                start = 0;
            }
            if (count === undefined) {
                count = this.reference.value.length;
            }
            const apexVariables = [];
            for (let i = start; i < start + count && i < this.reference.value.length; i++) {
                const variableReference = yield session.resolveApexIdToVariableReference(this.requestId, this.reference.value[i].ref);
                apexVariables.push(new ApexVariable(this.reference.value[i], ApexVariableKind.Collection, variableReference, session.getNumberOfChildren(variableReference)));
            }
            return Promise.resolve(apexVariables);
        });
    }
}
exports.CollectionReferenceContainer = CollectionReferenceContainer;
class MapReferenceContainer extends ObjectReferenceContainer {
    constructor() {
        super(...arguments);
        this.tupleContainers = new Map();
    }
    addTupleContainer(reference, tupleContainer) {
        this.tupleContainers.set(reference, tupleContainer);
    }
    expand(session, filter, start, count) {
        return __awaiter(this, void 0, void 0, function* () {
            if (start === undefined) {
                start = 0;
            }
            if (count === undefined) {
                count = this.tupleContainers.size;
            }
            const apexVariables = [];
            let offset = 0;
            this.tupleContainers.forEach((container, reference) => {
                if (offset >= start && offset < start + count) {
                    apexVariables.push(new ApexVariable({
                        name: container.keyAsString(),
                        declaredTypeRef: '',
                        nameForMessages: container.keyAsString(),
                        value: container.valueAsString()
                    }, ApexVariableKind.Collection, reference, session.getNumberOfChildren(reference)));
                }
                offset++;
            });
            return Promise.resolve(apexVariables);
        });
    }
}
exports.MapReferenceContainer = MapReferenceContainer;
class MapTupleContainer {
    constructor(tuple, requestId) {
        this.tuple = tuple;
        this.requestId = requestId;
    }
    keyAsString() {
        return ApexVariable.valueAsString(this.tuple.key);
    }
    valueAsString() {
        return ApexVariable.valueAsString(this.tuple.value);
    }
    expand(session, filter, start, count) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.tuple.key && !this.tuple.value) {
                // this object is empty
                return [];
            }
            const idsToFetch = [];
            if (this.tuple.key && this.tuple.key.ref) {
                idsToFetch.push(this.tuple.key.ref);
            }
            if (this.tuple.value && this.tuple.value.ref) {
                idsToFetch.push(this.tuple.value.ref);
            }
            yield session.fetchReferencesIfNecessary(this.requestId, idsToFetch);
            const variables = [];
            if (this.tuple.key) {
                const keyVariableReference = this.tuple.key.ref
                    ? yield session.resolveApexIdToVariableReference(this.requestId, this.tuple.key.ref)
                    : undefined;
                variables.push(new ApexVariable(this.tuple.key, ApexVariableKind.Collection, keyVariableReference, session.getNumberOfChildren(keyVariableReference)));
            }
            if (this.tuple.value) {
                const valueVariableReference = this.tuple.value.ref
                    ? yield session.resolveApexIdToVariableReference(this.requestId, this.tuple.value.ref)
                    : undefined;
                variables.push(new ApexVariable(this.tuple.value, ApexVariableKind.Collection, valueVariableReference, session.getNumberOfChildren(valueVariableReference)));
            }
            return variables;
        });
    }
    getNumberOfChildren() {
        return undefined;
    }
}
exports.MapTupleContainer = MapTupleContainer;
class ApexDebug extends vscode_debugadapter_1.LoggingDebugSession {
    constructor() {
        super('apex-debug-adapter.log');
        this.myRequestService = new requestService_1.RequestService();
        this.myStreamingService = core_1.StreamingService.getInstance();
        this.stackFrameInfos = new vscode_debugadapter_1.Handles();
        this.variableHandles = new vscode_debugadapter_1.Handles();
        this.variableContainerReferenceByApexId = new Map();
        this.traceAll = false;
        this.lock = new AsyncLock({ timeout: constants_1.DEFAULT_LOCK_TIMEOUT_MS });
        this.idleTimers = [];
        this.setDebuggerLinesStartAt1(true);
        this.setDebuggerPathFormat('uri');
        this.requestThreads = new Map();
        this.threadId = 1;
    }
    initializeRequest(response, args) {
        this.initializedResponse = response;
        this.initializedResponse.body = {
            supportsCompletionsRequest: false,
            supportsConditionalBreakpoints: false,
            supportsDelayedStackTraceLoading: false,
            supportsEvaluateForHovers: false,
            supportsExceptionInfoRequest: false,
            supportsExceptionOptions: false,
            supportsFunctionBreakpoints: false,
            supportsHitConditionalBreakpoints: false,
            supportsLoadedSourcesRequest: false,
            supportsRestartFrame: false,
            supportsSetVariable: false,
            supportsStepBack: false,
            supportsStepInTargetsRequest: false
        };
        this.initializedResponse.success = true;
        this.sendResponse(this.initializedResponse);
    }
    attachRequest(response, args) {
        response.success = false;
        this.sendResponse(response);
    }
    getSessionIdleTimer() {
        const timers = [];
        timers.push(setTimeout(() => {
            this.warnToDebugConsole(messages_1.nls.localize('idle_warn_text', constants_1.DEFAULT_IDLE_WARN1_MS / 60000, (constants_1.DEFAULT_IDLE_TIMEOUT_MS - constants_1.DEFAULT_IDLE_WARN1_MS) / 60000));
        }, constants_1.DEFAULT_IDLE_WARN1_MS), setTimeout(() => {
            this.warnToDebugConsole(messages_1.nls.localize('idle_warn_text', constants_1.DEFAULT_IDLE_WARN2_MS / 60000, (constants_1.DEFAULT_IDLE_TIMEOUT_MS - constants_1.DEFAULT_IDLE_WARN2_MS) / 60000));
        }, constants_1.DEFAULT_IDLE_WARN2_MS), setTimeout(() => {
            this.warnToDebugConsole(messages_1.nls.localize('idle_warn_text', constants_1.DEFAULT_IDLE_WARN3_MS / 60000, (constants_1.DEFAULT_IDLE_TIMEOUT_MS - constants_1.DEFAULT_IDLE_WARN3_MS) / 60000));
        }, constants_1.DEFAULT_IDLE_WARN3_MS), setTimeout(() => {
            this.warnToDebugConsole(messages_1.nls.localize('idle_terminated_text', constants_1.DEFAULT_IDLE_TIMEOUT_MS / 60000));
            this.sendEvent(new vscode_debugadapter_1.TerminatedEvent());
        }, constants_1.DEFAULT_IDLE_TIMEOUT_MS));
        return timers;
    }
    clearIdleTimers() {
        if (this.idleTimers) {
            this.idleTimers.forEach(timer => clearTimeout(timer));
            this.idleTimers = [];
        }
    }
    resetIdleTimer() {
        this.clearIdleTimers();
        this.idleTimers = this.getSessionIdleTimer();
        return this.idleTimers;
    }
    launchRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            this.initBreakpointSessionServices(args);
            this.setValidBreakpointLines(args);
            this.setupLogger(args);
            this.sfdxProject = args.sfdxProject;
            this.log(TRACE_CATEGORY_LAUNCH, `launchRequest: sfdxProject=${args.sfdxProject}`);
            if (!this.myBreakpointService.hasLineNumberMapping()) {
                response.message = messages_1.nls.localize('session_language_server_error_text');
                return this.sendResponse(response);
            }
            try {
                if (args.connectType === CONNECT_TYPE_ISV_DEBUGGER) {
                    const forceConfig = yield new cli_1.ForceConfigGet().getConfig(args.sfdxProject, types_1.SFDX_CONFIG_ISV_DEBUGGER_SID, types_1.SFDX_CONFIG_ISV_DEBUGGER_URL);
                    const isvDebuggerSid = forceConfig.get(types_1.SFDX_CONFIG_ISV_DEBUGGER_SID);
                    const isvDebuggerUrl = forceConfig.get(types_1.SFDX_CONFIG_ISV_DEBUGGER_URL);
                    if (typeof isvDebuggerSid === 'undefined' ||
                        typeof isvDebuggerUrl === 'undefined') {
                        response.message = messages_1.nls.localize('invalid_isv_project_config');
                        return this.sendResponse(response);
                    }
                    this.myRequestService.instanceUrl = isvDebuggerUrl;
                    this.myRequestService.accessToken = isvDebuggerSid;
                }
                else {
                    const orgInfo = yield new cli_1.ForceOrgDisplay().getOrgInfo(args.sfdxProject);
                    this.myRequestService.instanceUrl = orgInfo.instanceUrl;
                    this.myRequestService.accessToken = orgInfo.accessToken;
                }
                const isStreamingConnected = yield this.connectStreaming(args.sfdxProject);
                if (!isStreamingConnected) {
                    return this.sendResponse(response);
                }
                const sessionId = yield this.mySessionService
                    .forProject(args.sfdxProject)
                    .withUserFilter(this.toCommaSeparatedString(args.userIdFilter))
                    .withEntryFilter(args.entryPointFilter)
                    .withRequestFilter(this.toCommaSeparatedString(args.requestTypeFilter))
                    .start();
                if (this.mySessionService.isConnected()) {
                    response.success = true;
                    this.printToDebugConsole(messages_1.nls.localize('session_started_text', sessionId));
                    this.sendEvent(new vscode_debugadapter_1.InitializedEvent());
                    this.resetIdleTimer();
                }
                else {
                    this.errorToDebugConsole(`${messages_1.nls.localize('command_error_help_text')}:${os.EOL}${sessionId}`);
                }
            }
            catch (error) {
                this.tryToParseSfdxError(response, error);
            }
            this.sendResponse(response);
        });
    }
    initBreakpointSessionServices(args) {
        if (args && args.workspaceSettings) {
            const workspaceSettings = args.workspaceSettings;
            this.myRequestService.proxyUrl = workspaceSettings.proxyUrl;
            this.myRequestService.proxyStrictSSL = workspaceSettings.proxyStrictSSL;
            this.myRequestService.proxyAuthorization = workspaceSettings.proxyAuth;
            this.myRequestService.connectionTimeoutMs =
                workspaceSettings.connectionTimeoutMs;
        }
        // initialize services
        this.mySessionService = new core_1.SessionService(this.myRequestService);
        this.myBreakpointService = new core_1.BreakpointService(this.myRequestService);
    }
    setValidBreakpointLines(args) {
        if (args && args.lineBreakpointInfo) {
            const lineBpInfo = args.lineBreakpointInfo;
            if (lineBpInfo && lineBpInfo.length > 0) {
                const lineNumberMapping = new Map();
                const typerefMapping = new Map();
                for (const info of lineBpInfo) {
                    if (!lineNumberMapping.has(info.uri)) {
                        lineNumberMapping.set(info.uri, []);
                    }
                    const validLines = {
                        typeref: info.typeref,
                        lines: info.lines
                    };
                    lineNumberMapping.get(info.uri).push(validLines);
                    typerefMapping.set(info.typeref, info.uri);
                }
                this.myBreakpointService.setValidLines(lineNumberMapping, typerefMapping);
            }
        }
    }
    setupLogger(args) {
        if (typeof args.trace === 'boolean') {
            this.trace = args.trace ? [TRACE_ALL] : undefined;
            this.traceAll = args.trace;
        }
        else if (typeof args.trace === 'string') {
            this.trace = args.trace.split(',').map(category => category.trim());
            this.traceAll = this.trace.indexOf(TRACE_ALL) >= 0;
        }
        if (this.trace && this.trace.indexOf(TRACE_CATEGORY_PROTOCOL) >= 0) {
            // only log debug adapter protocol if 'protocol' tracing flag is set, ignore traceAll here
            vscode_debugadapter_1.logger.setup(vscode_debugadapter_1.Logger.LogLevel.Verbose, false);
        }
        else {
            vscode_debugadapter_1.logger.setup(vscode_debugadapter_1.Logger.LogLevel.Stop, false);
        }
    }
    disconnectRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                response.success = false;
                this.myStreamingService.disconnect();
                if (this.mySessionService.isConnected()) {
                    try {
                        const terminatedSessionId = yield this.mySessionService.stop();
                        if (!this.mySessionService.isConnected()) {
                            response.success = true;
                            this.printToDebugConsole(messages_1.nls.localize('session_terminated_text', terminatedSessionId));
                        }
                        else {
                            this.errorToDebugConsole(`${messages_1.nls.localize('command_error_help_text')}:${os.EOL}${terminatedSessionId}`);
                        }
                    }
                    catch (error) {
                        this.tryToParseSfdxError(response, error);
                    }
                }
                else {
                    response.success = true;
                }
                this.sendResponse(response);
            }
            finally {
                this.clearIdleTimers();
            }
        });
    }
    setBreakPointsRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.source && args.source.path && args.lines) {
                response.body = { breakpoints: [] };
                const uri = this.convertClientPathToDebugger(args.source.path);
                const unverifiedBreakpoints = [];
                let verifiedBreakpoints = new Set();
                try {
                    verifiedBreakpoints = yield this.lock.acquire(`breakpoint-${uri}`, () => __awaiter(this, void 0, void 0, function* () {
                        this.log(TRACE_CATEGORY_BREAKPOINTS, `setBreakPointsRequest: uri=${uri}`);
                        const knownBps = yield this.myBreakpointService.reconcileLineBreakpoints(this.sfdxProject, uri, this.mySessionService.getSessionId(), args.lines.map(line => this.convertClientLineToDebugger(line)));
                        return Promise.resolve(knownBps);
                    }));
                    // tslint:disable-next-line:no-empty
                }
                catch (error) { }
                verifiedBreakpoints.forEach(verifiedBreakpoint => {
                    const lineNumber = this.convertDebuggerLineToClient(verifiedBreakpoint);
                    response.body.breakpoints.push({
                        verified: true,
                        source: args.source,
                        line: lineNumber
                    });
                });
                args.lines.forEach(lineArg => {
                    if (!verifiedBreakpoints.has(lineArg)) {
                        const lineNumber = this.convertDebuggerLineToClient(lineArg);
                        response.body.breakpoints.push({
                            verified: false,
                            source: args.source,
                            line: lineNumber
                        });
                        unverifiedBreakpoints.push(lineNumber);
                    }
                });
                this.log(TRACE_CATEGORY_BREAKPOINTS, `setBreakPointsRequest: uri=${uri} args.lines=${args.lines.join(',')} verified=${Array.from(verifiedBreakpoints).join(',')} unverified=${unverifiedBreakpoints.join(',')}`);
            }
            response.success = true;
            this.sendResponse(response);
        });
    }
    continueRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            response.body = { allThreadsContinued: false };
            if (this.requestThreads.has(args.threadId)) {
                const requestId = this.requestThreads.get(args.threadId);
                try {
                    yield this.myRequestService.execute(new commands_1.RunCommand(requestId));
                    response.success = true;
                }
                catch (error) {
                    response.message = error;
                }
            }
            this.resetIdleTimer();
            this.sendResponse(response);
        });
    }
    nextRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            if (this.requestThreads.has(args.threadId)) {
                const requestId = this.requestThreads.get(args.threadId);
                try {
                    yield this.myRequestService.execute(new commands_1.StepOverCommand(requestId));
                    response.success = true;
                }
                catch (error) {
                    response.message = error;
                }
            }
            this.sendResponse(response);
        });
    }
    stepInRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            if (this.requestThreads.has(args.threadId)) {
                const requestId = this.requestThreads.get(args.threadId);
                try {
                    yield this.myRequestService.execute(new commands_1.StepIntoCommand(requestId));
                    response.success = true;
                }
                catch (error) {
                    response.message = error;
                }
            }
            this.sendResponse(response);
        });
    }
    stepOutRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            if (this.requestThreads.has(args.threadId)) {
                const requestId = this.requestThreads.get(args.threadId);
                try {
                    yield this.myRequestService.execute(new commands_1.StepOutCommand(requestId));
                    response.success = true;
                }
                catch (error) {
                    response.message = error;
                }
            }
            this.sendResponse(response);
        });
    }
    threadsRequest(response) {
        const debuggedThreads = [];
        for (const threadId of this.requestThreads.keys()) {
            debuggedThreads.push(new vscode_debugadapter_1.Thread(threadId, `Request ID: ${this.requestThreads.get(threadId)}`));
        }
        response.success = true;
        response.body = { threads: debuggedThreads };
        this.sendResponse(response);
    }
    stackTraceRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = false;
            if (!this.requestThreads.has(args.threadId)) {
                return this.sendResponse(response);
            }
            const requestId = this.requestThreads.get(args.threadId);
            try {
                const stateResponse = yield this.lock.acquire('stacktrace', () => __awaiter(this, void 0, void 0, function* () {
                    this.log(TRACE_CATEGORY_VARIABLES, `stackTraceRequest: args threadId=${args.threadId} startFrame=${args.startFrame} levels=${args.levels}`);
                    const responseString = yield this.myRequestService.execute(new commands_1.StateCommand(requestId));
                    return Promise.resolve(responseString);
                }));
                const stateRespObj = JSON.parse(stateResponse);
                const clientFrames = [];
                if (this.hasStackFrames(stateRespObj)) {
                    const serverFrames = stateRespObj.stateResponse.state.stack.stackFrame;
                    for (let i = 0; i < serverFrames.length; i++) {
                        const sourcePath = this.myBreakpointService.getSourcePathFromTyperef(serverFrames[i].typeRef);
                        const frameInfo = new ApexDebugStackFrameInfo(requestId, serverFrames[i].frameNumber);
                        const frameId = this.stackFrameInfos.create(frameInfo);
                        if (i === 0 && stateRespObj.stateResponse.state) {
                            // populate first stack frame with info from state response (saves a server round trip)
                            this.log(TRACE_CATEGORY_VARIABLES, 'stackTraceRequest: state=' +
                                JSON.stringify(stateRespObj.stateResponse.state));
                            if (stateRespObj.stateResponse.state.locals &&
                                stateRespObj.stateResponse.state.locals.local) {
                                frameInfo.locals = stateRespObj.stateResponse.state.locals.local;
                            }
                            else {
                                frameInfo.locals = [];
                            }
                            if (stateRespObj.stateResponse.state.statics &&
                                stateRespObj.stateResponse.state.statics.static) {
                                frameInfo.statics =
                                    stateRespObj.stateResponse.state.statics.static;
                            }
                            else {
                                frameInfo.statics = [];
                            }
                            if (stateRespObj.stateResponse.state.globals &&
                                stateRespObj.stateResponse.state.globals.global) {
                                frameInfo.globals =
                                    stateRespObj.stateResponse.state.globals.global;
                            }
                            else {
                                frameInfo.globals = [];
                            }
                            if (stateRespObj.stateResponse.state.references &&
                                stateRespObj.stateResponse.state.references.references) {
                                this.populateReferences(stateRespObj.stateResponse.state.references.references, frameInfo.requestId);
                            }
                        }
                        clientFrames.push(new vscode_debugadapter_1.StackFrame(frameId, serverFrames[i].fullName, sourcePath
                            ? new vscode_debugadapter_1.Source(path_1.basename(sourcePath), this.convertDebuggerPathToClient(sourcePath))
                            : undefined, this.convertDebuggerLineToClient(serverFrames[i].lineNumber), 0));
                    }
                }
                response.body = { stackFrames: clientFrames };
                response.success = true;
            }
            catch (error) {
                response.message = error;
            }
            this.sendResponse(response);
        });
    }
    hasStackFrames(response) {
        if (response &&
            response.stateResponse &&
            response.stateResponse.state &&
            response.stateResponse.state.stack &&
            response.stateResponse.state.stack.stackFrame &&
            response.stateResponse.state.stack.stackFrame.length > 0) {
            return true;
        }
        return false;
    }
    customRequest(command, response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = true;
            switch (command) {
                case constants_1.HOTSWAP_REQUEST:
                    this.warnToDebugConsole(messages_1.nls.localize('hotswap_warn_text'));
                    break;
                case constants_1.EXCEPTION_BREAKPOINT_REQUEST:
                    const requestArgs = args;
                    if (requestArgs && requestArgs.exceptionInfo) {
                        try {
                            yield this.lock.acquire('exception-breakpoint', () => __awaiter(this, void 0, void 0, function* () {
                                return this.myBreakpointService.reconcileExceptionBreakpoints(this.sfdxProject, this.mySessionService.getSessionId(), requestArgs.exceptionInfo);
                            }));
                            if (requestArgs.exceptionInfo.breakMode ===
                                constants_1.EXCEPTION_BREAKPOINT_BREAK_MODE_ALWAYS) {
                                this.printToDebugConsole(messages_1.nls.localize('created_exception_breakpoint_text', requestArgs.exceptionInfo.label));
                            }
                            else if (requestArgs.exceptionInfo.breakMode ===
                                constants_1.EXCEPTION_BREAKPOINT_BREAK_MODE_NEVER) {
                                this.printToDebugConsole(messages_1.nls.localize('removed_exception_breakpoint_text', requestArgs.exceptionInfo.label));
                            }
                        }
                        catch (error) {
                            response.success = false;
                            this.log(TRACE_CATEGORY_BREAKPOINTS, `exceptionBreakpointRequest: error=${error}`);
                        }
                    }
                    break;
                case constants_1.LIST_EXCEPTION_BREAKPOINTS_REQUEST:
                    const exceptionBreakpoints = this.myBreakpointService.getExceptionBreakpointCache();
                    response.body = {
                        typerefs: Array.from(exceptionBreakpoints.keys())
                    };
                    break;
                default:
                    break;
            }
            this.sendResponse(response);
        });
    }
    scopesRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = true;
            const frameInfo = this.stackFrameInfos.get(args.frameId);
            if (!frameInfo) {
                this.log(TRACE_CATEGORY_VARIABLES, `scopesRequest: no frame info found for stack frame ${args.frameId}`);
                response.body = { scopes: [] };
                this.sendResponse(response);
                return;
            }
            const scopes = new Array();
            scopes.push(new vscode_debugadapter_1.Scope('Local', this.variableHandles.create(new ScopeContainer('local', frameInfo)), false));
            scopes.push(new vscode_debugadapter_1.Scope('Static', this.variableHandles.create(new ScopeContainer('static', frameInfo)), false));
            scopes.push(new vscode_debugadapter_1.Scope('Global', this.variableHandles.create(new ScopeContainer('global', frameInfo)), false));
            scopes.forEach(scope => {
                this.log(TRACE_CATEGORY_VARIABLES, `scopesRequest: scope name=${scope.name} variablesReference=${scope.variablesReference}`);
            });
            response.body = { scopes };
            this.sendResponse(response);
        });
    }
    variablesRequest(response, args) {
        return __awaiter(this, void 0, void 0, function* () {
            response.success = true;
            const variablesContainer = this.variableHandles.get(args.variablesReference);
            if (!variablesContainer) {
                this.log(TRACE_CATEGORY_VARIABLES, `variablesRequest: no container for variablesReference=${args.variablesReference}`);
                // no container found: return empty variables array
                response.body = { variables: [] };
                this.sendResponse(response);
                return;
            }
            else {
                this.log(TRACE_CATEGORY_VARIABLES, `variablesRequest: getting variable for variablesReference=${args.variablesReference} start=${args.start} count=${args.count}`);
            }
            const filter = args.filter === 'indexed' || args.filter === 'named'
                ? args.filter
                : 'all';
            try {
                const variables = yield variablesContainer.expand(this, filter, args.start, args.count);
                variables.sort(ApexVariable.compareVariables);
                response.body = { variables };
                this.resetIdleTimer();
                this.sendResponse(response);
            }
            catch (error) {
                this.log(TRACE_CATEGORY_VARIABLES, `variablesRequest: error reading variables ${error} ${error.stack}`);
                // in case of error return empty variables array
                response.body = { variables: [] };
                this.sendResponse(response);
            }
        });
    }
    fetchFrameVariables(frameInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const frameResponse = yield this.myRequestService.execute(new commands_1.FrameCommand(frameInfo.requestId, frameInfo.frameNumber));
            const frameRespObj = JSON.parse(frameResponse);
            if (frameRespObj &&
                frameRespObj.frameResponse &&
                frameRespObj.frameResponse.frame) {
                this.log(TRACE_CATEGORY_VARIABLES, `fetchFrameVariables: frame ${frameInfo.frameNumber} frame=` +
                    JSON.stringify(frameRespObj.frameResponse.frame));
                if (frameRespObj.frameResponse.frame.locals &&
                    frameRespObj.frameResponse.frame.locals.local) {
                    frameInfo.locals = frameRespObj.frameResponse.frame.locals.local;
                }
                else {
                    frameInfo.locals = [];
                }
                if (frameRespObj.frameResponse.frame.statics &&
                    frameRespObj.frameResponse.frame.statics.static) {
                    frameInfo.statics = frameRespObj.frameResponse.frame.statics.static;
                }
                else {
                    frameInfo.statics = [];
                }
                if (frameRespObj.frameResponse.frame.globals &&
                    frameRespObj.frameResponse.frame.globals.global) {
                    frameInfo.globals = frameRespObj.frameResponse.frame.globals.global;
                }
                else {
                    frameInfo.globals = [];
                }
                if (frameRespObj.frameResponse.frame.references &&
                    frameRespObj.frameResponse.frame.references.references) {
                    this.populateReferences(frameRespObj.frameResponse.frame.references.references, frameInfo.requestId);
                }
            }
        });
    }
    populateReferences(references, requestId) {
        references.map(reference => {
            if (this.variableContainerReferenceByApexId.has(reference.id)) {
                return;
            }
            let variableReference;
            if (reference.type === 'object') {
                variableReference = this.variableHandles.create(new ObjectReferenceContainer(reference, requestId));
                this.log(TRACE_CATEGORY_VARIABLES, `populateReferences: new object reference: ${variableReference} for ${reference.id} ${reference.nameForMessages}`);
            }
            else if (reference.type === 'list' || reference.type === 'set') {
                variableReference = this.variableHandles.create(new CollectionReferenceContainer(reference, requestId));
                this.log(TRACE_CATEGORY_VARIABLES, `populateReferences: new ${reference.type} reference: ${variableReference} for ${reference.id} ${reference.nameForMessages} with size ${reference.size}`);
            }
            else if (reference.type === 'map') {
                const mapContainer = new MapReferenceContainer(reference, requestId);
                // explode all map entried so that we can drill down a map logically
                if (reference.tuple) {
                    reference.tuple.forEach(tuple => {
                        const tupleContainer = new MapTupleContainer(tuple, requestId);
                        const tupleReference = this.variableHandles.create(tupleContainer);
                        mapContainer.addTupleContainer(tupleReference, tupleContainer);
                    });
                }
                variableReference = this.variableHandles.create(mapContainer);
                this.log(TRACE_CATEGORY_VARIABLES, `populateReferences: new map reference: ${variableReference} for ${reference.id} ${reference.nameForMessages}`);
            }
            else {
                const referenceInfo = JSON.stringify(reference);
                this.log(TRACE_CATEGORY_VARIABLES, `populateReferences: unhandled reference: ${referenceInfo}`);
                return;
            }
            // map apex id to container reference
            this.variableContainerReferenceByApexId.set(reference.id, variableReference);
        });
    }
    getNumberOfChildren(variableReference) {
        if (variableReference !== undefined) {
            const variableContainer = this.variableHandles.get(variableReference);
            if (variableContainer) {
                return variableContainer.getNumberOfChildren();
            }
        }
    }
    resolveApexIdToVariableReference(requestId, apexId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof apexId === 'undefined') {
                return;
            }
            if (!this.variableContainerReferenceByApexId.has(apexId)) {
                yield this.fetchReferences(requestId, apexId);
                if (!this.variableContainerReferenceByApexId.has(apexId)) {
                    this.log(TRACE_CATEGORY_VARIABLES, `resolveApexIdToVariableReference: no reference found for apexId ${apexId} (request ${requestId})`);
                    return;
                }
            }
            const variableReference = this.variableContainerReferenceByApexId.get(apexId);
            this.log(TRACE_CATEGORY_VARIABLES, `resolveApexIdToVariableReference: resolved apexId=${apexId} to variableReference=${variableReference}`);
            return variableReference;
        });
    }
    fetchReferences(requestId, ...apexIds) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(TRACE_CATEGORY_VARIABLES, `fetchReferences: fetching references with apexIds=${apexIds} (request ${requestId})`);
            const referencesResponse = yield this.myRequestService.execute(new commands_1.ReferencesCommand(requestId, ...apexIds));
            const referencesResponseObj = JSON.parse(referencesResponse);
            if (referencesResponseObj &&
                referencesResponseObj.referencesResponse &&
                referencesResponseObj.referencesResponse.references &&
                referencesResponseObj.referencesResponse.references.references) {
                this.populateReferences(referencesResponseObj.referencesResponse.references.references, requestId);
            }
        });
    }
    fetchReferencesIfNecessary(requestId, apexIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const apexIdsToFetch = apexIds.filter(apexId => !this.variableContainerReferenceByApexId.has(apexId));
            if (apexIdsToFetch.length === 0) {
                return;
            }
            this.log(TRACE_CATEGORY_VARIABLES, `fetchReferences: fetching references with apexIds=${apexIdsToFetch} (request ${requestId})`);
            yield this.fetchReferences(requestId, ...apexIdsToFetch);
        });
    }
    evaluateRequest(response, args) {
        response.body = {
            result: args.expression,
            variablesReference: 0
        };
        response.success = true;
        this.sendResponse(response);
    }
    printToDebugConsole(msg, sourceFile, sourceLine) {
        if (msg && msg.length !== 0) {
            const event = new vscode_debugadapter_1.OutputEvent(`${msg}${ApexDebug.LINEBREAK}`, 'stdout');
            event.body.source = sourceFile;
            event.body.line = sourceLine;
            event.body.column = 0;
            this.sendEvent(event);
        }
    }
    warnToDebugConsole(msg) {
        if (msg && msg.length !== 0) {
            this.sendEvent(new vscode_debugadapter_1.OutputEvent(`${msg}${ApexDebug.LINEBREAK}`, 'console'));
        }
    }
    errorToDebugConsole(msg) {
        if (msg && msg.length !== 0) {
            this.sendEvent(new vscode_debugadapter_1.OutputEvent(`${msg}${ApexDebug.LINEBREAK}`, 'stderr'));
        }
    }
    log(traceCategory, message) {
        if (this.trace &&
            (this.traceAll || this.trace.indexOf(traceCategory) >= 0)) {
            this.printToDebugConsole(`${process.pid}: ${message}`);
        }
    }
    tryToParseSfdxError(response, error) {
        if (!error) {
            return;
        }
        try {
            response.success = false;
            const errorObj = helpers_1.extractJsonObject(error);
            if (errorObj && errorObj.message) {
                const errorMessage = errorObj.message;
                if (errorMessage.includes('entity type cannot be inserted: Apex Debugger Session')) {
                    response.message = messages_1.nls.localize('session_no_entity_access_text');
                }
                else {
                    response.message = errorMessage;
                }
                if (errorObj.action) {
                    this.errorToDebugConsole(`${messages_1.nls.localize('command_error_help_text')}:${os.EOL}${errorObj.action}`);
                }
            }
            else {
                response.message = messages_1.nls.localize('unexpected_error_help_text');
                this.errorToDebugConsole(`${messages_1.nls.localize('command_error_help_text')}:${os.EOL}${error}`);
            }
        }
        catch (e) {
            response.message =
                response.message || messages_1.nls.localize('unexpected_error_help_text');
            this.errorToDebugConsole(`${messages_1.nls.localize('command_error_help_text')}:${os.EOL}${error}`);
        }
    }
    connectStreaming(projectPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const clientInfos = [];
            for (const channel of [
                core_1.StreamingService.SYSTEM_EVENT_CHANNEL,
                core_1.StreamingService.USER_EVENT_CHANNEL
            ]) {
                const clientInfo = new core_1.StreamingClientInfoBuilder()
                    .forChannel(channel)
                    .withConnectedHandler(() => {
                    this.printToDebugConsole(messages_1.nls.localize('streaming_connected_text', channel));
                })
                    .withDisconnectedHandler(() => {
                    this.printToDebugConsole(messages_1.nls.localize('streaming_disconnected_text', channel));
                })
                    .withErrorHandler((reason) => {
                    this.errorToDebugConsole(reason);
                })
                    .withMsgHandler((message) => {
                    const data = message;
                    if (data && data.sobject && data.event) {
                        this.handleEvent(data);
                    }
                })
                    .build();
                clientInfos.push(clientInfo);
            }
            const systemChannelInfo = clientInfos[0];
            const userChannelInfo = clientInfos[1];
            return this.myStreamingService.subscribe(projectPath, this.myRequestService, systemChannelInfo, userChannelInfo);
        });
    }
    handleEvent(message) {
        const type = core_1.ApexDebuggerEventType[message.sobject.Type];
        this.log(TRACE_CATEGORY_STREAMINGAPI, `handleEvent: received ${JSON.stringify(message)}`);
        if (!this.mySessionService.isConnected() ||
            this.mySessionService.getSessionId() !== message.sobject.SessionId ||
            this.myStreamingService.hasProcessedEvent(type, message.event.replayId)) {
            this.log(TRACE_CATEGORY_STREAMINGAPI, `handleEvent: event ignored`);
            return;
        }
        switch (type) {
            case core_1.ApexDebuggerEventType.ApexException: {
                this.handleApexException(message);
                break;
            }
            case core_1.ApexDebuggerEventType.Debug: {
                this.handleDebug(message);
                break;
            }
            case core_1.ApexDebuggerEventType.RequestFinished: {
                this.handleRequestFinished(message);
                break;
            }
            case core_1.ApexDebuggerEventType.RequestStarted: {
                this.handleRequestStarted(message);
                break;
            }
            case core_1.ApexDebuggerEventType.Resumed: {
                this.handleResumed(message);
                break;
            }
            case core_1.ApexDebuggerEventType.SessionTerminated: {
                this.handleSessionTerminated(message);
                break;
            }
            case core_1.ApexDebuggerEventType.Stopped: {
                this.handleStopped(message);
                break;
            }
            case core_1.ApexDebuggerEventType.SystemGack: {
                this.handleSystemGack(message);
                break;
            }
            case core_1.ApexDebuggerEventType.SystemInfo: {
                this.handleSystemInfo(message);
                break;
            }
            case core_1.ApexDebuggerEventType.SystemWarning: {
                this.handleSystemWarning(message);
                break;
            }
            case core_1.ApexDebuggerEventType.LogLine:
            case core_1.ApexDebuggerEventType.OrgChange:
            case core_1.ApexDebuggerEventType.Ready:
            default: {
                break;
            }
        }
        this.myStreamingService.markEventProcessed(type, message.event.replayId);
    }
    logEvent(message) {
        let eventDescriptionSourceFile;
        let eventDescriptionSourceLine;
        let logMessage = message.event.createdDate === null
            ? new Date().toUTCString()
            : message.event.createdDate;
        logMessage += ` | ${message.sobject.Type}`;
        if (message.sobject.RequestId) {
            logMessage += ` | Request: ${message.sobject.RequestId}`;
        }
        if (message.sobject.BreakpointId) {
            logMessage += ` | Breakpoint: ${message.sobject.BreakpointId}`;
        }
        if (message.sobject.Line) {
            logMessage += ` | Line: ${message.sobject.Line}`;
        }
        if (message.sobject.Description) {
            logMessage += ` | ${message.sobject.Description}`;
            const regExp = /^(.*)\[(\d+)\]\|/;
            const matches = message.sobject.Description.match(regExp);
            if (matches && matches.length === 3) {
                const possibleClassName = matches[1];
                const possibleClassLine = parseInt(matches[2], 10);
                const possibleSourcePath = this.myBreakpointService.getSourcePathFromPartialTyperef(possibleClassName);
                if (possibleSourcePath) {
                    eventDescriptionSourceFile = new vscode_debugadapter_1.Source(path_1.basename(possibleSourcePath), this.convertDebuggerPathToClient(possibleSourcePath));
                    eventDescriptionSourceLine = this.convertDebuggerLineToClient(possibleClassLine);
                }
            }
        }
        if (message.sobject.Stacktrace) {
            logMessage += ` |${os.EOL}${message.sobject.Stacktrace}`;
        }
        this.printToDebugConsole(logMessage, eventDescriptionSourceFile, eventDescriptionSourceLine);
    }
    getThreadIdFromRequestId(requestId) {
        for (const threadId of this.requestThreads.keys()) {
            if (this.requestThreads.get(threadId) === requestId) {
                return threadId;
            }
        }
    }
    handleApexException(message) {
        this.logEvent(message);
    }
    handleDebug(message) {
        this.logEvent(message);
    }
    handleRequestFinished(message) {
        const threadId = this.getThreadIdFromRequestId(message.sobject.RequestId);
        if (threadId !== undefined) {
            this.logEvent(message);
            this.requestThreads.delete(threadId);
            this.sendEvent(new vscode_debugadapter_1.ThreadEvent('exited', threadId));
            // cleanup everything that's no longer necessary after all request finished
            if (this.requestThreads.size === 0) {
                this.log(TRACE_CATEGORY_VARIABLES, 'handleRequestFinished: clearing variable cache');
                this.stackFrameInfos.reset();
                this.variableHandles.reset();
                this.variableContainerReferenceByApexId.clear();
            }
        }
    }
    handleRequestStarted(message) {
        if (message.sobject.RequestId) {
            this.logEvent(message);
            this.requestThreads.set(this.threadId++, message.sobject.RequestId);
        }
    }
    handleResumed(message) {
        const threadId = this.getThreadIdFromRequestId(message.sobject.RequestId);
        if (threadId !== undefined) {
            this.logEvent(message);
        }
    }
    handleSessionTerminated(message) {
        if (message.sobject.Description) {
            this.errorToDebugConsole(message.sobject.Description);
            this.sendEvent(new vscode_debugadapter_1.Event(constants_1.SHOW_MESSAGE_EVENT, {
                type: index_1.VscodeDebuggerMessageType.Error,
                message: message.sobject.Description
            }));
        }
        this.mySessionService.forceStop();
        this.sendEvent(new vscode_debugadapter_1.TerminatedEvent());
    }
    handleStopped(message) {
        const threadId = this.getThreadIdFromRequestId(message.sobject.RequestId);
        if (threadId !== undefined) {
            // cleanup everything that's no longer valid after a stop event
            // but only if only one request is currently debugged (we wan't to preserve the info for a second request)
            if (this.requestThreads.size === 1) {
                this.log(TRACE_CATEGORY_VARIABLES, 'handleStopped: clearing variable cache');
                this.stackFrameInfos.reset();
                this.variableHandles.reset();
                this.variableContainerReferenceByApexId.clear();
            }
            // log to console and notify client
            this.logEvent(message);
            let reason = '';
            // if breakpointid is found in exception breakpoint cache
            // set the reason for stopped event to that reason
            if (message.sobject.BreakpointId) {
                const cache = this.myBreakpointService.getExceptionBreakpointCache();
                cache.forEach((value, key) => {
                    if (value === message.sobject.BreakpointId) {
                        // typerefs for exceptions will change based on whether they are custom,
                        // defined as an inner class, defined in a trigger, or in a namespaced org
                        reason = key
                            .replace(constants_1.SALESFORCE_EXCEPTION_PREFIX, '')
                            .replace(constants_1.TRIGGER_EXCEPTION_PREFIX, '')
                            .replace('$', '.')
                            .replace('/', '.');
                    }
                });
            }
            const stoppedEvent = new vscode_debugadapter_1.StoppedEvent(reason, threadId);
            this.sendEvent(stoppedEvent);
        }
    }
    handleSystemGack(message) {
        this.logEvent(message);
        if (message.sobject.Description) {
            this.sendEvent(new vscode_debugadapter_1.Event(constants_1.SHOW_MESSAGE_EVENT, {
                type: index_1.VscodeDebuggerMessageType.Error,
                message: message.sobject.Description
            }));
        }
    }
    handleSystemInfo(message) {
        this.logEvent(message);
    }
    handleSystemWarning(message) {
        this.logEvent(message);
        if (message.sobject.Description) {
            this.sendEvent(new vscode_debugadapter_1.Event(constants_1.SHOW_MESSAGE_EVENT, {
                type: index_1.VscodeDebuggerMessageType.Warning,
                message: message.sobject.Description
            }));
        }
    }
    toCommaSeparatedString(arg) {
        if (arg && arg.length > 0) {
            return Array.from(new Set(arg)).join(',');
        }
        return '';
    }
}
exports.ApexDebug = ApexDebug;
ApexDebug.LINEBREAK = `${os.EOL}`;
vscode_debugadapter_1.DebugSession.run(ApexDebug);
//# sourceMappingURL=apexDebug.js.map