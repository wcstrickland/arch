"use strict";
/*
 * Copyright (c) 2017, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@salesforce/salesforcedx-utils-vscode/out/src/cli");
class BreakpointService {
    constructor(requestService) {
        this.lineNumberMapping = new Map();
        this.typerefMapping = new Map();
        this.lineBreakpointCache = new Map();
        this.exceptionBreakpointCache = new Map();
        this.requestService = requestService;
    }
    setValidLines(lineNumberMapping, typerefMapping) {
        this.lineNumberMapping = lineNumberMapping;
        this.typerefMapping = typerefMapping;
    }
    hasLineNumberMapping() {
        return this.lineNumberMapping && this.lineNumberMapping.size > 0;
    }
    isApexDebuggerBreakpointId(id) {
        return id != null && id.startsWith('07b');
    }
    getTyperefFor(uri, line) {
        const linesInTyperefs = this.lineNumberMapping.get(uri);
        if (linesInTyperefs) {
            for (const linesInTyperef of linesInTyperefs) {
                if (linesInTyperef.lines.indexOf(line) >= 0) {
                    return linesInTyperef.typeref;
                }
            }
        }
    }
    getSourcePathFromTyperef(typeref) {
        return this.typerefMapping.get(typeref);
    }
    getSourcePathFromPartialTyperef(partialTyperef) {
        for (const typeref of this.typerefMapping.keys()) {
            if (typeref.endsWith(partialTyperef)) {
                return this.typerefMapping.get(typeref);
            }
        }
    }
    cacheLineBreakpoint(uriArg, lineArg, breakpointIdArg) {
        if (!this.lineBreakpointCache.has(uriArg)) {
            this.lineBreakpointCache.set(uriArg, []);
        }
        this.lineBreakpointCache.get(uriArg).push({
            line: lineArg,
            breakpointId: breakpointIdArg
        });
    }
    getLineBreakpointCache() {
        return this.lineBreakpointCache;
    }
    getExceptionBreakpointCache() {
        return this.exceptionBreakpointCache;
    }
    getBreakpointsFor(uri) {
        const lines = new Set();
        const existingBreakpoints = this.lineBreakpointCache.get(uri);
        if (existingBreakpoints) {
            for (const breakpointInfo of existingBreakpoints) {
                lines.add(breakpointInfo.line);
            }
        }
        return lines;
    }
    createLineBreakpoint(projectPath, sessionId, typeref, line) {
        return __awaiter(this, void 0, void 0, function* () {
            const execution = new cli_1.CliCommandExecutor(new cli_1.SfdxCommandBuilder()
                .withArg('force:data:record:create')
                .withFlag('--sobjecttype', 'ApexDebuggerBreakpoint')
                .withFlag('--values', `SessionId='${sessionId}' FileName='${typeref}' Line=${line} IsEnabled='true' Type='Line'`)
                .withArg('--usetoolingapi')
                .withJson()
                .build(), { cwd: projectPath, env: this.requestService.getEnvVars() }).execute();
            const cmdOutput = new cli_1.CommandOutput();
            const result = yield cmdOutput.getCmdResult(execution);
            try {
                const breakpointId = JSON.parse(result).result.id;
                if (this.isApexDebuggerBreakpointId(breakpointId)) {
                    return Promise.resolve(breakpointId);
                }
                else {
                    return Promise.reject(result);
                }
            }
            catch (e) {
                return Promise.reject(result);
            }
        });
    }
    deleteBreakpoint(projectPath, breakpointId) {
        return __awaiter(this, void 0, void 0, function* () {
            const execution = new cli_1.CliCommandExecutor(new cli_1.SfdxCommandBuilder()
                .withArg('force:data:record:delete')
                .withFlag('--sobjecttype', 'ApexDebuggerBreakpoint')
                .withFlag('--sobjectid', breakpointId)
                .withArg('--usetoolingapi')
                .withJson()
                .build(), { cwd: projectPath, env: this.requestService.getEnvVars() }).execute();
            const cmdOutput = new cli_1.CommandOutput();
            const result = yield cmdOutput.getCmdResult(execution);
            try {
                const deletedBreakpointId = JSON.parse(result).result.id;
                if (this.isApexDebuggerBreakpointId(deletedBreakpointId)) {
                    return Promise.resolve(deletedBreakpointId);
                }
                else {
                    return Promise.reject(result);
                }
            }
            catch (e) {
                return Promise.reject(result);
            }
        });
    }
    reconcileLineBreakpoints(projectPath, uri, sessionId, clientLines) {
        return __awaiter(this, void 0, void 0, function* () {
            const knownBreakpoints = this.lineBreakpointCache.get(uri);
            if (knownBreakpoints) {
                for (let knownBpIdx = knownBreakpoints.length - 1; knownBpIdx >= 0; knownBpIdx--) {
                    const knownBp = knownBreakpoints[knownBpIdx];
                    if (clientLines.indexOf(knownBp.line) === -1) {
                        try {
                            const breakpointId = yield this.deleteBreakpoint(projectPath, knownBp.breakpointId);
                            if (breakpointId) {
                                knownBreakpoints.splice(knownBpIdx, 1);
                            }
                            // tslint:disable-next-line:no-empty
                        }
                        catch (error) { }
                    }
                }
            }
            for (const clientLine of clientLines) {
                if (!knownBreakpoints ||
                    !knownBreakpoints.find(knownBreakpoint => knownBreakpoint.line === clientLine)) {
                    const typeref = this.getTyperefFor(uri, clientLine);
                    if (typeref) {
                        try {
                            const breakpointId = yield this.createLineBreakpoint(projectPath, sessionId, typeref, clientLine);
                            if (breakpointId) {
                                this.cacheLineBreakpoint(uri, clientLine, breakpointId);
                            }
                            // tslint:disable-next-line:no-empty
                        }
                        catch (error) { }
                    }
                }
            }
            return Promise.resolve(this.getBreakpointsFor(uri));
        });
    }
    createExceptionBreakpoint(projectPath, sessionId, typeref) {
        return __awaiter(this, void 0, void 0, function* () {
            const execution = new cli_1.CliCommandExecutor(new cli_1.SfdxCommandBuilder()
                .withArg('force:data:record:create')
                .withFlag('--sobjecttype', 'ApexDebuggerBreakpoint')
                .withFlag('--values', `SessionId='${sessionId}' FileName='${typeref}' IsEnabled='true' Type='Exception'`)
                .withArg('--usetoolingapi')
                .withJson()
                .build(), { cwd: projectPath, env: this.requestService.getEnvVars() }).execute();
            const cmdOutput = new cli_1.CommandOutput();
            const result = yield cmdOutput.getCmdResult(execution);
            try {
                const breakpointId = JSON.parse(result).result.id;
                if (this.isApexDebuggerBreakpointId(breakpointId)) {
                    return Promise.resolve(breakpointId);
                }
                else {
                    return Promise.reject(result);
                }
            }
            catch (e) {
                return Promise.reject(result);
            }
        });
    }
    reconcileExceptionBreakpoints(projectPath, sessionId, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const knownBreakpointId = this.exceptionBreakpointCache.get(info.typeref);
            if (knownBreakpointId && info.breakMode === 'never') {
                yield this.deleteBreakpoint(projectPath, knownBreakpointId);
                this.exceptionBreakpointCache.delete(info.typeref);
            }
            else if (!knownBreakpointId && info.breakMode === 'always') {
                const createdBreakpointId = yield this.createExceptionBreakpoint(projectPath, sessionId, info.typeref);
                if (createdBreakpointId) {
                    this.exceptionBreakpointCache.set(info.typeref, createdBreakpointId);
                }
            }
        });
    }
    clearSavedBreakpoints() {
        this.lineBreakpointCache.clear();
        this.exceptionBreakpointCache.clear();
    }
}
exports.BreakpointService = BreakpointService;
//# sourceMappingURL=breakpointService.js.map