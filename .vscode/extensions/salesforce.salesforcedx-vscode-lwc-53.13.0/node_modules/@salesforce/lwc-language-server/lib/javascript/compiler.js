"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("../constants");
const compiler_1 = require("@lwc/compiler");
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const comment_parser_1 = __importDefault(require("comment-parser"));
function getClassMembers(metadata, memberType, memberDecorator) {
    const members = [];
    if (metadata.classMembers) {
        for (const member of metadata.classMembers) {
            if (member.type === memberType) {
                if (!memberDecorator || member.decorator === memberDecorator) {
                    members.push(member);
                }
            }
        }
    }
    return members;
}
function getDecoratorsTargets(metadata, elementType, targetType) {
    const props = [];
    if (metadata.decorators) {
        for (const element of metadata.decorators) {
            if (element.type === elementType) {
                for (const target of element.targets) {
                    if (target.type === targetType) {
                        props.push(target);
                    }
                }
                break;
            }
        }
    }
    return props;
}
function getPublicReactiveProperties(metadata) {
    return getClassMembers(metadata, 'property', 'api');
}
exports.getPublicReactiveProperties = getPublicReactiveProperties;
function getPrivateReactiveProperties(metadata) {
    return getDecoratorsTargets(metadata, 'track', 'property');
}
exports.getPrivateReactiveProperties = getPrivateReactiveProperties;
function getApiMethods(metadata) {
    return getDecoratorsTargets(metadata, 'api', 'method');
}
exports.getApiMethods = getApiMethods;
function getProperties(metadata) {
    return getClassMembers(metadata, 'property');
}
exports.getProperties = getProperties;
function getMethods(metadata) {
    return getClassMembers(metadata, 'method');
}
exports.getMethods = getMethods;
function sanitizeComment(comment) {
    const parsed = comment_parser_1.default('/*' + comment + '*/');
    return parsed && parsed.length > 0 ? parsed[0].source : null;
}
function patchComments(metadata) {
    if (metadata.doc) {
        metadata.doc = sanitizeComment(metadata.doc);
        for (const classMember of metadata.classMembers) {
            if (classMember.doc) {
                classMember.doc = sanitizeComment(classMember.doc);
            }
        }
    }
}
function extractLocationFromBabelError(message) {
    const m = message.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
    const startLine = m.indexOf('\n> ') + 3;
    const line = parseInt(m.substring(startLine, m.indexOf(' | ', startLine)), 10);
    const startColumn = m.indexOf('    | ', startLine);
    const mark = m.indexOf('^', startColumn);
    const column = mark - startColumn - 6;
    const location = { line, column };
    return location;
}
exports.extractLocationFromBabelError = extractLocationFromBabelError;
function extractMessageFromBabelError(message) {
    const start = message.indexOf(': ') + 2;
    const end = message.indexOf('\n', start);
    return message.substring(start, end);
}
exports.extractMessageFromBabelError = extractMessageFromBabelError;
// TODO: proper type for 'err' (i.e. SyntaxError)
function toDiagnostic(err) {
    // TODO: 'err' doesn't have end loc, squiggling until the end of the line until babel 7 is released
    const message = err.message;
    let location = err.location;
    if (!location) {
        location = extractLocationFromBabelError(message);
    }
    const startLine = location.line - 1;
    const startCharacter = location.column;
    // https://github.com/forcedotcom/salesforcedx-vscode/issues/2074
    // Limit the end character to max 32 bit integer so that it doesn't overflow other language servers
    const range = vscode_languageserver_1.Range.create(startLine, startCharacter, startLine, constants_1.MAX_32BIT_INTEGER);
    return {
        range,
        severity: vscode_languageserver_1.DiagnosticSeverity.Error,
        source: constants_1.DIAGNOSTIC_SOURCE,
        message: extractMessageFromBabelError(message),
    };
}
async function compileSource(source, fileName = 'foo.js') {
    try {
        const name = fileName.substring(0, fileName.lastIndexOf('.'));
        const options = {
            name,
            namespace: 'x',
            files: {},
        };
        const transformerResult = await compiler_1.transform(source, fileName, options);
        const metadata = transformerResult.metadata;
        patchComments(metadata);
        return { metadata, diagnostics: [] };
    }
    catch (err) {
        return { diagnostics: [toDiagnostic(err)] };
    }
}
exports.compileSource = compileSource;
/**
 * Use to compile a live document (contents may be different from current file in disk)
 */
async function compileDocument(document) {
    const file = vscode_uri_1.URI.file(document.uri).fsPath;
    const filePath = path.parse(file);
    const fileName = filePath.base;
    return compileSource(document.getText(), fileName);
}
exports.compileDocument = compileDocument;
async function compileFile(file) {
    const filePath = path.parse(file);
    const fileName = filePath.base;
    const data = await fs.readFile(file, 'utf-8');
    return compileSource(data, fileName);
}
exports.compileFile = compileFile;
function toVSCodeRange(babelRange) {
    // babel (column:0-based line:1-based) => vscode (character:0-based line:0-based)
    return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(babelRange.start.line - 1, babelRange.start.column), vscode_languageserver_1.Position.create(babelRange.end.line - 1, babelRange.end.column));
}
exports.toVSCodeRange = toVSCodeRange;
function extractAttributes(metadata, uri) {
    const publicAttributes = [];
    const privateAttributes = [];
    for (const x of getProperties(metadata)) {
        if (x.decorator === 'api') {
            const location = vscode_languageserver_1.Location.create(uri, toVSCodeRange(x.loc));
            const name = x.name.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
            const memberType = x.type === 'property' ? lightning_lsp_common_1.MemberType.PROPERTY : lightning_lsp_common_1.MemberType.METHOD;
            publicAttributes.push(new lightning_lsp_common_1.AttributeInfo(name, x.doc, memberType, lightning_lsp_common_1.Decorator.API, undefined, location, 'LWC custom attribute'));
        }
        else {
            const location = vscode_languageserver_1.Location.create(uri, toVSCodeRange(x.loc));
            const name = x.name.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
            const memberType = x.type === 'property' ? lightning_lsp_common_1.MemberType.PROPERTY : lightning_lsp_common_1.MemberType.METHOD;
            const decorator = x.decorator === 'track' ? lightning_lsp_common_1.Decorator.TRACK : undefined;
            privateAttributes.push(new lightning_lsp_common_1.AttributeInfo(name, x.doc, memberType, decorator, undefined, location, 'LWC custom attribute'));
        }
    }
    return {
        publicAttributes,
        privateAttributes,
    };
}
exports.extractAttributes = extractAttributes;
//# sourceMappingURL=compiler.js.map