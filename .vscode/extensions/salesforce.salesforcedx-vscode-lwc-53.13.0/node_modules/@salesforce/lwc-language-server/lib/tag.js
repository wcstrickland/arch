"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("./javascript/compiler");
const fs = __importStar(require("fs-extra"));
const glob = __importStar(require("fast-glob"));
const camelcase_1 = __importDefault(require("camelcase"));
const change_case_1 = require("change-case");
const vscode_uri_1 = require("vscode-uri");
const path = __importStar(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
function attributeDoc(attribute) {
    const { name, type, documentation } = attribute;
    if (name && type && documentation) {
        return `- **${name}**: *${type}* ${documentation}`;
    }
    if (name && type) {
        return `- **${name}**: *${type}*`;
    }
    if (name) {
        return `- **${name}**`;
    }
    return '';
}
function methodDoc(method) {
    const { name, doc } = method;
    if (name && doc) {
        return `- **${name}()** *: ${doc}`;
    }
    if (name) {
        return `- **${name}()**`;
    }
    return '';
}
class Tag {
    constructor(attributes) {
        this._allAttributes = null;
        this._properties = null;
        this._methods = null;
        this.file = attributes.file;
        this.metadata = attributes.metadata;
        if (attributes.updatedAt) {
            this.updatedAt = new Date(attributes.updatedAt);
        }
        else if (this.file) {
            const data = fs.statSync(this.file);
            this.updatedAt = data.mtime;
        }
    }
    get description() {
        const docs = [this.documentation, this.attributeDocs, this.methodDocs];
        return docs.filter(item => item !== null).join('\n');
    }
    get name() {
        return path.parse(this.file).name;
    }
    get auraName() {
        return 'c:' + camelcase_1.default(this.name);
    }
    get lwcName() {
        if (this.name.includes('_')) {
            return 'c-' + this.name;
        }
        else {
            return 'c-' + change_case_1.paramCase(this.name);
        }
    }
    get lwcTypingsName() {
        return 'c/' + this.name;
    }
    get attributes() {
        return this.publicAttributes;
    }
    attribute(name) {
        return this.attributes.find(attr => attr.name === name) || null;
    }
    get documentation() {
        return this.metadata.doc;
    }
    get attributeDocs() {
        if (this.publicAttributes.length === 0) {
            return null;
        }
        return ['### Attributes', ...this.publicAttributes.map(attributeDoc)].join('\n');
    }
    get classMembers() {
        return this.metadata.classMembers;
    }
    classMember(name) {
        return this.classMembers.find(item => item.name === name) || null;
    }
    classMemberLocation(name) {
        var _a;
        const classMember = this.classMember(name);
        if (!classMember) {
            return null;
        }
        return vscode_languageserver_1.Location.create(this.uri, compiler_1.toVSCodeRange((_a = classMember) === null || _a === void 0 ? void 0 : _a.loc));
    }
    get methodDocs() {
        if (this.apiMethods.length === 0) {
            return null;
        }
        return ['### Methods', ...this.apiMethods.map(methodDoc)].join('\n');
    }
    get uri() {
        return vscode_uri_1.URI.file(path.resolve(this.file)).toString();
    }
    get allAttributes() {
        if (this._allAttributes) {
            return this._allAttributes;
        }
        this._allAttributes = compiler_1.extractAttributes(this.metadata, this.uri);
        return this._allAttributes;
    }
    get publicAttributes() {
        return this.allAttributes.publicAttributes;
    }
    get privateAttributes() {
        return this.allAttributes.privateAttributes;
    }
    get properties() {
        if (this._properties) {
            return this._properties;
        }
        this._properties = compiler_1.getProperties(this.metadata);
        return this._properties;
    }
    get methods() {
        if (this._methods) {
            return this._methods;
        }
        this._methods = compiler_1.getMethods(this.metadata);
        return this._methods;
    }
    get apiMethods() {
        return this.methods.filter(method => method.decorator === 'api');
    }
    get range() {
        if (this.metadata.declarationLoc) {
            return compiler_1.toVSCodeRange(this.metadata.declarationLoc);
        }
        else {
            return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), vscode_languageserver_1.Position.create(0, 0));
        }
    }
    get location() {
        return vscode_languageserver_1.Location.create(this.uri, this.range);
    }
    get allLocations() {
        const { dir, name } = path.parse(this.file);
        const convertFileToLocation = (file) => {
            const uri = vscode_uri_1.URI.file(path.resolve(file)).toString();
            const position = vscode_languageserver_1.Position.create(0, 0);
            const range = vscode_languageserver_1.Range.create(position, position);
            return vscode_languageserver_1.Location.create(uri, range);
        };
        const filteredFiles = glob.sync(`${dir}/${name}.+(html|css)`);
        const locations = filteredFiles.map(convertFileToLocation);
        locations.unshift(this.location);
        return locations;
    }
    updateMetadata(meta) {
        this.metadata = meta;
        this._allAttributes = null;
        this._methods = null;
        this._properties = null;
        const data = fs.statSync(this.file);
        this.updatedAt = data.mtime;
    }
    static async fromFile(file, updatedAt) {
        if (file === '' || file.length === 0) {
            return null;
        }
        const filePath = path.parse(file);
        const fileName = filePath.base;
        const data = await fs.readFile(file, 'utf-8');
        if (!(data.includes(`from "lwc"`) || data.includes(`from 'lwc'`))) {
            return null;
        }
        const { metadata, diagnostics } = await compiler_1.compileSource(data, fileName);
        if (diagnostics.length > 0) {
            console.log(`Could not create Tag from ${file}.\n${diagnostics}`);
            return null;
        }
        return new Tag({ file, metadata, updatedAt });
    }
}
exports.default = Tag;
//# sourceMappingURL=tag.js.map