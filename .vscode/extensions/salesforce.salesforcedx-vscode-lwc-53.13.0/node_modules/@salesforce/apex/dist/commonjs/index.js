"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const apexServices = {
    refreshApex: () => {
        return Promise.reject('not implemented');
    },
    getSObjectValue: () => {
        throw new Error('not implemented');
    }
};
const PREFIX_BARE = '@salesforce/apex';
const PREFIX = '@salesforce/apex/';
const PREFIX_LENGTH = PREFIX.length;
/**
 * Module resolver for @salesforce/apex/* that provides access to force.com Apex.
 *
 * The supported module identifiers are dependent on org metadata:
 * 1. Service capabilities, like refresh: @salesforce/apex
 * 2. Wire adapter and imperative function of an Apex method in namespace: @salesforce/apex/[namespace].[ClassName].[methodName]
 * 3. Wire adapter and imperative function of an Apex method in default ('c') namespace: @salesforce/apex/[ClassName].[methodName]
 *
 * @param resource The module identifier. Eg "@salesforce/apex/ClassName.methodName".
 * @param resource The resource name; that is, the value after "@salesforce/apex/".
 * @returns The value of the requested resource.
 */
function apexResolver(resource) {
    // handle import { ... } from '@salesforce/apex';
    if (resource === PREFIX_BARE) {
        return apexServices;
    }
    if (!resource.startsWith(PREFIX) || resource.length <= PREFIX_LENGTH) {
        return undefined;
    }
    resource = resource.substring(PREFIX_LENGTH);
    // handle namespace and default namespace import of Apex method
    const parts = resource.split('.');
    const method = parts.pop();
    const classname = parts.pop();
    const namespace = parts.pop() || '';
    return () => {
        return Promise.reject(`not implemented: ${namespace}.${classname}.${method}`);
    };
}
exports.default = apexResolver;
//# sourceMappingURL=index.js.map