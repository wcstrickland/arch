/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const htmlScanner_1 = require("../parser/htmlScanner");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const tagProviders_1 = require("./tagProviders");
const htmlLanguageTypes_1 = require("../htmlLanguageTypes");
function doHover(document, position, htmlDocument) {
    let offset = document.offsetAt(position);
    let node = htmlDocument.findNodeAt(offset);
    if (!node || !node.tag) {
        return null;
    }
    let tagProviders = tagProviders_1.getTagProviders().filter(p => p.isApplicable(document.languageId));
    function getTagHover(tag, range, open) {
        // **** CHANGES TO HTML LANGUAGE SERVICE HERE **** //
        //tag = tag.toLowerCase();
        for (let provider of tagProviders) {
            let hover = null;
            const tagInfo = provider.getTagInfo(tag);
            if (tagInfo) {
                const doc = tagInfo.getHover();
                const tagLabel = open ? '<' + tag + '>' : '</' + tag + '>';
                const markdown = ['```html', tagLabel, '```', doc];
                return { contents: { kind: vscode_languageserver_types_1.MarkupKind.Markdown, value: markdown.join('\n') }, range };
            }
        }
        return null;
    }
    function getAttributeHover(tag, name, range) {
        tag = tag.toLowerCase();
        for (const provider of tagProviders) {
            const tagInfo = provider.getTagInfo(tag);
            if (tagInfo) {
                const attrInfo = tagInfo.getAttributeInfo(name);
                if (attrInfo) {
                    const markdown = ['**' + name + '**', '', attrInfo.documentation || ''];
                    return { contents: { kind: vscode_languageserver_types_1.MarkupKind.Markdown, value: markdown.join('\n') }, range };
                }
            }
            // If we don't match on tags / attributes, see if we match any directives
            const directiveInfo = getAttributeInfo(name, provider.getGlobalAttributes());
            if (directiveInfo) {
                const markdown = ['**' + name + '**', '', directiveInfo.documentation];
                return { contents: { kind: vscode_languageserver_types_1.MarkupKind.Markdown, value: markdown.join('\n') }, range };
            }
        }
        return null;
    }
    // Ugh, dumb
    function getAttributeInfo(label, globalAttributes) {
        for (const info of globalAttributes) {
            if (label === info.name) {
                return info;
            }
        }
        return null;
    }
    function getTagNameRange(tokenType, startOffset) {
        let scanner = htmlScanner_1.createScanner(document.getText(), startOffset);
        let token = scanner.scan();
        while (token !== htmlLanguageTypes_1.TokenType.EOS && (scanner.getTokenEnd() < offset || (scanner.getTokenEnd() === offset && token !== tokenType))) {
            token = scanner.scan();
        }
        if (token === tokenType && offset <= scanner.getTokenEnd()) {
            return { start: document.positionAt(scanner.getTokenOffset()), end: document.positionAt(scanner.getTokenEnd()) };
        }
        return null;
    }
    if (node.endTagStart && offset >= node.endTagStart) {
        let tagRange = getTagNameRange(htmlLanguageTypes_1.TokenType.EndTag, node.endTagStart);
        if (tagRange) {
            return getTagHover(node.tag, tagRange, false);
        }
        return null;
    }
    let tagRange = getTagNameRange(htmlLanguageTypes_1.TokenType.StartTag, node.start);
    if (tagRange) {
        return getTagHover(node.tag, tagRange, true);
    }
    const attributeRange = getTagNameRange(htmlLanguageTypes_1.TokenType.AttributeName, node.start);
    if (attributeRange) {
        return getAttributeHover(node.tag, document.getText(attributeRange), attributeRange);
    }
    return null;
}
exports.doHover = doHover;
//# sourceMappingURL=htmlHover.js.map