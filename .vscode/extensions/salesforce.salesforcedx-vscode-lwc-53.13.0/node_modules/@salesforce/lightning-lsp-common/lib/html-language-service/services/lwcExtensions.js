'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const htmlScanner_1 = require("../parser/htmlScanner");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const htmlLanguageTypes_1 = require("../htmlLanguageTypes");
const utils_1 = require("./utils");
const TOP_OF_FILE = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), vscode_languageserver_types_1.Position.create(0, 0));
function getIteratorNameRange(document, attributeName, startOffset, endOffset) {
    const scanner = htmlScanner_1.createScanner(document.getText(), startOffset);
    let token = scanner.scan();
    while (token !== htmlLanguageTypes_1.TokenType.EOS && scanner.getTokenEnd() < endOffset) {
        if (token === htmlLanguageTypes_1.TokenType.AttributeName) {
            const range = {
                start: document.positionAt(scanner.getTokenOffset()),
                end: document.positionAt(scanner.getTokenEnd()),
            };
            const curAttributeName = document.getText(range);
            if (curAttributeName === attributeName) {
                // we have a name range, lets adjust it to be after the 'iterator:' part
                range.start.character = range.start.character + 'iterator:'.length;
                return range;
            }
        }
        token = scanner.scan();
        if (token === htmlLanguageTypes_1.TokenType.StartTagClose || token == htmlLanguageTypes_1.TokenType.StartTagSelfClose) {
            break;
        }
    }
    return null;
}
function findLWCDeclaration(document, attributeValue, node) {
    let cur = node;
    while (cur.parent != null) {
        const item = utils_1.stripQuotes((cur.attributes && cur.attributes['for:item']) || '');
        if (item === attributeValue) {
            // matched to for:each definition
            const range = utils_1.getAttributeRange(document, 'for:item', cur.start, cur.end);
            if (range) {
                return {
                    uri: document.uri,
                    range,
                };
            }
        }
        // try iterator: tag
        const attributeName = cur.attributeNames.find(a => a.startsWith('iterator:'));
        if (attributeName) {
            const split = attributeName.split(':');
            if (split.length == 2 && split[1] === attributeValue) {
                const range = getIteratorNameRange(document, attributeName, cur.start, cur.end);
                if (range) {
                    return {
                        uri: document.uri,
                        range,
                    };
                }
            }
        }
        cur = cur.parent;
    }
    return null;
}
/**
 * Looks for property bindings {PROPERTY.something} within attribute values, or body content, and returns a location
 * within the same template that corresponds to iterator:PROPERTY or for:item="PROPERTY".
 */
function getPropertyBindingTemplateDeclaration(document, position, htmlDocument) {
    const offset = document.offsetAt(position);
    const node = htmlDocument.findNodeAt(offset);
    if (!node || !node.tag) {
        return null;
    }
    let propertyValue = getPropertyBindingValue(document, position, htmlDocument);
    if (propertyValue) {
        return findLWCDeclaration(document, propertyValue, node);
    }
    return null;
}
exports.getPropertyBindingTemplateDeclaration = getPropertyBindingTemplateDeclaration;
/**
 * Parses attribute value or body text content looking for the active {PROPERTY.something} reference corresponding
 * to the position. It will only return the leading property name. i.e. PROPERTY
 */
function getPropertyBindingValue(document, position, htmlDocument) {
    const offset = document.offsetAt(position);
    const node = htmlDocument.findNodeAt(offset);
    if (!node || !node.tag) {
        return null;
    }
    // first look through attribute values
    const attributeRange = utils_1.getTagNameRange(document, offset, htmlLanguageTypes_1.TokenType.AttributeValue, node.start);
    if (attributeRange) {
        const value = document.getText(attributeRange);
        const valueRelativeOffset = offset - document.offsetAt(attributeRange.start);
        const dotIndex = value.indexOf('.');
        // make sure our position is BEFORE the first dot before matching...
        if (dotIndex != -1 && valueRelativeOffset >= dotIndex) {
            // we're after the first dot, bail
            return null;
        }
        const valueTrimmed = value.trim();
        const valuePattern = /{(\w*)(?:\.(.*?))?}/g;
        const match = valuePattern.exec(valueTrimmed);
        if (match) {
            const property = match[1];
            return property;
        }
    }
    // try looking through body text...
    if (!attributeRange) {
        const scanner = htmlScanner_1.createScanner(document.getText(), node.start);
        let token = scanner.scan();
        while (token !== htmlLanguageTypes_1.TokenType.EOS && scanner.getTokenEnd() <= node.end) {
            if (token === htmlLanguageTypes_1.TokenType.Content) {
                const range = {
                    start: document.positionAt(scanner.getTokenOffset()),
                    end: document.positionAt(scanner.getTokenEnd()),
                };
                const curContent = document.getText(range);
                const relativeOffset = offset - scanner.getTokenOffset();
                var match;
                const valuePattern = /{(\w*)(?:\.(.*?))?}/g;
                while ((match = valuePattern.exec(curContent))) {
                    const start = valuePattern.lastIndex - match[0].length;
                    const end = valuePattern.lastIndex - 1;
                    if (start <= relativeOffset && relativeOffset <= end) {
                        // this just gives us the match within the full regular expression match
                        // we want to make sure we're only on the left most property.
                        const dotIndex = curContent.indexOf('.', start);
                        if (dotIndex == -1 || relativeOffset < dotIndex) {
                            return match[1];
                        }
                    }
                }
            }
            token = scanner.scan();
        }
    }
    return null;
}
exports.getPropertyBindingValue = getPropertyBindingValue;
//# sourceMappingURL=lwcExtensions.js.map