"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = exports.getASTfor = exports.UNSUPPORTED_TEST_NAME = exports.UNRESOLVED_FUNCTION_NAME = void 0;

var _fs = require("fs");

var _types = require("@babel/types");

var parser = _interopRequireWildcard(require("@babel/parser"));

var _parser_nodes = require("./parser_nodes");

var _helper = require("./helper");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var UNRESOLVED_FUNCTION_NAME = '__function__';
exports.UNRESOLVED_FUNCTION_NAME = UNRESOLVED_FUNCTION_NAME;
var UNSUPPORTED_TEST_NAME = '__unsupported__';
exports.UNSUPPORTED_TEST_NAME = UNSUPPORTED_TEST_NAME;

var _getASTfor = function _getASTfor(file, data, options) {
  var _data = data || (0, _fs.readFileSync)(file).toString();

  var config = _objectSpread(_objectSpread({}, options), {}, {
    sourceType: 'module'
  });

  return [parser.parse(_data, config), _data];
};

var getASTfor = function getASTfor(file, data) {
  var _getASTfor2 = _getASTfor(file, data, (0, _helper.parseOptions)(file)),
      _getASTfor3 = _slicedToArray(_getASTfor2, 1),
      bFile = _getASTfor3[0];

  return bFile;
};

exports.getASTfor = getASTfor;

var parse = function parse(file, data, options) {
  var parseResult = new _parser_nodes.ParseResult(file);

  var _getASTfor4 = _getASTfor(file, data, options),
      _getASTfor5 = _slicedToArray(_getASTfor4, 2),
      ast = _getASTfor5[0],
      _data = _getASTfor5[1];

  var deepGet = function deepGet(node) {
    for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      types[_key - 1] = arguments[_key];
    }

    return types.reduce(function (rootForType, type) {
      while (rootForType[type]) {
        rootForType = rootForType[type];
      }

      return rootForType;
    }, node);
  };

  var updateNameInfo = function updateNameInfo(nBlock, bNode) {
    var arg = bNode.expression.arguments[0];
    var name = arg.value;

    if (!name) {
      switch (arg.type) {
        case 'TemplateLiteral':
          name = _data.substring(arg.start + 1, arg.end - 1);
          break;

        case 'CallExpression':
          // a dynamic function: use a placeholder
          name = UNRESOLVED_FUNCTION_NAME;
          break;

        default:
          // eslint-disable-next-line no-console
          console.warn("failed to extract name for type \"".concat(arg.type, "\" in node:"), bNode);
          name = UNSUPPORTED_TEST_NAME;
          break;
      }
    }

    nBlock.name = name;
    nBlock.nameRange = new _parser_nodes.ParsedRange(arg.loc.start.line, arg.loc.start.column + 2, arg.loc.end.line, arg.loc.end.column - 1);
  };

  var updateNode = function updateNode(node, babylonNode) {
    node.start = babylonNode.loc.start;
    node.end = babylonNode.loc.end;
    node.start.column += 1;
    parseResult.addNode(node);

    if (node instanceof _parser_nodes.NamedBlock) {
      updateNameInfo(node, babylonNode);
    }
  };

  var isFunctionCall = function isFunctionCall(node) {
    return node && node.type === 'ExpressionStatement' && node.expression && node.expression.type === 'CallExpression';
  };

  var isFunctionDeclaration = function isFunctionDeclaration(nodeType) {
    return nodeType === 'ArrowFunctionExpression' || nodeType === 'FunctionExpression';
  }; // Pull out the name of a CallExpression (describe/it)


  var getNameForNode = function getNameForNode(node) {
    if (isFunctionCall(node) && node.expression.callee) {
      // Get root callee in case it's a chain of higher-order functions (e.g. .each(table)(name, fn))
      var rootCallee = deepGet(node.expression, 'callee');
      var name = rootCallee.name || // handle cases where it's a member expression (e.g .only or .concurrent.only)
      deepGet(rootCallee, 'object').name || // handle cases where it's part of a tag (e.g. .each`table`)
      deepGet(rootCallee, 'tag', 'object').name;
      return name;
    }

    return undefined;
  }; // When given a node in the AST, does this represent
  // the start of an it/test block?


  var isAnIt = function isAnIt(node) {
    var name = getNameForNode(node);
    return name === 'it' || name === 'fit' || name === 'test';
  };

  var isAnDescribe = function isAnDescribe(node) {
    var name = getNameForNode(node);
    return name === 'describe';
  }; // When given a node in the AST, does this represent
  // the start of an expect expression?


  var isAnExpect = function isAnExpect(node) {
    if (!isFunctionCall(node)) {
      return false;
    }

    var name = '';
    var element = node && node.expression ? node.expression.callee : undefined;

    while (!name && element) {
      // eslint-disable-next-line prefer-destructuring
      name = element.name; // Because expect may have accessors tacked on (.to.be) or nothing
      // (expect()) we have to check multiple levels for the name

      element = element.object || element.callee;
    }

    return name === 'expect';
  };

  var addNode = function addNode(type, parent, babylonNode) {
    var child = parent.addChild(type);
    updateNode(child, babylonNode);

    if (child instanceof _parser_nodes.NamedBlock && child.name == null) {
      // eslint-disable-next-line no-console
      console.warn("block is missing name: ".concat(JSON.stringify(babylonNode)));
    }

    return child;
  }; // A recursive AST parser


  var searchNodes = function searchNodes(babylonParent, parent) {
    // Look through the node's children
    var child;

    if (!babylonParent.body || !Array.isArray(babylonParent.body)) {
      return;
    }

    babylonParent.body.forEach(function (element) {
      var _element$argument;

      child = undefined; // Pull out the node
      // const element = babylonParent.body[node];

      if (isAnDescribe(element)) {
        child = addNode('describe', parent, element);
      } else if (isAnIt(element)) {
        child = addNode('it', parent, element);
      } else if (isAnExpect(element)) {
        child = addNode('expect', parent, element);
      } else if (element && element.type === 'VariableDeclaration') {
        element.declarations.filter(function (declaration) {
          return declaration.init && isFunctionDeclaration(declaration.init.type);
        }).forEach(function (declaration) {
          return searchNodes(declaration.init.body, parent);
        });
      } else if (element && element.type === 'ExpressionStatement' && element.expression && element.expression.type === 'AssignmentExpression' && element.expression.right && isFunctionDeclaration(element.expression.right.type)) {
        searchNodes(element.expression.right.body, parent);
      } else if (element.type === 'ReturnStatement' && ((_element$argument = element.argument) === null || _element$argument === void 0 ? void 0 : _element$argument.arguments)) {
        element.argument.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, parent);
        });
      }

      if (isFunctionCall(element)) {
        element.expression.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, child || parent);
        });
      }
    });
  };

  var program = ast.program;
  searchNodes(program, parseResult.root);
  return parseResult;
};

exports.parse = parse;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL2JhYmVsX3BhcnNlci5qcyJdLCJuYW1lcyI6WyJVTlJFU09MVkVEX0ZVTkNUSU9OX05BTUUiLCJVTlNVUFBPUlRFRF9URVNUX05BTUUiLCJfZ2V0QVNUZm9yIiwiZmlsZSIsImRhdGEiLCJvcHRpb25zIiwiX2RhdGEiLCJ0b1N0cmluZyIsImNvbmZpZyIsInNvdXJjZVR5cGUiLCJwYXJzZXIiLCJwYXJzZSIsImdldEFTVGZvciIsImJGaWxlIiwicGFyc2VSZXN1bHQiLCJQYXJzZVJlc3VsdCIsImFzdCIsImRlZXBHZXQiLCJub2RlIiwidHlwZXMiLCJyZWR1Y2UiLCJyb290Rm9yVHlwZSIsInR5cGUiLCJ1cGRhdGVOYW1lSW5mbyIsIm5CbG9jayIsImJOb2RlIiwiYXJnIiwiZXhwcmVzc2lvbiIsImFyZ3VtZW50cyIsIm5hbWUiLCJ2YWx1ZSIsInN1YnN0cmluZyIsInN0YXJ0IiwiZW5kIiwiY29uc29sZSIsIndhcm4iLCJuYW1lUmFuZ2UiLCJQYXJzZWRSYW5nZSIsImxvYyIsImxpbmUiLCJjb2x1bW4iLCJ1cGRhdGVOb2RlIiwiYmFieWxvbk5vZGUiLCJhZGROb2RlIiwiTmFtZWRCbG9jayIsImlzRnVuY3Rpb25DYWxsIiwiaXNGdW5jdGlvbkRlY2xhcmF0aW9uIiwibm9kZVR5cGUiLCJnZXROYW1lRm9yTm9kZSIsImNhbGxlZSIsInJvb3RDYWxsZWUiLCJ1bmRlZmluZWQiLCJpc0FuSXQiLCJpc0FuRGVzY3JpYmUiLCJpc0FuRXhwZWN0IiwiZWxlbWVudCIsIm9iamVjdCIsInBhcmVudCIsImNoaWxkIiwiYWRkQ2hpbGQiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VhcmNoTm9kZXMiLCJiYWJ5bG9uUGFyZW50IiwiYm9keSIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJkZWNsYXJhdGlvbnMiLCJmaWx0ZXIiLCJkZWNsYXJhdGlvbiIsImluaXQiLCJyaWdodCIsImFyZ3VtZW50IiwicHJvZ3JhbSIsInJvb3QiXSwi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b0NELEdBNUNEOztBQXRIaUcsTUFvSzFGaUIsT0FwSzBGLEdBb0svRTFELEdBcEsrRSxDQW9LMUYwRCxPQXBLMEY7QUFxS2pHWixFQUFBQSxXQUFXLENBQUNZLE9BQUQsRUFBVTVELFdBQVcsQ0FBQzZELElBQXRCLENBQVg7QUFFQSxTQUFPN0QsV0FBUDtBQUNELENBeEtNIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtyZWFkRmlsZVN5bmN9IGZyb20gJ2ZzJztcbmltcG9ydCB7RmlsZSBhcyBCYWJlbEZpbGUsIE5vZGUgYXMgQmFiZWxOb2RlfSBmcm9tICdAYmFiZWwvdHlwZXMnO1xuaW1wb3J0ICogYXMgcGFyc2VyIGZyb20gJ0BiYWJlbC9wYXJzZXInO1xuaW1wb3J0IHR5cGUge1BhcnNlZE5vZGVUeXBlfSBmcm9tICcuL3BhcnNlcl9ub2Rlcyc7XG5pbXBvcnQge05hbWVkQmxvY2ssIFBhcnNlZFJhbmdlLCBQYXJzZVJlc3VsdCwgUGFyc2VkTm9kZX0gZnJvbSAnLi9wYXJzZXJfbm9kZXMnO1xuaW1wb3J0IHtwYXJzZU9wdGlvbnN9IGZyb20gJy4vaGVscGVyJztcblxuZXhwb3J0IGNvbnN0IFVOUkVTT0xWRURfRlVOQ1RJT05fTkFNRSA9ICdfX2Z1bmN0aW9uX18nO1xuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1RFU1RfTkFNRSA9ICdfX3Vuc3VwcG9ydGVkX18nO1xuXG5jb25zdCBfZ2V0QVNUZm9yID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZywgb3B0aW9uczogP3BhcnNlci5QYXJzZXJPcHRpb25zKTogW0JhYmVsRmlsZSwgc3RyaW5nXSA9PiB7XG4gIGNvbnN0IF9kYXRhID0gZGF0YSB8fCByZWFkRmlsZVN5bmMoZmlsZSkudG9TdHJpbmcoKTtcbiAgY29uc3QgY29uZmlnID0gey4uLm9wdGlvbnMsIHNvdXJjZVR5cGU6ICdtb2R1bGUnfTtcbiAgcmV0dXJuIFtwYXJzZXIucGFyc2UoX2RhdGEsIGNvbmZpZyksIF9kYXRhXTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBU1Rmb3IgPSAoZmlsZTogc3RyaW5nLCBkYXRhOiA/c3RyaW5nKTogQmFiZWxGaWxlID0+IHtcbiAgY29uc3QgW2JGaWxlXSA9IF9nZXRBU1Rmb3IoZmlsZSwgZGF0YSwgcGFyc2VPcHRpb25zKGZpbGUpKTtcbiAgcmV0dXJuIGJGaWxlO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZywgb3B0aW9uczogP3BhcnNlci5QYXJzZXJPcHRpb25zKTogUGFyc2VSZXN1bHQgPT4ge1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IG5ldyBQYXJzZVJlc3VsdChmaWxlKTtcbiAgY29uc3QgW2FzdCwgX2RhdGFdID0gX2dldEFTVGZvcihmaWxlLCBkYXRhLCBvcHRpb25zKTtcblxuICBjb25zdCBkZWVwR2V0ID0gKG5vZGUsIC4uLnR5cGVzOiBzdHJpbmdbXSkgPT5cbiAgICB0eXBlcy5yZWR1Y2U8QmFiZWxOb2RlPigocm9vdEZvclR5cGUsIHR5cGUpID0+IHtcbiAgICAgIHdoaWxlIChyb290Rm9yVHlwZVt0eXBlXSkge1xuICAgICAgICByb290Rm9yVHlwZSA9IHJvb3RGb3JUeXBlW3R5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3RGb3JUeXBlO1xuICAgIH0sIG5vZGUpO1xuXG4gIGNvbnN0IHVwZGF0ZU5hbWVJbmZvID0gKG5CbG9jazogTmFtZWRCbG9jaywgYk5vZGU6IEJhYmVsTm9kZSkgPT4ge1xuICAgIGNvbnN0IGFyZyA9IGJOb2RlLmV4cHJlc3Npb24uYXJndW1lbnRzWzBdO1xuICAgIGxldCBuYW1lID0gYXJnLnZhbHVlO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBzd2l0Y2ggKGFyZy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1RlbXBsYXRlTGl0ZXJhbCc6XG4gICAgICAgICAgbmFtZSA9IF9kYXRhLnN1YnN0cmluZyhhcmcuc3RhcnQgKyAxLCBhcmcuZW5kIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICAvLyBhIGR5bmFtaWMgZnVuY3Rpb246IHVzZSBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgbmFtZSA9IFVOUkVTT0xWRURfRlVOQ1RJT05fTkFNRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybihgZmFpbGVkIHRvIGV4dHJhY3QgbmFtZSBmb3IgdHlwZSBcIiR7YXJnLnR5cGV9XCIgaW4gbm9kZTpgLCBiTm9kZSk7XG4gICAgICAgICAgbmFtZSA9IFVOU1VQUE9SVEVEX1RFU1RfTkFNRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuQmxvY2submFtZSA9IG5hbWU7XG4gICAgbkJsb2NrLm5hbWVSYW5nZSA9IG5ldyBQYXJzZWRSYW5nZShcbiAgICAgIGFyZy5sb2Muc3RhcnQubGluZSxcbiAgICAgIGFyZy5sb2Muc3RhcnQuY29sdW1uICsgMixcbiAgICAgIGFyZy5sb2MuZW5kLmxpbmUsXG4gICAgICBhcmcubG9jLmVuZC5jb2x1bW4gLSAxXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB1cGRhdGVOb2RlID0gKG5vZGU6IFBhcnNlZE5vZGUsIGJhYnlsb25Ob2RlOiBCYWJlbE5vZGUpID0+IHtcbiAgICBub2RlLnN0YXJ0ID0gYmFieWxvbk5vZGUubG9jLnN0YXJ0O1xuICAgIG5vZGUuZW5kID0gYmFieWxvbk5vZGUubG9jLmVuZDtcbiAgICBub2RlLnN0YXJ0LmNvbHVtbiArPSAxO1xuXG4gICAgcGFyc2VSZXN1bHQuYWRkTm9kZShub2RlKTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE5hbWVkQmxvY2spIHtcbiAgICAgIHVwZGF0ZU5hbWVJbmZvKG5vZGUsIGJhYnlsb25Ob2RlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaXNGdW5jdGlvbkNhbGwgPSBub2RlID0+XG4gICAgbm9kZSAmJiBub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJiBub2RlLmV4cHJlc3Npb24gJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbic7XG5cbiAgY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uID0gKG5vZGVUeXBlOiBzdHJpbmcpID0+XG4gICAgbm9kZVR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgfHwgbm9kZVR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nO1xuXG4gIC8vIFB1bGwgb3V0IHRoZSBuYW1lIG9mIGEgQ2FsbEV4cHJlc3Npb24gKGRlc2NyaWJlL2l0KVxuICBjb25zdCBnZXROYW1lRm9yTm9kZSA9IG5vZGUgPT4ge1xuICAgIGlmIChpc0Z1bmN0aW9uQ2FsbChub2RlKSAmJiBub2RlLmV4cHJlc3Npb24uY2FsbGVlKSB7XG4gICAgICAvLyBHZXQgcm9vdCBjYWxsZWUgaW4gY2FzZSBpdCdzIGEgY2hhaW4gb2YgaGlnaGVyLW9yZGVyIGZ1bmN0aW9ucyAoZS5nLiAuZWFjaCh0YWJsZSkobmFtZSwgZm4pKVxuICAgICAgY29uc3Qgcm9vdENhbGxlZSA9IGRlZXBHZXQobm9kZS5leHByZXNzaW9uLCAnY2FsbGVlJyk7XG4gICAgICBjb25zdCBuYW1lID1cbiAgICAgICAgcm9vdENhbGxlZS5uYW1lIHx8XG4gICAgICAgIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBpdCdzIGEgbWVtYmVyIGV4cHJlc3Npb24gKGUuZyAub25seSBvciAuY29uY3VycmVudC5vbmx5KVxuICAgICAgICBkZWVwR2V0KHJvb3RDYWxsZWUsICdvYmplY3QnKS5uYW1lIHx8XG4gICAgICAgIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBpdCdzIHBhcnQgb2YgYSB0YWcgKGUuZy4gLmVhY2hgdGFibGVgKVxuICAgICAgICBkZWVwR2V0KHJvb3RDYWxsZWUsICd0YWcnLCAnb2JqZWN0JykubmFtZTtcblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gV2hlbiBnaXZlbiBhIG5vZGUgaW4gdGhlIEFTVCwgZG9lcyB0aGlzIHJlcHJlc2VudFxuICAvLyB0aGUgc3RhcnQgb2YgYW4gaXQvdGVzdCBibG9jaz9cbiAgY29uc3QgaXNBbkl0ID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGdldE5hbWVGb3JOb2RlKG5vZGUpO1xuICAgIHJldHVybiBuYW1lID09PSAnaXQnIHx8IG5hbWUgPT09ICdmaXQnIHx8IG5hbWUgPT09ICd0ZXN0JztcbiAgfTtcblxuICBjb25zdCBpc0FuRGVzY3JpYmUgPSBub2RlID0+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0TmFtZUZvck5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdkZXNjcmliZSc7XG4gIH07XG5cbiAgLy8gV2hlbiBnaXZlbiBhIG5vZGUgaW4gdGhlIEFTVCwgZG9lcyB0aGlzIHJlcHJlc2VudFxuICAvLyB0aGUgc3RhcnQgb2YgYW4gZXhwZWN0IGV4cHJlc3Npb24/XG4gIGNvbnN0IGlzQW5FeHBlY3QgPSBub2RlID0+IHtcbiAgICBpZiAoIWlzRnVuY3Rpb25DYWxsKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuYW1lID0gJyc7XG4gICAgbGV0IGVsZW1lbnQgPSBub2RlICYmIG5vZGUuZXhwcmVzc2lvbiA/IG5vZGUuZXhwcmVzc2lvbi5jYWxsZWUgOiB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKCFuYW1lICYmIGVsZW1lbnQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgbmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgIC8vIEJlY2F1c2UgZXhwZWN0IG1heSBoYXZlIGFjY2Vzc29ycyB0YWNrZWQgb24gKC50by5iZSkgb3Igbm90aGluZ1xuICAgICAgLy8gKGV4cGVjdCgpKSB3ZSBoYXZlIHRvIGNoZWNrIG11bHRpcGxlIGxldmVscyBmb3IgdGhlIG5hbWVcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9iamVjdCB8fCBlbGVtZW50LmNhbGxlZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgPT09ICdleHBlY3QnO1xuICB9O1xuXG4gIGNvbnN0IGFkZE5vZGUgPSAodHlwZTogUGFyc2VkTm9kZVR5cGUsIHBhcmVudDogUGFyc2VkTm9kZSwgYmFieWxvbk5vZGU6IEJhYmVsTm9kZSk6IFBhcnNlZE5vZGUgPT4ge1xuICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmFkZENoaWxkKHR5cGUpO1xuICAgIHVwZGF0ZU5vZGUoY2hpbGQsIGJhYnlsb25Ob2RlKTtcblxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVkQmxvY2sgJiYgY2hpbGQubmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKGBibG9jayBpcyBtaXNzaW5nIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkoYmFieWxvbk5vZGUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gQSByZWN1cnNpdmUgQVNUIHBhcnNlclxuICBjb25zdCBzZWFyY2hOb2RlcyA9IChiYWJ5bG9uUGFyZW50OiBCYWJlbE5vZGUsIHBhcmVudDogUGFyc2VkTm9kZSkgPT4ge1xuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgbGV0IGNoaWxkOiA/UGFyc2VkTm9kZTtcblxuICAgIGlmICghYmFieWxvblBhcmVudC5ib2R5IHx8ICFBcnJheS5pc0FycmF5KGJhYnlsb25QYXJlbnQuYm9keSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBiYWJ5bG9uUGFyZW50LmJvZHkuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgLy8gUHVsbCBvdXQgdGhlIG5vZGVcbiAgICAgIC8vIGNvbnN0IGVsZW1lbnQgPSBiYWJ5bG9uUGFyZW50LmJvZHlbbm9kZV07XG5cbiAgICAgIGlmIChpc0FuRGVzY3JpYmUoZWxlbWVudCkpIHtcbiAgICAgICAgY2hpbGQgPSBhZGROb2RlKCdkZXNjcmliZScsIHBhcmVudCwgZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQW5JdChlbGVtZW50KSkge1xuICAgICAgICBjaGlsZCA9IGFkZE5vZGUoJ2l0JywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBbkV4cGVjdChlbGVtZW50KSkge1xuICAgICAgICBjaGlsZCA9IGFkZE5vZGUoJ2V4cGVjdCcsIHBhcmVudCwgZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgZWxlbWVudC5kZWNsYXJhdGlvbnNcbiAgICAgICAgICAuZmlsdGVyKGRlY2xhcmF0aW9uID0+IGRlY2xhcmF0aW9uLmluaXQgJiYgaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmluaXQudHlwZSkpXG4gICAgICAgICAgLmZvckVhY2goZGVjbGFyYXRpb24gPT4gc2VhcmNoTm9kZXMoZGVjbGFyYXRpb24uaW5pdC5ib2R5LCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgZWxlbWVudC50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uICYmXG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nICYmXG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbi5yaWdodCAmJlxuICAgICAgICBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0LnR5cGUpXG4gICAgICApIHtcbiAgICAgICAgc2VhcmNoTm9kZXMoZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0LmJvZHksIHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ1JldHVyblN0YXRlbWVudCcgJiYgZWxlbWVudC5hcmd1bWVudD8uYXJndW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQuYXJndW1lbnQuYXJndW1lbnRzXG4gICAgICAgICAgLmZpbHRlcihhcmd1bWVudCA9PiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oYXJndW1lbnQudHlwZSkpXG4gICAgICAgICAgLmZvckVhY2goYXJndW1lbnQgPT4gc2VhcmNoTm9kZXMoYXJndW1lbnQuYm9keSwgcGFyZW50KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uQ2FsbChlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50LmV4cHJlc3Npb24uYXJndW1lbnRzXG4gICAgICAgICAgLmZpbHRlcihhcmd1bWVudCA9PiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oYXJndW1lbnQudHlwZSkpXG4gICAgICAgICAgLmZvckVhY2goYXJndW1lbnQgPT4gc2VhcmNoTm9kZXMoYXJndW1lbnQuYm9keSwgY2hpbGQgfHwgcGFyZW50KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qge3Byb2dyYW19ID0gYXN0O1xuICBzZWFyY2hOb2Rlcyhwcm9ncmFtLCBwYXJzZVJlc3VsdC5yb290KTtcblxuICByZXR1cm4gcGFyc2VSZXN1bHQ7XG59O1xuIl19