"use strict";

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _fs = require("fs");

var _typescript = _interopRequireDefault(require("typescript"));

var _parser_nodes = require("./parser_nodes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Note (2019/04/16):
 *
 * This is a direct port from the deprecated jest-test-typescript-parser in https://github.com/facebook/jest, as jest moving to babel-7, which includes direct typescript
 * support, the package is removed.
 *
 * However "jest-test-typescript-parser" is used by 3rd party tools such as vscode-jest, together with "jest-editor-support",
 * therefore, for the continuity and backward compatibility, we merged the legacy parser here and take responsibility in selecting the
 * proper parser for the given file. Therefore tools that adopt the new "jest-editor-support" package should remove
 * "jest-test-typescript-parser".
 *
 * 
 */

/* eslint-disable no-param-reassign */
function getNode(file, expression, node) {
  var start = file.getLineAndCharacterOfPosition(expression.getStart(file));
  node.start = {
    column: start.character + 1,
    line: start.line + 1
  };
  var pos = expression.getEnd();
  var end = file.getLineAndCharacterOfPosition(pos); // our end position is 1-based end character, including whitespace and
  // statement separator.  getLineAndCharacterOfPosition in typescript, however,
  // returns the 1-based location of the last non-whitespace char position.
  // Therefore we need to adjust for the actual lineEnd position here

  var lineEnd = file.getLineEndOfPosition(pos);
  var lineEndDiff = lineEnd - pos; // TypeScript parser is 0 based, so we have to increment by 1 to normalize
  // but the character position is the exclusive, so no need to to increment by 1

  node.end = {
    column: end.character + lineEndDiff,
    line: end.line + 1
  };
  node.file = file.fileName;
  return node;
} // eslint-disable-next-line import/prefer-default-export


function parse(file, data) {
  var sourceFile = _typescript["default"].createSourceFile(file, data || (0, _fs.readFileSync)(file).toString(), _typescript["default"].ScriptTarget.ES3);

  var parseResult = new _parser_nodes.ParseResult(file);

  var addNode = function addNode(tsNode, parent, type) {
    var child = parent.addChild(type);
    getNode(sourceFile, tsNode, child);

    if (child instanceof _parser_nodes.NamedBlock) {
      var arg = tsNode.arguments[0];
      child.name = arg.text;

      if (!child.name) {
        if (_typescript["default"].isTemplateExpression(arg)) {
          child.name = sourceFile.text.substring(arg.pos + 1, arg.end - 1);
        }
      }

      if (child.name != null) {
        var start = sourceFile.getLineAndCharacterOfPosition(arg.pos);
        var end = sourceFile.getLineAndCharacterOfPosition(arg.end);
        child.nameRange = new _parser_nodes.ParsedRange(start.line + 1, start.character + 2, end.line + 1, end.character - 1);
      } else {
        // eslint-disable-next-line no-console
        console.warn("NamedBlock but no name found for ".concat(type, " tsNode="), tsNode);
      }

      parseResult.addNode(child);
    } else {
      // block has no name, thus perform extra dedup check by line info
      parseResult.addNode(child, true);
    }

    return child;
  };

  function searchNodes(parent) {
    var findText = function findText(expression) {
      return expression && expression.text ? expression.text : undefined;
    };

    return function (node) {
      var sNode;

      if (node.kind === _typescript["default"].SyntaxKind.CallExpression) {
        var text = node.expression ? findText(node.expression) || findText(node.expression.expression) : undefined;

        if (text === 'describe') {
          sNode = addNode(node, parent, 'describe');
        } else if (text === 'it' || text === 'test' || text === 'fit') {
          sNode = addNode(node, parent, 'it');
        } else {
          var element = node.expression;
          var expectText = '';

          while (element && !expectText) {
            expectText = element.text;
            element = element.expression;
          }

          if (expectText === 'expect') {
            sNode = addNode(node, parent, 'expect');
          }
        }
      }

      _typescript["default"].forEachChild(node, searchNodes(sNode || parent));
    };
  }

  _typescript["default"].forEachChild(sourceFile, searchNodes(parseResult.root));

  return parseResult;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL3R5cGVzY3JpcHRfcGFyc2VyLmpzIl0sIm5hbWVzIjpbImdldE5vZGUiLCJmaWxlIiwiZXhwcmVzc2lvbiIsIm5vZGUiLCJzdGFydCIsImdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uIiwiZ2V0U3RhcnQiLCJjb2x1bW4iLCJjaGFyYWN0ZXIiLCJsaW5lIiwicG9zIiwiZ2V0RW5kIiwiZW5kIiwibGluZUVuZCIsImdldExpbmVFbmRPZlBvc2l0aW9uIiwibGluZUVuZERpZmYiLCJmaWxlTmFtZSIsInBhcnNlIiwiZGF0YSIsInNvdXJjZUZpbGUiLCJ0cyIsImNyZWF0ZVNvdXJjZUZpbGUiLCJ0b1N0cmluZyIsIlNjcmlwdFRhcmdldCIsIkVTMyIsInBhcnNlUmVzdWx0IiwiUGFyc2VSZXN1bHQiLCJhZGROb2RlIiwidHNOb2RlIiwicGFyZW50IiwidHlwZSIsImNoaWxkIiwiYWRkQ2hpbGQiLCJOYW1lZEJsb2NrIiwiYXJnIiwiYXJndW1lbnRzIiwibmFtZSIsInRleHQiLCJpc1RlbXBsYXRlRXhwcmVzc2lvbiIsInN1YnN0cmluZyIsIm5hbWVSYW5nZSIsIlBhcnNlZFJhbmdlIiwiY29uc29sZSIsIndhcm4iLCJzZWFyY2hOb2RlcyIsImZpbmRUZXh0IiwidW5kZWZpbmVkIiwic05vZGUiLCJraW5kIiwiU3ludGF4S2luZCIsIkNhbGxFeHByZXNzaW9uIiwiZWxlbWVudCIsImV4cGVjdFRleHQiLCJmb3JFYWNoQ2hpbGQiLCJyb290Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7QUFFQTs7QUFDQTs7OztBQXRCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBLFNBQVNBLE9BQVQsQ0FBZ0NDLElBQWhDLEVBQXFEQyxVQUFyRCxFQUFvRkMsSUFBcEYsRUFBZ0c7QUFDOUYsTUFBTUMsS0FBSyxHQUFHSCxJQUFJLENBQUNJLDZCQUFMLENBQW1DSCxVQUFVLENBQUNJLFFBQVgsQ0FBb0JMLElB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QU8sQ0FBQ3hCLElBQUQsRUFBTzBCLE1BQVAsRUFBZSxJQUFmLENBQWY7QUFDRCxTQUZNLE1BRUE7QUFDTCxjQUFJc0IsT0FBTyxHQUFHaEQsSUFBSSxDQUFDRCxVQUFuQjtBQUNBLGNBQUlrRCxVQUFVLEdBQUcsRUFBakI7O0FBQ0EsaUJBQU9ELE9BQU8sSUFBSSxDQUFDQyxVQUFuQixFQUErQjtBQUM3QkEsWUFBQUEsVUFBVSxHQUFHRCxPQUFPLENBQUNkLElBQXJCO0FBQ0FjLFlBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDakQsVUFBbEI7QUFDRDs7QUFDRCxjQUFJa0QsVUFBVSxLQUFLLFFBQW5CLEVBQTZCO0FBQzNCTCxZQUFBQSxLQUFLLEdBQUdwQixPQUFPLENBQUN4QixJQUFELEVBQU8wQixNQUFQLEVBQWUsUUFBZixDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUNEVCw2QkFBR2lDLFlBQUgsQ0FBZ0JsRCxJQUFoQixFQUFzQnlDLFdBQVcsQ0FBQ0csS0FBSyxJQUFJbEIsTUFBVixDQUFqQztBQUNELEtBdEJEO0FBdUJEOztBQUVEVCx5QkFBR2lDLFlBQUgsQ0FBZ0JsQyxVQUFoQixFQUE0QnlCLFdBQVcsQ0FBQ25CLFdBQVcsQ0FBQzZCLElBQWIsQ0FBdkM7O0FBQ0EsU0FBTzdCLFdBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogTm90ZSAoMjAxOS8wNC8xNik6XG4gKlxuICogVGhpcyBpcyBhIGRpcmVjdCBwb3J0IGZyb20gdGhlIGRlcHJlY2F0ZWQgamVzdC10ZXN0LXR5cGVzY3JpcHQtcGFyc2VyIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0LCBhcyBqZXN0IG1vdmluZyB0byBiYWJlbC03LCB3aGljaCBpbmNsdWRlcyBkaXJlY3QgdHlwZXNjcmlwdFxuICogc3VwcG9ydCwgdGhlIHBhY2thZ2UgaXMgcmVtb3ZlZC5cbiAqXG4gKiBIb3dldmVyIFwiamVzdC10ZXN0LXR5cGVzY3JpcHQtcGFyc2VyXCIgaXMgdXNlZCBieSAzcmQgcGFydHkgdG9vbHMgc3VjaCBhcyB2c2NvZGUtamVzdCwgdG9nZXRoZXIgd2l0aCBcImplc3QtZWRpdG9yLXN1cHBvcnRcIixcbiAqIHRoZXJlZm9yZSwgZm9yIHRoZSBjb250aW51aXR5IGFuZCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSBtZXJnZWQgdGhlIGxlZ2FjeSBwYXJzZXIgaGVyZSBhbmQgdGFrZSByZXNwb25zaWJpbGl0eSBpbiBzZWxlY3RpbmcgdGhlXG4gKiBwcm9wZXIgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gZmlsZS4gVGhlcmVmb3JlIHRvb2xzIHRoYXQgYWRvcHQgdGhlIG5ldyBcImplc3QtZWRpdG9yLXN1cHBvcnRcIiBwYWNrYWdlIHNob3VsZCByZW1vdmVcbiAqIFwiamVzdC10ZXN0LXR5cGVzY3JpcHQtcGFyc2VyXCIuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuXG5pbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQge05hbWVkQmxvY2ssIFBhcnNlZFJhbmdlLCBQYXJzZWROb2RlLCBQYXJzZVJlc3VsdH0gZnJvbSAnLi9wYXJzZXJfbm9kZXMnO1xuaW1wb3J0IHR5cGUge1BhcnNlZE5vZGVUeXBlfSBmcm9tICcuL3BhcnNlcl9ub2Rlcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5mdW5jdGlvbiBnZXROb2RlPFQ6IFBhcnNlZE5vZGU+KGZpbGU6IHRzLlNvdXJjZUZpbGUsIGV4cHJlc3Npb246IHRzLkNhbGxFeHByZXNzaW9uLCBub2RlOiBUKTogVCB7XG4gIGNvbnN0IHN0YXJ0ID0gZmlsZS5nZXRMaW5lQW5kQ2hhcmFjdGVyT2ZQb3NpdGlvbihleHByZXNzaW9uLmdldFN0YXJ0KGZpbGUpKTtcbiAgbm9kZS5zdGFydCA9IHtcbiAgICBjb2x1bW46IHN0YXJ0LmNoYXJhY3RlciArIDEsXG4gICAgbGluZTogc3RhcnQubGluZSArIDEsXG4gIH07XG4gIGNvbnN0IHBvcyA9IGV4cHJlc3Npb24uZ2V0RW5kKCk7XG4gIGNvbnN0IGVuZCA9IGZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24ocG9zKTtcblxuICAvLyBvdXIgZW5kIHBvc2l0aW9uIGlzIDEtYmFzZWQgZW5kIGNoYXJhY3RlciwgaW5jbHVkaW5nIHdoaXRlc3BhY2UgYW5kXG4gIC8vIHN0YXRlbWVudCBzZXBhcmF0b3IuICBnZXRMaW5lQW5kQ2hhcmFjdGVyT2ZQb3NpdGlvbiBpbiB0eXBlc2NyaXB0LCBob3dldmVyLFxuICAvLyByZXR1cm5zIHRoZSAxLWJhc2VkIGxvY2F0aW9uIG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXIgcG9zaXRpb24uXG4gIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGFkanVzdCBmb3IgdGhlIGFjdHVhbCBsaW5lRW5kIHBvc2l0aW9uIGhlcmVcbiAgY29uc3QgbGluZUVuZCA9IGZpbGUuZ2V0TGluZUVuZE9mUG9zaXRpb24ocG9zKTtcbiAgY29uc3QgbGluZUVuZERpZmYgPSBsaW5lRW5kIC0gcG9zO1xuXG4gIC8vIFR5cGVTY3JpcHQgcGFyc2VyIGlzIDAgYmFzZWQsIHNvIHdlIGhhdmUgdG8gaW5jcmVtZW50IGJ5IDEgdG8gbm9ybWFsaXplXG4gIC8vIGJ1dCB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGlzIHRoZSBleGNsdXNpdmUsIHNvIG5vIG5lZWQgdG8gdG8gaW5jcmVtZW50IGJ5IDFcbiAgbm9kZS5lbmQgPSB7XG4gICAgY29sdW1uOiBlbmQuY2hhcmFjdGVyICsgbGluZUVuZERpZmYsXG4gICAgbGluZTogZW5kLmxpbmUgKyAxLFxuICB9O1xuICBub2RlLmZpbGUgPSBmaWxlLmZpbGVOYW1lO1xuICByZXR1cm4gbm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnRcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShmaWxlOiBzdHJpbmcsIGRhdGE6ID9zdHJpbmcpOiBQYXJzZVJlc3VsdCB7XG4gIGNvbnN0IHNvdXJjZUZpbGUgPSB0cy5jcmVhdGVTb3VyY2VGaWxlKGZpbGUsIGRhdGEgfHwgcmVhZEZpbGVTeW5jKGZpbGUpLnRvU3RyaW5nKCksIHRzLlNjcmlwdFRhcmdldC5FUzMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IG5ldyBQYXJzZVJlc3VsdChmaWxlKTtcblxuICBjb25zdCBhZGROb2RlID0gKHRzTm9kZTogdHMuTm9kZSwgcGFyZW50OiBQYXJzZWROb2RlLCB0eXBlOiBQYXJzZWROb2RlVHlwZSk6IFBhcnNlZE5vZGUgPT4ge1xuICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmFkZENoaWxkKHR5cGUpO1xuICAgIGdldE5vZGUoc291cmNlRmlsZSwgdHNOb2RlLCBjaGlsZCk7XG5cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBOYW1lZEJsb2NrKSB7XG4gICAgICBjb25zdCBhcmcgPSB0c05vZGUuYXJndW1lbnRzWzBdO1xuICAgICAgY2hpbGQubmFtZSA9IGFyZy50ZXh0O1xuICAgICAgaWYgKCFjaGlsZC5uYW1lKSB7XG4gICAgICAgIGlmICh0cy5pc1RlbXBsYXRlRXhwcmVzc2lvbihhcmcpKSB7XG4gICAgICAgICAgY2hpbGQubmFtZSA9IHNvdXJjZUZpbGUudGV4dC5zdWJzdHJpbmcoYXJnLnBvcyArIDEsIGFyZy5lbmQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHNvdXJjZUZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oYXJnLnBvcyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHNvdXJjZUZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oYXJnLmVuZCk7XG4gICAgICAgIGNoaWxkLm5hbWVSYW5nZSA9IG5ldyBQYXJzZWRSYW5nZShzdGFydC5saW5lICsgMSwgc3RhcnQuY2hhcmFjdGVyICsgMiwgZW5kLmxpbmUgKyAxLCBlbmQuY2hhcmFjdGVyIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oYE5hbWVkQmxvY2sgYnV0IG5vIG5hbWUgZm91bmQgZm9yICR7dHlwZX0gdHNOb2RlPWAsIHRzTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlUmVzdWx0LmFkZE5vZGUoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBibG9jayBoYXMgbm8gbmFtZSwgdGh1cyBwZXJmb3JtIGV4dHJhIGRlZHVwIGNoZWNrIGJ5IGxpbmUgaW5mb1xuICAgICAgcGFyc2VSZXN1bHQuYWRkTm9kZShjaGlsZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNlYXJjaE5vZGVzKHBhcmVudDogUGFyc2VkTm9kZSkge1xuICAgIGNvbnN0IGZpbmRUZXh0ID0gKGV4cHJlc3Npb246IGFueSkgPT4gKGV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbi50ZXh0ID8gZXhwcmVzc2lvbi50ZXh0IDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gKG5vZGU6IHRzLk5vZGUpID0+IHtcbiAgICAgIGxldCBzTm9kZTogP1BhcnNlZE5vZGU7XG4gICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBub2RlLmV4cHJlc3Npb24gPyBmaW5kVGV4dChub2RlLmV4cHJlc3Npb24pIHx8IGZpbmRUZXh0KG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGV4dCA9PT0gJ2Rlc2NyaWJlJykge1xuICAgICAgICAgIHNOb2RlID0gYWRkTm9kZShub2RlLCBwYXJlbnQsICdkZXNjcmliZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgPT09ICdpdCcgfHwgdGV4dCA9PT0gJ3Rlc3QnIHx8IHRleHQgPT09ICdmaXQnKSB7XG4gICAgICAgICAgc05vZGUgPSBhZGROb2RlKG5vZGUsIHBhcmVudCwgJ2l0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGVsZW1lbnQgPSBub2RlLmV4cHJlc3Npb247XG4gICAgICAgICAgbGV0IGV4cGVjdFRleHQgPSAnJztcbiAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiAhZXhwZWN0VGV4dCkge1xuICAgICAgICAgICAgZXhwZWN0VGV4dCA9IGVsZW1lbnQudGV4dDtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmV4cHJlc3Npb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHBlY3RUZXh0ID09PSAnZXhwZWN0Jykge1xuICAgICAgICAgICAgc05vZGUgPSBhZGROb2RlKG5vZGUsIHBhcmVudCwgJ2V4cGVjdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHMuZm9yRWFjaENoaWxkKG5vZGUsIHNlYXJjaE5vZGVzKHNOb2RlIHx8IHBhcmVudCkpO1xuICAgIH07XG4gIH1cblxuICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgc2VhcmNoTm9kZXMocGFyc2VSZXN1bHQucm9vdCkpO1xuICByZXR1cm4gcGFyc2VSZXN1bHQ7XG59XG4iXX0=