"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.some");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.reflect.construct");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParseResult = exports.DescribeBlock = exports.ItBlock = exports.NamedBlock = exports.Expect = exports.ParsedNode = exports.ParsedNodeTypes = exports.ParsedRange = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable no-use-before-define */

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * range and location here are 1-based position.
 */
var ParsedRange = function ParsedRange(startLine, startCol, endLine, endCol) {
  _classCallCheck(this, ParsedRange);

  this.start = {
    column: startCol,
    line: startLine
  };
  this.end = {
    column: endCol,
    line: endLine
  };
}; // export type ParsedNodeType = 'expect' | 'describe' | 'it' | 'ROOT';


exports.ParsedRange = ParsedRange;
var ParsedNodeTypes = {
  describe: 'describe',
  expect: 'expect',
  it: 'it',
  root: 'root'
};
exports.ParsedNodeTypes = ParsedNodeTypes;

var ParsedNode = /*#__PURE__*/function () {
  function ParsedNode(type, file) {
    _classCallCheck(this, ParsedNode);

    this.type = type;
    this.file = file;
  }

  _createClass(ParsedNode, [{
    key: "addChild",
    value: function addChild(type) {
      var child;

      switch (type) {
        case ParsedNodeTypes.describe:
          child = new DescribeBlock(this.file);
          break;

        case ParsedNodeTypes.it:
          child = new ItBlock(this.file);
          break;

        case ParsedNodeTypes.expect:
          child = new Expect(this.file);
          break;

        default:
          throw TypeError("unexpected child node type: ".concat(type));
      }

      if (!this.children) {
        this.children = [child];
      } else {
        this.children.push(child);
      }

      return child;
    }
  }, {
    key: "filter",
    value: function filter(f) {
      var filterSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var filtered = [];

      var _filter = function _filter(node, _filterSelf) {
        if (_filterSelf && f(node)) {
          filtered.push(node);
        }

        if (node.children) {
          node.children.forEach(function (c) {
            return _filter(c, true);
          });
        }
      };

      _filter(this, filterSelf);

      return filtered;
    }
  }]);

  return ParsedNode;
}();

exports.ParsedNode = ParsedNode;

var Expect = /*#__PURE__*/function (_ParsedNode) {
  _inherits(Expect, _ParsedNode);

  var _super = _createSuper(Expect);

  function Expect(file) {
    _classCallCheck(this, Expect);

    return _super.call(this, ParsedNodeTypes.expect, file);
  }

  return Expect;
}(ParsedNode);

exports.Expect = Expect;

var NamedBlock = /*#__PURE__*/function (_ParsedNode2) {
  _inherits(NamedBlock, _ParsedNode2);

  var _super2 = _createSuper(NamedBlock);

  function NamedBlock(type, file, name) {
    var _this;

    _classCallCheck(this, NamedBlock);

    _this = _super2.call(this, type, file);

    if (name) {
      _this.name = name;
    }

    return _this;
  }

  return NamedBlock;
}(ParsedNode);

exports.NamedBlock = NamedBlock;

var ItBlock = /*#__PURE__*/function (_NamedBlock) {
  _inherits(ItBlock, _NamedBlock);

  var _super3 = _createSuper(ItBlock);

  function ItBlock(file, name) {
    _classCallCheck(this, ItBlock);

    return _super3.call(this, ParsedNodeTypes.it, file, name);
  }

  return ItBlock;
}(NamedBlock);

exports.ItBlock = ItBlock;

var DescribeBlock = /*#__PURE__*/function (_NamedBlock2) {
  _inherits(DescribeBlock, _NamedBlock2);

  var _super4 = _createSuper(DescribeBlock);

  function DescribeBlock(file, name) {
    _classCallCheck(this, DescribeBlock);

    return _super4.call(this, ParsedNodeTypes.describe, file, name);
  }

  return DescribeBlock;
}(NamedBlock); // export type NodeClass = Node | Expect | ItBlock | DescribeBlock;


exports.DescribeBlock = DescribeBlock;

var ParseResult = /*#__PURE__*/function () {
  function ParseResult(file) {
    _classCallCheck(this, ParseResult);

    this.file = file;
    this.root = new ParsedNode(ParsedNodeTypes.root, file);
    this.describeBlocks = [];
    this.expects = [];
    this.itBlocks = [];
  }

  _createClass(ParseResult, [{
    key: "addNode",
    value: function addNode(node) {
      var dedup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (node instanceof DescribeBlock) {
        this.describeBlocks.push(node);
      } else if (node instanceof ItBlock) {
        this.itBlocks.push(node);
      } else if (node instanceof Expect) {
        if (dedup && this.expects.some(function (e) {
          return e.start.line === node.start.line && e.start.column === node.start.column;
        })) {
          // found dup, return
          return;
        }

        this.expects.push(node);
      } else {
        throw new TypeError("unexpected node class '".concat(_typeof(node), "': ").concat(JSON.stringify(node)));
      }
    }
  }]);

  return ParseResult;
}();

exports.ParseResult = ParseResult;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL3BhcnNlcl9ub2Rlcy5qcyJdLCJuYW1lcyI6WyJQYXJzZWRSYW5nZSIsInN0YXJ0TGluZSIsInN0YXJ0Q29sIiwiZW5kTGluZSIsImVuZENvbCIsInN0YXJ0IiwiY29sdW1uIiwibGluZSIsImVuZCIsIlBhcnNlZE5vZGVUeXBlcyIsImRlc2NyaWJlIiwiZXhwZWN0IiwiaXQiLCJyb290IiwiUGFyc2VkTm9kZSIsInR5cGUiLCJmaWxlIiwiY2hpbGQiLCJEZXNjcmliZUJsb2NrIiwiSXRCbG9jayIsIkV4cGVjdCIsIlR5cGVFcnJvciIsImNoaWxkcmVuIiwicHVzaCIsImYiLCJmaWx0ZXJTZWxmIiwiZmlsdGVyZWQiLCJfZmlsdGVyIiwibm9kZSIsIl9maWx0ZXJTZWxmIiwiZm9yRWFjaCIsImMiLCJOYW1lZEJsb2NrIiwibmFtZSIsIlBhcnNlUmVzdWx0IiwiZGVzY3JpYmVCbG9ja3MiLCJleHBlY3RzIiwiaXRCbG9ja3MiLCJkZWR1cCIsInNvbWUiLCJlIiwiSlNPTiIsInN0cmluZ2lmeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOzs7Ozs7Ozs7QUFXQTs7O0lBR2FBLFcsR0FLWCxxQkFBWUMsU0FBWixFQUErQkMsUUFBL0IsRUFBaURDLE9BQWpELEVBQWtFQyxNQUFsRSxFQUFrRjtBQUFBOztBQUNoRixPQUFLQyxLQUFMLEdBQWE7QUFBQ0MsSUFBQUEsTUFBTSxFQUFFSixRQUFUO0FBQW1CSyxJQUFBQSxJQUFJLEVBQUVOO0FBQXpCLEdBQWI7QUFDQSxPQUFLTyxHQUFMLEdBQVc7QUFBQ0YsSUFBQUEsTUFBTSxFQUFFRixNQUFUO0FBQWlCRyxJQUFBQSxJQUFJLEVBQUVKO0FBQXZCLEdBQVg7QUFDRCxDLEVBR0g7Ozs7QUFFTyxJQUFNTSxlQUFlLEdBQUc7QUFDN0JDLEVBQUFBLFFBQVEsRUFBRSxV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XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0xvY2F0aW9ufSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogcmFuZ2UgYW5kIGxvY2F0aW9uIGhlcmUgYXJlIDEtYmFzZWQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzZWRSYW5nZSB7XG4gIHN0YXJ0OiBMb2NhdGlvbjtcblxuICBlbmQ6IExvY2F0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHN0YXJ0TGluZTogbnVtYmVyLCBzdGFydENvbDogbnVtYmVyLCBlbmRMaW5lOiBudW1iZXIsIGVuZENvbDogbnVtYmVyKSB7XG4gICAgdGhpcy5zdGFydCA9IHtjb2x1bW46IHN0YXJ0Q29sLCBsaW5lOiBzdGFydExpbmV9O1xuICAgIHRoaXMuZW5kID0ge2NvbHVtbjogZW5kQ29sLCBsaW5lOiBlbmRMaW5lfTtcbiAgfVxufVxuXG4vLyBleHBvcnQgdHlwZSBQYXJzZWROb2RlVHlwZSA9ICdleHBlY3QnIHwgJ2Rlc2NyaWJlJyB8ICdpdCcgfCAnUk9PVCc7XG5cbmV4cG9ydCBjb25zdCBQYXJzZWROb2RlVHlwZXMgPSB7XG4gIGRlc2NyaWJlOiAnZGVzY3JpYmUnLFxuICBleHBlY3Q6ICdleHBlY3QnLFxuICBpdDogJ2l0JyxcbiAgcm9vdDogJ3Jvb3QnLFxufTtcblxuZXhwb3J0IHR5cGUgUGFyc2VkTm9kZVR5cGUgPSAkS2V5czx0eXBlb2YgUGFyc2VkTm9kZVR5cGVzPjtcblxuZXhwb3J0IGNsYXNzIFBhcnNlZE5vZGUge1xuICB0eXBlOiBQYXJzZWROb2RlVHlwZTtcblxuICBzdGFydDogTG9jYXRpb247XG5cbiAgZW5kOiBMb2NhdGlvbjtcblxuICBmaWxlOiBzdHJpbmc7XG5cbiAgY2hpbGRyZW46ID9BcnJheTxQYXJzZWROb2RlPjtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBQYXJzZWROb2RlVHlwZSwgZmlsZTogc3RyaW5nKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgYWRkQ2hpbGQodHlwZTogUGFyc2VkTm9kZVR5cGUpOiBQYXJzZWROb2RlIHtcbiAgICBsZXQgY2hpbGQ6IFBhcnNlZE5vZGU7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGFyc2VkTm9kZVR5cGVzLmRlc2NyaWJlOlxuICAgICAgICBjaGlsZCA9IG5ldyBEZXNjcmliZUJsb2NrKHRoaXMuZmlsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYXJzZWROb2RlVHlwZXMuaXQ6XG4gICAgICAgIGNoaWxkID0gbmV3IEl0QmxvY2sodGhpcy5maWxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhcnNlZE5vZGVUeXBlcy5leHBlY3Q6XG4gICAgICAgIGNoaWxkID0gbmV3IEV4cGVjdCh0aGlzLmZpbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgdW5leHBlY3RlZCBjaGlsZCBub2RlIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gW2NoaWxkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgZmlsdGVyKGY6IChub2RlOiBQYXJzZWROb2RlKSA9PiBib29sZWFuLCBmaWx0ZXJTZWxmOiBib29sZWFuID0gZmFsc2UpOiBBcnJheTxQYXJzZWROb2RlPiB7XG4gICAgY29uc3QgZmlsdGVyZWQ6IEFycmF5PFBhcnNlZE5vZGU+ID0gW107XG5cbiAgICBjb25zdCBfZmlsdGVyID0gKG5vZGU6IFBhcnNlZE5vZGUsIF9maWx0ZXJTZWxmOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoX2ZpbHRlclNlbGYgJiYgZihub2RlKSkge1xuICAgICAgICBmaWx0ZXJlZC5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBfZmlsdGVyKGMsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX2ZpbHRlcih0aGlzLCBmaWx0ZXJTZWxmKTtcbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV4cGVjdCBleHRlbmRzIFBhcnNlZE5vZGUge1xuICBjb25zdHJ1Y3RvcihmaWxlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihQYXJzZWROb2RlVHlwZXMuZXhwZWN0LCBmaWxlKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmFtZWRCbG9jayBleHRlbmRzIFBhcnNlZE5vZGUge1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgbmFtZVJhbmdlOiBQYXJzZWRSYW5nZTtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBQYXJzZWROb2RlVHlwZSwgZmlsZTogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgc3VwZXIodHlwZSwgZmlsZSk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJdEJsb2NrIGV4dGVuZHMgTmFtZWRCbG9jayB7XG4gIGNvbnN0cnVjdG9yKGZpbGU6IHN0cmluZywgbmFtZT86IHN0cmluZykge1xuICAgIHN1cGVyKFBhcnNlZE5vZGVUeXBlcy5pdCwgZmlsZSwgbmFtZSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBEZXNjcmliZUJsb2NrIGV4dGVuZHMgTmFtZWRCbG9jayB7XG4gIGNvbnN0cnVjdG9yKGZpbGU6IHN0cmluZywgbmFtZT86IHN0cmluZykge1xuICAgIHN1cGVyKFBhcnNlZE5vZGVUeXBlcy5kZXNjcmliZSwgZmlsZSwgbmFtZSk7XG4gIH1cbn1cblxuLy8gZXhwb3J0IHR5cGUgTm9kZUNsYXNzID0gTm9kZSB8IEV4cGVjdCB8IEl0QmxvY2sgfCBEZXNjcmliZUJsb2NrO1xuXG5leHBvcnQgY2xhc3MgUGFyc2VSZXN1bHQge1xuICBkZXNjcmliZUJsb2NrczogQXJyYXk8RGVzY3JpYmVCbG9jaz47XG5cbiAgZXhwZWN0czogQXJyYXk8RXhwZWN0PjtcblxuICBpdEJsb2NrczogQXJyYXk8SXRCbG9jaz47XG5cbiAgcm9vdDogUGFyc2VkTm9kZTtcblxuICBmaWxlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZmlsZTogc3RyaW5nKSB7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUGFyc2VkTm9kZShQYXJzZWROb2RlVHlwZXMucm9vdCwgZmlsZSk7XG5cbiAgICB0aGlzLmRlc2NyaWJlQmxvY2tzID0gW107XG4gICAgdGhpcy5leHBlY3RzID0gW107XG4gICAgdGhpcy5pdEJsb2NrcyA9IFtdO1xuICB9XG5cbiAgYWRkTm9kZShub2RlOiBQYXJzZWROb2RlLCBkZWR1cDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEZXNjcmliZUJsb2NrKSB7XG4gICAgICB0aGlzLmRlc2NyaWJlQmxvY2tzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgSXRCbG9jaykge1xuICAgICAgdGhpcy5pdEJsb2Nrcy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEV4cGVjdCkge1xuICAgICAgaWYgKGRlZHVwICYmIHRoaXMuZXhwZWN0cy5zb21lKGUgPT4gZS5zdGFydC5saW5lID09PSBub2RlLnN0YXJ0LmxpbmUgJiYgZS5zdGFydC5jb2x1bW4gPT09IG5vZGUuc3RhcnQuY29sdW1uKSkge1xuICAgICAgICAvLyBmb3VuZCBkdXAsIHJldHVyblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0cy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bmV4cGVjdGVkIG5vZGUgY2xhc3MgJyR7dHlwZW9mIG5vZGV9JzogJHtKU09OLnN0cmluZ2lmeShub2RlKX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==