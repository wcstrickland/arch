"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = exports.getASTfor = void 0;

var _fs = require("fs");

var _babylon = require("babylon");

var _parser_nodes = require("./parser_nodes");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// eslint-disable no-underscore-dangle
var _getASTfor = function _getASTfor(file, data) {
  var _data = data || (0, _fs.readFileSync)(file).toString();

  var config = {
    plugins: ['*'],
    sourceType: 'module'
  };
  return [(0, _babylon.parse)(_data, config), _data];
};

var getASTfor = function getASTfor(file, data) {
  var _getASTfor2 = _getASTfor(file, data),
      _getASTfor3 = _slicedToArray(_getASTfor2, 1),
      bFile = _getASTfor3[0];

  return bFile;
};

exports.getASTfor = getASTfor;

var parse = function parse(file, data) {
  var parseResult = new _parser_nodes.ParseResult(file);

  var _getASTfor4 = _getASTfor(file, data),
      _getASTfor5 = _slicedToArray(_getASTfor4, 2),
      ast = _getASTfor5[0],
      _data = _getASTfor5[1];

  var updateNameInfo = function updateNameInfo(nBlock, bNode) {
    var arg = bNode.expression.arguments[0];
    var name = arg.value;

    if (!name && arg.type === 'TemplateLiteral') {
      name = _data.substring(arg.start + 1, arg.end - 1);
    }

    if (name == null) {
      throw new TypeError("failed to update namedBlock from: ".concat(JSON.stringify(bNode)));
    }

    nBlock.name = name;
    nBlock.nameRange = new _parser_nodes.ParsedRange(arg.loc.start.line, arg.loc.start.column + 2, arg.loc.end.line, arg.loc.end.column - 1);
  };

  var updateNode = function updateNode(node, babylonNode) {
    node.start = babylonNode.loc.start;
    node.end = babylonNode.loc.end;
    node.start.column += 1;
    parseResult.addNode(node);

    if (node instanceof _parser_nodes.NamedBlock) {
      updateNameInfo(node, babylonNode);
    }
  };

  var isFunctionCall = function isFunctionCall(node) {
    return node && node.type === 'ExpressionStatement' && node.expression && node.expression.type === 'CallExpression';
  };

  var isFunctionDeclaration = function isFunctionDeclaration(nodeType) {
    return nodeType === 'ArrowFunctionExpression' || nodeType === 'FunctionExpression';
  }; // Pull out the name of a CallExpression (describe/it)
  // handle cases where it's a member expression (.only)


  var getNameForNode = function getNameForNode(node) {
    if (isFunctionCall(node) && node && node.expression && node.expression.callee) {
      return node.expression.callee.name || (node.expression.callee.object ? node.expression.callee.object.name : undefined);
    }

    return undefined;
  }; // When given a node in the AST, does this represent
  // the start of an it/test block?


  var isAnIt = function isAnIt(node) {
    var name = getNameForNode(node);
    return name === 'it' || name === 'fit' || name === 'test';
  };

  var isAnDescribe = function isAnDescribe(node) {
    var name = getNameForNode(node);
    return name === 'describe';
  }; // When given a node in the AST, does this represent
  // the start of an expect expression?


  var isAnExpect = function isAnExpect(node) {
    if (!isFunctionCall(node)) {
      return false;
    }

    var name = '';
    var element = node && node.expression ? node.expression.callee : undefined;

    while (!name && element) {
      // eslint-disable-next-line prefer-destructuring
      name = element.name; // Because expect may have accessors tacked on (.to.be) or nothing
      // (expect()) we have to check multiple levels for the name

      element = element.object || element.callee;
    }

    return name === 'expect';
  };

  var addNode = function addNode(type, parent, babylonNode) {
    var child = parent.addChild(type);
    updateNode(child, babylonNode);

    if (child instanceof _parser_nodes.NamedBlock && child.name == null) {
      // eslint-disable-next-line no-console
      console.warn("block is missing name: ".concat(JSON.stringify(babylonNode)));
    }

    return child;
  }; // A recursive AST parser


  var searchNodes = function searchNodes(babylonParent, parent) {
    // Look through the node's children
    var child;

    if (!babylonParent.body) {
      return;
    }

    babylonParent.body.forEach(function (element) {
      child = undefined; // Pull out the node
      // const element = babylonParent.body[node];

      if (isAnDescribe(element)) {
        child = addNode('describe', parent, element);
      } else if (isAnIt(element)) {
        child = addNode('it', parent, element);
      } else if (isAnExpect(element)) {
        child = addNode('expect', parent, element);
      } else if (element && element.type === 'VariableDeclaration') {
        element.declarations.filter(function (declaration) {
          return declaration.init && isFunctionDeclaration(declaration.init.type);
        }).forEach(function (declaration) {
          return searchNodes(declaration.init.body, parent);
        });
      } else if (element && element.type === 'ExpressionStatement' && element.expression && element.expression.type === 'AssignmentExpression' && element.expression.right && isFunctionDeclaration(element.expression.right.type)) {
        searchNodes(element.expression.right.body, parent);
      } else if (element.type === 'ReturnStatement' && element.argument.arguments) {
        element.argument.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, parent);
        });
      }

      if (isFunctionCall(element)) {
        element.expression.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, child || parent);
        });
      }
    });
  };

  var program = ast.program;
  searchNodes(program, parseResult.root);
  return parseResult;
};

exports.parse = parse;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL2JhYnlsb25fcGFyc2VyLmpzIl0sIm5hbWVzIjpbIl9nZXRBU1Rmb3IiLCJmaWxlIiwiZGF0YSIsIl9kYXRhIiwidG9TdHJpbmciLCJjb25maWciLCJwbHVnaW5zIiwic291cmNlVHlwZSIsImdldEFTVGZvciIsImJGaWxlIiwicGFyc2UiLCJwYXJzZVJlc3VsdCIsIlBhcnNlUmVzdWx0IiwiYXN0IiwidXBkYXRlTmFtZUluZm8iLCJuQmxvY2siLCJiTm9kZSIsImFyZyIsImV4cHJlc3Npb24iLCJhcmd1bWVudHMiLCJuYW1lIiwidmFsdWUiLCJ0eXBlIiwic3Vic3RyaW5nIiwic3RhcnQiLCJlbmQiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibmFtZVJhbmdlIiwiUGFyc2VkUmFuZ2UiLCJsb2MiLCJsaW5lIiwiY29sdW1uIiwidXBkYXRlTm9kZSIsIm5vZGUiLCJiYWJ5bG9uTm9kZSIsImFkZE5vZGUiLCJOYW1lZEJsb2NrIiwiaXNGdW5jdGlvbkNhbGwiLCJpc0Z1bmN0aW9uRGVjbGFyYXRpb24iLCJub2RlVHlwZSIsImdldE5hbWVGb3JOb2RlIiwiY2FsbGVlIiwib2JqZWN0IiwidW5kZWZpbmVkIiwiaXNBbkl0IiwiaXNBbkRlc2NyaWJlIiwiaXNBbkV4cGVjdCIsImVsZW1lbnQiLCJwYXJlbnQiLCJjaGlsZCIsImFkZENoaWxkIiwiY29uc29sZSIsIndhcm4iLCJzZWFyY2hOb2RlcyIsImJhYnlsb25QYXJlbnQiLCJib2R5IiwiZm9yRWFjaCIsImRlY2xhcmF0aW9ucyIsImZpbHRlciIsImRlY2xhcmF0aW9uIiwiaW5pdCIsInJpZ2h0IiwiYXJndW1lbnQiLCJwcm9ncmFtIiwicm9vdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdBOztBQUVBOztBQUVBOzs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFDQyxJ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QjtBQUFBLFNBRGxCLEVBRUdvQyxPQUZILENBRVcsVUFBQU0sUUFBUTtBQUFBLGlCQUFJVCxXQUFXLENBQUNTLFFBQVEsQ0FBQ1AsSUFBVixFQUFnQk4sS0FBSyxJQUFJRCxNQUF6QixDQUFmO0FBQUEsU0FGbkI7QUFHRDtBQUNGLEtBbkNEO0FBb0NELEdBNUNEOztBQTdGaUUsTUEySTFEZSxPQTNJMEQsR0EySS9DcEQsR0EzSStDLENBMkkxRG9ELE9BM0kwRDtBQTRJakVWLEVBQUFBLFdBQVcsQ0FBQ1UsT0FBRCxFQUFVdEQsV0FBVyxDQUFDdUQsSUFBdEIsQ0FBWDtBQUVBLFNBQU92RCxXQUFQO0FBQ0QsQ0EvSU0iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuXG5pbXBvcnQge0ZpbGUgYXMgQmFieWxvbkZpbGUsIE5vZGUgYXMgQmFieWxvbk5vZGUsIHBhcnNlIGFzIGJhYnlsb25QYXJzZX0gZnJvbSAnYmFieWxvbic7XG5pbXBvcnQgdHlwZSB7UGFyc2VkTm9kZVR5cGV9IGZyb20gJy4vcGFyc2VyX25vZGVzJztcbmltcG9ydCB7TmFtZWRCbG9jaywgUGFyc2VkUmFuZ2UsIFBhcnNlUmVzdWx0LCBQYXJzZWROb2RlfSBmcm9tICcuL3BhcnNlcl9ub2Rlcyc7XG5cbi8vIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG5jb25zdCBfZ2V0QVNUZm9yID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZyk6IFtCYWJ5bG9uRmlsZSwgc3RyaW5nXSA9PiB7XG4gIGNvbnN0IF9kYXRhID0gZGF0YSB8fCByZWFkRmlsZVN5bmMoZmlsZSkudG9TdHJpbmcoKTtcbiAgY29uc3QgY29uZmlnID0ge3BsdWdpbnM6IFsnKiddLCBzb3VyY2VUeXBlOiAnbW9kdWxlJ307XG4gIHJldHVybiBbYmFieWxvblBhcnNlKF9kYXRhLCBjb25maWcpLCBfZGF0YV07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QVNUZm9yID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZyk6IEJhYnlsb25GaWxlID0+IHtcbiAgY29uc3QgW2JGaWxlXSA9IF9nZXRBU1Rmb3IoZmlsZSwgZGF0YSk7XG4gIHJldHVybiBiRmlsZTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZSA9IChmaWxlOiBzdHJpbmcsIGRhdGE6ID9zdHJpbmcpOiBQYXJzZVJlc3VsdCA9PiB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gbmV3IFBhcnNlUmVzdWx0KGZpbGUpO1xuICBjb25zdCBbYXN0LCBfZGF0YV0gPSBfZ2V0QVNUZm9yKGZpbGUsIGRhdGEpO1xuXG4gIGNvbnN0IHVwZGF0ZU5hbWVJbmZvID0gKG5CbG9jazogTmFtZWRCbG9jaywgYk5vZGU6IEJhYnlsb25Ob2RlKSA9PiB7XG4gICAgY29uc3QgYXJnID0gYk5vZGUuZXhwcmVzc2lvbi5hcmd1bWVudHNbMF07XG4gICAgbGV0IG5hbWUgPSBhcmcudmFsdWU7XG5cbiAgICBpZiAoIW5hbWUgJiYgYXJnLnR5cGUgPT09ICdUZW1wbGF0ZUxpdGVyYWwnKSB7XG4gICAgICBuYW1lID0gX2RhdGEuc3Vic3RyaW5nKGFyZy5zdGFydCArIDEsIGFyZy5lbmQgLSAxKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBmYWlsZWQgdG8gdXBkYXRlIG5hbWVkQmxvY2sgZnJvbTogJHtKU09OLnN0cmluZ2lmeShiTm9kZSl9YCk7XG4gICAgfVxuICAgIG5CbG9jay5uYW1lID0gbmFtZTtcbiAgICBuQmxvY2submFtZVJhbmdlID0gbmV3IFBhcnNlZFJhbmdlKFxuICAgICAgYXJnLmxvYy5zdGFydC5saW5lLFxuICAgICAgYXJnLmxvYy5zdGFydC5jb2x1bW4gKyAyLFxuICAgICAgYXJnLmxvYy5lbmQubGluZSxcbiAgICAgIGFyZy5sb2MuZW5kLmNvbHVtbiAtIDFcbiAgICApO1xuICB9O1xuICBjb25zdCB1cGRhdGVOb2RlID0gKG5vZGU6IFBhcnNlZE5vZGUsIGJhYnlsb25Ob2RlOiBCYWJ5bG9uTm9kZSkgPT4ge1xuICAgIG5vZGUuc3RhcnQgPSBiYWJ5bG9uTm9kZS5sb2Muc3RhcnQ7XG4gICAgbm9kZS5lbmQgPSBiYWJ5bG9uTm9kZS5sb2MuZW5kO1xuICAgIG5vZGUuc3RhcnQuY29sdW1uICs9IDE7XG5cbiAgICBwYXJzZVJlc3VsdC5hZGROb2RlKG5vZGUpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgTmFtZWRCbG9jaykge1xuICAgICAgdXBkYXRlTmFtZUluZm8obm9kZSwgYmFieWxvbk5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpc0Z1bmN0aW9uQ2FsbCA9IG5vZGUgPT5cbiAgICBub2RlICYmIG5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmIG5vZGUuZXhwcmVzc2lvbiAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJztcblxuICBjb25zdCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAobm9kZVR5cGU6IHN0cmluZykgPT5cbiAgICBub2RlVHlwZSA9PT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyB8fCBub2RlVHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbic7XG5cbiAgLy8gUHVsbCBvdXQgdGhlIG5hbWUgb2YgYSBDYWxsRXhwcmVzc2lvbiAoZGVzY3JpYmUvaXQpXG4gIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBpdCdzIGEgbWVtYmVyIGV4cHJlc3Npb24gKC5vbmx5KVxuICBjb25zdCBnZXROYW1lRm9yTm9kZSA9IG5vZGUgPT4ge1xuICAgIGlmIChpc0Z1bmN0aW9uQ2FsbChub2RlKSAmJiBub2RlICYmIG5vZGUuZXhwcmVzc2lvbiAmJiBub2RlLmV4cHJlc3Npb24uY2FsbGVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBub2RlLmV4cHJlc3Npb24uY2FsbGVlLm5hbWUgfHwgKG5vZGUuZXhwcmVzc2lvbi5jYWxsZWUub2JqZWN0ID8gbm9kZS5leHByZXNzaW9uLmNhbGxlZS5vYmplY3QubmFtZSA6IHVuZGVmaW5lZClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gV2hlbiBnaXZlbiBhIG5vZGUgaW4gdGhlIEFTVCwgZG9lcyB0aGlzIHJlcHJlc2VudFxuICAvLyB0aGUgc3RhcnQgb2YgYW4gaXQvdGVzdCBibG9jaz9cbiAgY29uc3QgaXNBbkl0ID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGdldE5hbWVGb3JOb2RlKG5vZGUpO1xuICAgIHJldHVybiBuYW1lID09PSAnaXQnIHx8IG5hbWUgPT09ICdmaXQnIHx8IG5hbWUgPT09ICd0ZXN0JztcbiAgfTtcblxuICBjb25zdCBpc0FuRGVzY3JpYmUgPSBub2RlID0+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0TmFtZUZvck5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdkZXNjcmliZSc7XG4gIH07XG5cbiAgLy8gV2hlbiBnaXZlbiBhIG5vZGUgaW4gdGhlIEFTVCwgZG9lcyB0aGlzIHJlcHJlc2VudFxuICAvLyB0aGUgc3RhcnQgb2YgYW4gZXhwZWN0IGV4cHJlc3Npb24/XG4gIGNvbnN0IGlzQW5FeHBlY3QgPSBub2RlID0+IHtcbiAgICBpZiAoIWlzRnVuY3Rpb25DYWxsKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuYW1lID0gJyc7XG4gICAgbGV0IGVsZW1lbnQgPSBub2RlICYmIG5vZGUuZXhwcmVzc2lvbiA/IG5vZGUuZXhwcmVzc2lvbi5jYWxsZWUgOiB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKCFuYW1lICYmIGVsZW1lbnQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgbmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgIC8vIEJlY2F1c2UgZXhwZWN0IG1heSBoYXZlIGFjY2Vzc29ycyB0YWNrZWQgb24gKC50by5iZSkgb3Igbm90aGluZ1xuICAgICAgLy8gKGV4cGVjdCgpKSB3ZSBoYXZlIHRvIGNoZWNrIG11bHRpcGxlIGxldmVscyBmb3IgdGhlIG5hbWVcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9iamVjdCB8fCBlbGVtZW50LmNhbGxlZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgPT09ICdleHBlY3QnO1xuICB9O1xuXG4gIGNvbnN0IGFkZE5vZGUgPSAodHlwZTogUGFyc2VkTm9kZVR5cGUsIHBhcmVudDogUGFyc2VkTm9kZSwgYmFieWxvbk5vZGU6IEJhYnlsb25Ob2RlKTogUGFyc2VkTm9kZSA9PiB7XG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuYWRkQ2hpbGQodHlwZSk7XG4gICAgdXBkYXRlTm9kZShjaGlsZCwgYmFieWxvbk5vZGUpO1xuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTmFtZWRCbG9jayAmJiBjaGlsZC5uYW1lID09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oYGJsb2NrIGlzIG1pc3NpbmcgbmFtZTogJHtKU09OLnN0cmluZ2lmeShiYWJ5bG9uTm9kZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBBIHJlY3Vyc2l2ZSBBU1QgcGFyc2VyXG4gIGNvbnN0IHNlYXJjaE5vZGVzID0gKGJhYnlsb25QYXJlbnQ6IEJhYnlsb25Ob2RlLCBwYXJlbnQ6IFBhcnNlZE5vZGUpID0+IHtcbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIG5vZGUncyBjaGlsZHJlblxuICAgIGxldCBjaGlsZDogP1BhcnNlZE5vZGU7XG5cbiAgICBpZiAoIWJhYnlsb25QYXJlbnQuYm9keSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJhYnlsb25QYXJlbnQuYm9keS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBQdWxsIG91dCB0aGUgbm9kZVxuICAgICAgLy8gY29uc3QgZWxlbWVudCA9IGJhYnlsb25QYXJlbnQuYm9keVtub2RlXTtcblxuICAgICAgaWYgKGlzQW5EZXNjcmliZShlbGVtZW50KSkge1xuICAgICAgICBjaGlsZCA9IGFkZE5vZGUoJ2Rlc2NyaWJlJywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBbkl0KGVsZW1lbnQpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnaXQnLCBwYXJlbnQsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0FuRXhwZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnZXhwZWN0JywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICBlbGVtZW50LmRlY2xhcmF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoZGVjbGFyYXRpb24gPT4gZGVjbGFyYXRpb24uaW5pdCAmJiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaW5pdC50eXBlKSlcbiAgICAgICAgICAuZm9yRWFjaChkZWNsYXJhdGlvbiA9PiBzZWFyY2hOb2RlcyhkZWNsYXJhdGlvbi5pbml0LmJvZHksIHBhcmVudCkpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICBlbGVtZW50LnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJlxuICAgICAgICBlbGVtZW50LmV4cHJlc3Npb24gJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLnR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0ICYmXG4gICAgICAgIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihlbGVtZW50LmV4cHJlc3Npb24ucmlnaHQudHlwZSlcbiAgICAgICkge1xuICAgICAgICBzZWFyY2hOb2RlcyhlbGVtZW50LmV4cHJlc3Npb24ucmlnaHQuYm9keSwgcGFyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50JyAmJiBlbGVtZW50LmFyZ3VtZW50LmFyZ3VtZW50cykge1xuICAgICAgICBlbGVtZW50LmFyZ3VtZW50LmFyZ3VtZW50c1xuICAgICAgICAgIC5maWx0ZXIoYXJndW1lbnQgPT4gaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGFyZ3VtZW50LnR5cGUpKVxuICAgICAgICAgIC5mb3JFYWNoKGFyZ3VtZW50ID0+IHNlYXJjaE5vZGVzKGFyZ3VtZW50LmJvZHksIHBhcmVudCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbkNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLmFyZ3VtZW50c1xuICAgICAgICAgIC5maWx0ZXIoYXJndW1lbnQgPT4gaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGFyZ3VtZW50LnR5cGUpKVxuICAgICAgICAgIC5mb3JFYWNoKGFyZ3VtZW50ID0+IHNlYXJjaE5vZGVzKGFyZ3VtZW50LmJvZHksIGNoaWxkIHx8IHBhcmVudCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHtwcm9ncmFtfSA9IGFzdDtcbiAgc2VhcmNoTm9kZXMocHJvZ3JhbSwgcGFyc2VSZXN1bHQucm9vdCk7XG5cbiAgcmV0dXJuIHBhcnNlUmVzdWx0O1xufTtcbiJdfQ==