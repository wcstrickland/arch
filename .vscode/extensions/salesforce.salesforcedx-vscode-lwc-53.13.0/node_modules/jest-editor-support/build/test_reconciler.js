"use strict";

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *  You have a Jest test runner watching for changes, and you have
 *  an extension that wants to know where to show errors after file parsing.
 *
 *  This class represents the state between runs, keeping track of passes/fails
 *  at a file level, generating useful error messages and providing a nice API.
 */
var TestReconciler = /*#__PURE__*/function () {
  function TestReconciler() {
    _classCallCheck(this, TestReconciler);

    this.fileStatuses = {};
  } // the processed test results will be returned immediately instead of saved in
  // instance properties. This is 1) to prevent race condition 2) the data is already
  // stored in the this.fileStatuses, no dup is better 3) client will most likely need to process
  // all the results anyway.


  _createClass(TestReconciler, [{
    key: "updateFileWithJestStatus",
    value: function updateFileWithJestStatus(results) {
      var _this = this;

      // Loop through all files inside the report from Jest
      var statusList = [];
      results.testResults.forEach(function (file) {
        // Did the file pass/fail?
        var status = _this.statusToReconcilationState(file.status); // Create our own simpler representation


        var fileStatus = {
          assertions: _this.mapAssertions(file.name, file.assertionResults),
          file: file.name,
          message: file.message,
          status: status
        };
        _this.fileStatuses[file.name] = fileStatus;
        statusList.push(fileStatus);
      });
      return statusList;
    }
    /**
     * remove jest status of the test file from the cached results
     * @param {string} fileName
     */

  }, {
    key: "removeTestFile",
    value: function removeTestFile(fileName) {
      delete this.fileStatuses[fileName];
    } // A failed test also contains the stack trace for an `expect`
    // we don't get this as structured data, but what we get
    // is useful enough to make it for ourselves

  }, {
    key: "mapAssertions",
    value: function mapAssertions(filename, assertions) {
      var _this2 = this;

      // convert jest location (column is 0-based and line is 1-based) to all 0-based location used internally in this package

      /* eslint-disable no-param-reassign */
      var convertJestLocation = function convertJestLocation(jestLocation) {
        if (jestLocation) {
          jestLocation.line -= 1;
        }

        return jestLocation;
      }; // Is it jest < 17? e.g. Before I added this to the JSON


      if (!assertions) {
        return [];
      } // Change all failing assertions into structured data


      return assertions.map(function (assertion) {
        // Failure messages seems to always be an array of one item
        var message = assertion.failureMessages && assertion.failureMessages[0];
        var _short = null;
        var terse = null;
        var line = null;
        var location = convertJestLocation(assertion.location); // output from jest --testLocationInResults (https://jestjs.io/docs/en/cli#testlocationinresults)

        if (message) {
          // Just the first line, with little whitespace
          _short = message.split('   at', 1)[0].trim(); // this will show inline, so we want to show very little

          terse = _this2.sanitizeShortErrorMessage(_short);
          line = _this2.lineOfError(message, filename);
        }

        return {
          line: line,
          message: message || '',
          shortMessage: _short,
          status: _this2.statusToReconcilationState(assertion.status),
          terseMessage: terse,
          title: assertion.title,
          location: location,
          fullName: assertion.fullName,
          ancestorTitles: assertion.ancestorTitles
        };
      });
    } // Do everything we can to try make a one-liner from the error report

  }, {
    key: "sanitizeShortErrorMessage",
    value: function sanitizeShortErrorMessage(string) {
      if (string.includes('does not match stored snapshot')) {
        return 'Snapshot has changed';
      }

      if (string.includes('New snapshot was not written')) {
        return 'New snapshot is ready to write';
      }

      return string.split('\n').splice(2).join('').replace(/\s\s+/g, ' ').replace('Received:', ', Received:').split('Difference:')[0];
    } // Pull the line out from the stack trace

  }, {
    key: "lineOfError",
    value: function lineOfError(message, filePath) {
      var filename = _path["default"].basename(filePath);

      var restOfTrace = message.split(filename, 2)[1];
      return restOfTrace ? parseInt(restOfTrace.split(':')[1], 10) : null;
    }
  }, {
    key: "statusToReconcilationState",
    value: function statusToReconcilationState(status) {
      switch (status) {
        case 'passed':
          return 'KnownSuccess';

        case 'failed':
          return 'KnownFail';

        case 'pending':
          return 'KnownSkip';

        case 'todo':
          return 'KnownTodo';

        default:
          return 'Unknown';
      }
    }
  }, {
    key: "stateForTestFile",
    value: function stateForTestFile(file) {
      var results = this.fileStatuses[file];

      if (!results) {
        return 'Unknown';
      }

      return results.status;
    }
  }, {
    key: "assertionsForTestFile",
    value: function assertionsForTestFile(file) {
      var results = this.fileStatuses[file];
      return results ? results.assertions : null;
    }
  }, {
    key: "stateForTestAssertion",
    value: function stateForTestAssertion(file, name) {
      var results = this.fileStatuses[file];

      if (!results || !results.assertions) {
        return null;
      }

      var assertion = results.assertions.find(function (a) {
        return a.title === name;
      });

      if (!assertion) {
        return null;
      }

      return assertion;
    }
  }]);

  return TestReconciler;
}();

exports["default"] = TestReconciler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZXN0X3JlY29uY2lsZXIuanMiXSwibmFtZXMiOlsiVGVzdFJlY29uY2lsZXIiLCJmaWxlU3RhdHVzZXMiLCJyZXN1bHRzIiwic3RhdHVzTGlzdCIsInRlc3RSZXN1bHRzIiwiZm9yRWFjaCIsImZpbGUiLCJzdGF0dXMiLCJzdGF0dXNUb1JlY29uY2lsYXRpb25TdGF0ZSIsImZpbGVTdGF0dXMiLCJhc3NlcnRpb25zIiwibWFwQXNzZXJ0aW9ucyIsIm5hbWUiLCJhc3NlcnRpb25SZXN1bHRzIiwibWVzc2FnZSIsInB1c2giLCJmaWxlTmFtZSIsImZpbGVuYW1lIiwiY29udmVydEplc3RMb2NhdGlvbiIsImplc3RMb2NhdGlvbiIsImxpbmUiLCJtYXAiLCJhc3NlcnRpb24iLCJmYWlsdXJlTWVzc2FnZXMiLCJzaG9ydCIsInRlcnNlIiwibG9jYXRpb24iLCJzcGxpdCIsInRyaW0iLCJzYW5pdGl6ZVNob3J0RXJyb3JNZXNzYWdlIiwibGluZU9mRXJyb3IiLCJzaG9ydE1lc3NhZ2UiLCJ0ZXJzZU1lc3NhZ2UiLCJ0aXRsZSIsImZ1bGxOYW1lIiwiYW5jZXN0b3JUaXRsZXMiLCJzdHJpbmciLCJpbmNsdWRlcyIsInNwbGljZSIsImpvaW4iLCJyZXBsYWNlIiwiZmlsZVBhdGgiLCJwYXRoIiwiYmFzZW5hbWUiLCJyZXN0T2ZUcmFjZSIsInBhcnNlSW50IiwiZmluZCIsImEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7OztBQUtBOzs7Ozs7O0lBT3FCQSxjO0FBR25CLDRCQUFjO0FBQUE7O0FBQ1osU0FBS0MsWUFBTCxHQUFvQixFQUFwQjtBQUNELEcsQ0FFRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7NkNBQ3lCQyxPLEVBQTBEO0FBQUE7O0FBQ2pGO0FBQ0EsVUFBTUMsVUFBcUMsR0FBRyxFQUE5QztBQUNBRCxNQUFBQSxPQUFPLENBQUNFLFdBQVIsQ0FBb0JDLE9BQXBCLENBQTRCLFVB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QUNEOztBQUNELGFBQU9BLE9BQU8sQ0FBQ0ssTUFBZjtBQUNEOzs7MENBRXFCRCxJLEVBQTRDO0FBQ2hFLFVBQU1KLE9BQU8sR0FBRyxLQUFLRCxZQUFMLENBQWtCSyxJQUFsQixDQUFoQjtBQUNBLGFBQU9KLE9BQU8sR0FBR0EsT0FBTyxDQUFDUSxVQUFYLEdBQXdCLElBQXRDO0FBQ0Q7OzswQ0FFcUJKLEksRUFBY00sSSxFQUEwQztBQUM1RSxVQUFNVixPQUFPLEdBQUcsS0FBS0QsWUFBTCxDQUFrQkssSUFBbEIsQ0FBaEI7O0FBQ0EsVUFBSSxDQUFDSixPQUFELElBQVksQ0FBQ0EsT0FBTyxDQUFDUSxVQUF6QixFQUFxQztBQUNuQyxlQUFPLElBQVA7QUFDRDs7QUFDRCxVQUFNWSxTQUFTLEdBQUdwQixPQUFPLENBQUNRLFVBQVIsQ0FBbUJvQyxJQUFuQixDQUF3QixVQUFBQyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDZCxLQUFGLEtBQVlyQixJQUFoQjtBQUFBLE9BQXpCLENBQWxCOztBQUNBLFVBQUksQ0FBQ1UsU0FBTCxFQUFnQjtBQUNkLGVBQU8sSUFBUDtBQUNEOztBQUNELGFBQU9BLFNBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0eXBlIHtUZXN0RmlsZUFzc2VydGlvblN0YXR1cywgVGVzdEFzc2VydGlvblN0YXR1cywgVGVzdFJlY29uY2lsaWF0aW9uU3RhdGUsIExvY2F0aW9ufSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHR5cGUge0Zvcm1hdHRlZEFzc2VydGlvblJlc3VsdCwgRm9ybWF0dGVkVGVzdFJlc3VsdHN9IGZyb20gJy4uL3R5cGVzL1Rlc3RSZXN1bHQnO1xuXG4vKipcbiAqICBZb3UgaGF2ZSBhIEplc3QgdGVzdCBydW5uZXIgd2F0Y2hpbmcgZm9yIGNoYW5nZXMsIGFuZCB5b3UgaGF2ZVxuICogIGFuIGV4dGVuc2lvbiB0aGF0IHdhbnRzIHRvIGtub3cgd2hlcmUgdG8gc2hvdyBlcnJvcnMgYWZ0ZXIgZmlsZSBwYXJzaW5nLlxuICpcbiAqICBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIHN0YXRlIGJldHdlZW4gcnVucywga2VlcGluZyB0cmFjayBvZiBwYXNzZXMvZmFpbHNcbiAqICBhdCBhIGZpbGUgbGV2ZWwsIGdlbmVyYXRpbmcgdXNlZnVsIGVycm9yIG1lc3NhZ2VzIGFuZCBwcm92aWRpbmcgYSBuaWNlIEFQSS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVzdFJlY29uY2lsZXIge1xuICBmaWxlU3RhdHVzZXM6IHtba2V5OiBzdHJpbmddOiBUZXN0RmlsZUFzc2VydGlvblN0YXR1c307XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maWxlU3RhdHVzZXMgPSB7fTtcbiAgfVxuXG4gIC8vIHRoZSBwcm9jZXNzZWQgdGVzdCByZXN1bHRzIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiBzYXZlZCBpblxuICAvLyBpbnN0YW5jZSBwcm9wZXJ0aWVzLiBUaGlzIGlzIDEpIHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb24gMikgdGhlIGRhdGEgaXMgYWxyZWFkeVxuICAvLyBzdG9yZWQgaW4gdGhlIHRoaXMuZmlsZVN0YXR1c2VzLCBubyBkdXAgaXMgYmV0dGVyIDMpIGNsaWVudCB3aWxsIG1vc3QgbGlrZWx5IG5lZWQgdG8gcHJvY2Vzc1xuICAvLyBhbGwgdGhlIHJlc3VsdHMgYW55d2F5LlxuICB1cGRhdGVGaWxlV2l0aEplc3RTdGF0dXMocmVzdWx0czogRm9ybWF0dGVkVGVzdFJlc3VsdHMpOiBUZXN0RmlsZUFzc2VydGlvblN0YXR1c1tdIHtcbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIGZpbGVzIGluc2lkZSB0aGUgcmVwb3J0IGZyb20gSmVzdFxuICAgIGNvbnN0IHN0YXR1c0xpc3Q6IFRlc3RGaWxlQXNzZXJ0aW9uU3RhdHVzW10gPSBbXTtcbiAgICByZXN1bHRzLnRlc3RSZXN1bHRzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAvLyBEaWQgdGhlIGZpbGUgcGFzcy9mYWlsP1xuICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5zdGF0dXNUb1JlY29uY2lsYXRpb25TdGF0ZShmaWxlLnN0YXR1cyk7XG4gICAgICAvLyBDcmVhdGUgb3VyIG93biBzaW1wbGVyIHJlcHJlc2VudGF0aW9uXG4gICAgICBjb25zdCBmaWxlU3RhdHVzOiBUZXN0RmlsZUFzc2VydGlvblN0YXR1cyA9IHtcbiAgICAgICAgYXNzZXJ0aW9uczogdGhpcy5tYXBBc3NlcnRpb25zKGZpbGUubmFtZSwgZmlsZS5hc3NlcnRpb25SZXN1bHRzKSxcbiAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICBtZXNzYWdlOiBmaWxlLm1lc3NhZ2UsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgIH07XG4gICAgICB0aGlzLmZpbGVTdGF0dXNlc1tmaWxlLm5hbWVdID0gZmlsZVN0YXR1cztcbiAgICAgIHN0YXR1c0xpc3QucHVzaChmaWxlU3RhdHVzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHVzTGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgamVzdCBzdGF0dXMgb2YgdGhlIHRlc3QgZmlsZSBmcm9tIHRoZSBjYWNoZWQgcmVzdWx0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWVcbiAgICovXG4gIHJlbW92ZVRlc3RGaWxlKGZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICBkZWxldGUgdGhpcy5maWxlU3RhdHVzZXNbZmlsZU5hbWVdO1xuICB9XG5cbiAgLy8gQSBmYWlsZWQgdGVzdCBhbHNvIGNvbnRhaW5zIHRoZSBzdGFjayB0cmFjZSBmb3IgYW4gYGV4cGVjdGBcbiAgLy8gd2UgZG9uJ3QgZ2V0IHRoaXMgYXMgc3RydWN0dXJlZCBkYXRhLCBidXQgd2hhdCB3ZSBnZXRcbiAgLy8gaXMgdXNlZnVsIGVub3VnaCB0byBtYWtlIGl0IGZvciBvdXJzZWx2ZXNcblxuICBtYXBBc3NlcnRpb25zKGZpbGVuYW1lOiBzdHJpbmcsIGFzc2VydGlvbnM6IEFycmF5PEZvcm1hdHRlZEFzc2VydGlvblJlc3VsdD4pOiBBcnJheTxUZXN0QXNzZXJ0aW9uU3RhdHVzPiB7XG4gICAgLy8gY29udmVydCBqZXN0IGxvY2F0aW9uIChjb2x1bW4gaXMgMC1iYXNlZCBhbmQgbGluZSBpcyAxLWJhc2VkKSB0byBhbGwgMC1iYXNlZCBsb2NhdGlvbiB1c2VkIGludGVybmFsbHkgaW4gdGhpcyBwYWNrYWdlXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBjb25zdCBjb252ZXJ0SmVzdExvY2F0aW9uID0gKGplc3RMb2NhdGlvbjogP0xvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoamVzdExvY2F0aW9uKSB7XG4gICAgICAgIGplc3RMb2NhdGlvbi5saW5lIC09IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gamVzdExvY2F0aW9uO1xuICAgIH07XG4gICAgLy8gSXMgaXQgamVzdCA8IDE3PyBlLmcuIEJlZm9yZSBJIGFkZGVkIHRoaXMgdG8gdGhlIEpTT05cbiAgICBpZiAoIWFzc2VydGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgYWxsIGZhaWxpbmcgYXNzZXJ0aW9ucyBpbnRvIHN0cnVjdHVyZWQgZGF0YVxuICAgIHJldHVybiBhc3NlcnRpb25zLm1hcChhc3NlcnRpb24gPT4ge1xuICAgICAgLy8gRmFpbHVyZSBtZXNzYWdlcyBzZWVtcyB0byBhbHdheXMgYmUgYW4gYXJyYXkgb2Ygb25lIGl0ZW1cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhc3NlcnRpb24uZmFpbHVyZU1lc3NhZ2VzICYmIGFzc2VydGlvbi5mYWlsdXJlTWVzc2FnZXNbMF07XG4gICAgICBsZXQgc2hvcnQgPSBudWxsO1xuICAgICAgbGV0IHRlcnNlID0gbnVsbDtcbiAgICAgIGxldCBsaW5lID0gbnVsbDtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gY29udmVydEplc3RMb2NhdGlvbihhc3NlcnRpb24ubG9jYXRpb24pOyAvLyBvdXRwdXQgZnJvbSBqZXN0IC0tdGVzdExvY2F0aW9uSW5SZXN1bHRzIChodHRwczovL2plc3Rqcy5pby9kb2NzL2VuL2NsaSN0ZXN0bG9jYXRpb25pbnJlc3VsdHMpXG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAvLyBKdXN0IHRoZSBmaXJzdCBsaW5lLCB3aXRoIGxpdHRsZSB3aGl0ZXNwYWNlXG4gICAgICAgIHNob3J0ID0gbWVzc2FnZS5zcGxpdCgnICAgYXQnLCAxKVswXS50cmltKCk7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBzaG93IGlubGluZSwgc28gd2Ugd2FudCB0byBzaG93IHZlcnkgbGl0dGxlXG4gICAgICAgIHRlcnNlID0gdGhpcy5zYW5pdGl6ZVNob3J0RXJyb3JNZXNzYWdlKHNob3J0KTtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZU9mRXJyb3IobWVzc2FnZSwgZmlsZW5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCAnJyxcbiAgICAgICAgc2hvcnRNZXNzYWdlOiBzaG9ydCxcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1RvUmVjb25jaWxhdGlvblN0YXRlKGFzc2VydGlvbi5zdGF0dXMpLFxuICAgICAgICB0ZXJzZU1lc3NhZ2U6IHRlcnNlLFxuICAgICAgICB0aXRsZTogYXNzZXJ0aW9uLnRpdGxlLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZnVsbE5hbWU6IGFzc2VydGlvbi5mdWxsTmFtZSxcbiAgICAgICAgYW5jZXN0b3JUaXRsZXM6IGFzc2VydGlvbi5hbmNlc3RvclRpdGxlcyxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBEbyBldmVyeXRoaW5nIHdlIGNhbiB0byB0cnkgbWFrZSBhIG9uZS1saW5lciBmcm9tIHRoZSBlcnJvciByZXBvcnRcbiAgc2FuaXRpemVTaG9ydEVycm9yTWVzc2FnZShzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHN0cmluZy5pbmNsdWRlcygnZG9lcyBub3QgbWF0Y2ggc3RvcmVkIHNuYXBzaG90JykpIHtcbiAgICAgIHJldHVybiAnU25hcHNob3QgaGFzIGNoYW5nZWQnO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ05ldyBzbmFwc2hvdCB3YXMgbm90IHdyaXR0ZW4nKSkge1xuICAgICAgcmV0dXJuICdOZXcgc25hcHNob3QgaXMgcmVhZHkgdG8gd3JpdGUnO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5zcGxpY2UoMilcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKVxuICAgICAgLnJlcGxhY2UoJ1JlY2VpdmVkOicsICcsIFJlY2VpdmVkOicpXG4gICAgICAuc3BsaXQoJ0RpZmZlcmVuY2U6JylbMF07XG4gIH1cblxuICAvLyBQdWxsIHRoZSBsaW5lIG91dCBmcm9tIHRoZSBzdGFjayB0cmFjZVxuICBsaW5lT2ZFcnJvcihtZXNzYWdlOiBzdHJpbmcsIGZpbGVQYXRoOiBzdHJpbmcpOiA/bnVtYmVyIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgIGNvbnN0IHJlc3RPZlRyYWNlID0gbWVzc2FnZS5zcGxpdChmaWxlbmFtZSwgMilbMV07XG4gICAgcmV0dXJuIHJlc3RPZlRyYWNlID8gcGFyc2VJbnQocmVzdE9mVHJhY2Uuc3BsaXQoJzonKVsxXSwgMTApIDogbnVsbDtcbiAgfVxuXG4gIHN0YXR1c1RvUmVjb25jaWxhdGlvblN0YXRlKHN0YXR1czogc3RyaW5nKTogVGVzdFJlY29uY2lsaWF0aW9uU3RhdGUge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlICdwYXNzZWQnOlxuICAgICAgICByZXR1cm4gJ0tub3duU3VjY2Vzcyc7XG4gICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICByZXR1cm4gJ0tub3duRmFpbCc7XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgcmV0dXJuICdLbm93blNraXAnO1xuICAgICAgY2FzZSAndG9kbyc6XG4gICAgICAgIHJldHVybiAnS25vd25Ub2RvJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9XG5cbiAgc3RhdGVGb3JUZXN0RmlsZShmaWxlOiBzdHJpbmcpOiBUZXN0UmVjb25jaWxpYXRpb25TdGF0ZSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZmlsZVN0YXR1c2VzW2ZpbGVdO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuc3RhdHVzO1xuICB9XG5cbiAgYXNzZXJ0aW9uc0ZvclRlc3RGaWxlKGZpbGU6IHN0cmluZyk6IFRlc3RBc3NlcnRpb25TdGF0dXNbXSB8IG51bGwge1xuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmZpbGVTdGF0dXNlc1tmaWxlXTtcbiAgICByZXR1cm4gcmVzdWx0cyA/IHJlc3VsdHMuYXNzZXJ0aW9ucyA6IG51bGw7XG4gIH1cblxuICBzdGF0ZUZvclRlc3RBc3NlcnRpb24oZmlsZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBUZXN0QXNzZXJ0aW9uU3RhdHVzIHwgbnVsbCB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZmlsZVN0YXR1c2VzW2ZpbGVdO1xuICAgIGlmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5hc3NlcnRpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYXNzZXJ0aW9uID0gcmVzdWx0cy5hc3NlcnRpb25zLmZpbmQoYSA9PiBhLnRpdGxlID09PSBuYW1lKTtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhc3NlcnRpb247XG4gIH1cbn1cbiJdfQ==