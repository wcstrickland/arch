"use strict";

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.replace");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProjectWorkspace = exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Represents the project that the extension is running on and it's state
 */
var ProjectWorkspace = /*#__PURE__*/function () {
  _createClass(ProjectWorkspace, [{
    key: "pathToJest",

    /**
     * The path to the root of the project's workspace
     *
     * @type {string}
     */

    /**
     * The command to execute Jest on the command line, this is normally a file path like
     * `node_modules/.bin/jest` but you should not make the assumption that it is always a direct
     * file path, as in a create-react app it would look like `npm test --`.
     *
     * This means when launching a process, you will need to split on the first
     * space, and then move any other args into the args of the process.
     *
     * @type {string}
     */

    /**
     * @deprecated please use `jestCommandLine` instead.
     *
     * @type {string?}
     */
    get: function get() {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      return this.jestCommandLine;
    },
    set: function set(commandLine) {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      this.jestCommandLine = commandLine;
    }
    /**
     * Path to a local Jest config file.
     *
     * @type {string}
     */

  }]);

  function ProjectWorkspace(rootPath, jestCommandLine, pathToConfig, localJestMajorVersion, outputFileSuffix, collectCoverage, debug, nodeEnv) {
    _classCallCheck(this, ProjectWorkspace);

    this.rootPath = rootPath;
    this.jestCommandLine = jestCommandLine;
    this.pathToConfig = pathToConfig;
    this.localJestMajorVersion = localJestMajorVersion;
    this.outputFileSuffix = outputFileSuffix ? outputFileSuffix.replace(/[^a-z0-9]/gi, '_').toLowerCase() : undefined;
    this.collectCoverage = collectCoverage;
    this.debug = debug;
    this.nodeEnv = nodeEnv;
  }

  return ProjectWorkspace;
}();
/**
 * A factory to create a ProjectWorkspace instance from a ProjectWorkspaceConfig object.
 */


exports["default"] = ProjectWorkspace;

var createProjectWorkspace = function createProjectWorkspace(config) {
  // Note for pathToConfig we are forcing the TS compiler to accept undefined for ProjectWorkspace.pathToConfig.
  // This property should be allowed to be optional, since Jest will work fine if no config file is provided.  It
  // will just use defaults.
  return new ProjectWorkspace(config.rootPath, config.jestCommandLine, config.pathToConfig, config.localJestMajorVersion, config.outputFileSuffix, config.collectCoverage, config.debug, config.nodeEnv);
};

exports.createProjectWorkspace = createProjectWorkspace;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9qZWN0X3dvcmtzcGFjZS50cyJdLCJuYW1lcyI6WyJQcm9qZWN0V29ya3NwYWNlIiwiY29uc29sZSIsIndhcm4iLCJqZXN0Q29tbWFuZExpbmUiLCJjb21tYW5kTGluZSIsInJvb3RQYXRoIiwicGF0aFRvQ29uZmlnIiwibG9jYWxKZXN0TWFqb3JWZXJzaW9uIiwib3V0cHV0RmlsZVN1ZmZpeCIsImNvbGxlY3RDb3ZlcmFnZSIsImRlYnVnIiwibm9kZUVudiIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsImNyZWF0ZVByb2plY3RXb3Jrc3BhY2UiLCJjb25maWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFtQkE7OztJQUdxQkEsZ0I7Ozs7QUFDbkI7Ozs7OztBQU9BOzs7Ozs7Ozs7OztBQVlBOzs7Ozt3QkFLaUI7QUFDZjtBQUNBQyxNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSx3RkFBYjtBQUNBLGFBQU8sS0FBS0MsZUFBWjtBQUNELEs7c0JBRWNDLFcsRUFBcUI7QUFDbEM7QUFDQUgsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsd0ZBQWI7QUFDQSxXQUFLQyxlQUFMLEdBQXVCQyxXQUF2QjtBQUNEO0FBRUQ7Ozs7Ozs7O0FBMENBLDRCQUNFQyxRQURGLEVBRUVGLGVBRkYsRUFHRUcsWUFIRixFQUlFQyxxQkFKRixFQUtFQyxnQkFMRixFQU1FQyxlQU5GLEVBT0VDLEtBUEYsRUFRRUMsT0FSRixFQVNFO0FBQUE7O0FBQ0EsU0FBS04sUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLRixlQUFMLEdBQXVCQSxlQUF2QjtBQUNBLFNBQUtHLFlBQUwsR0FBb0JBLFlBQXBCO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkJBLHFCQUE3QjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLENBQUNJLE9BQWpCLENBQXlCLGFBQXpCLEVBQXdDLEdBQXhDLEVBQTZDQyxXQUE3QyxFQUFILEdBQWdFQyxTQUF4RztBQUNBLFNBQUtMLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7Ozs7QUFHSDs7Ozs7OztBQUdPLElBQU1JLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBeUIsQ0FBQ0MsTUFBRCxFQUFzRDtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxTQUFPLElBQUloQixnQkFBSixDQUNMZ0IsTUFBTSxDQUFDWCxRQURGLEVBRUxXLE1BQU0sQ0FBQ2IsZUFGRixFQUdKYSxNQUFNLENBQUNWLFlBSEgsRUFJTFUsTUFBTSxDQUFDVCxxQkFKRixFQUtMUyxNQUFNLENBQUNSLGdCQUxGLEVBTUxRLE1BQU0sQ0FBQ1AsZUFORixFQU9MTyxNQUFNLENBQUNOLEtBUEYsRUFRTE0sTUFBTSxDQUFDTCxPQVJGLENBQVA7QUFVRCxDQWRNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0V29ya3NwYWNlQ29uZmlnIHtcbiAgamVzdENvbW1hbmRMaW5lOiBzdHJpbmc7XG4gIHBhdGhUb0NvbmZpZz86IHN0cmluZztcbiAgcm9vdFBhdGg6IHN0cmluZztcbiAgbG9jYWxKZXN0TWFqb3JWZXJzaW9uOiBudW1iZXI7XG4gIG91dHB1dEZpbGVTdWZmaXg/OiBzdHJpbmc7XG4gIGNvbGxlY3RDb3ZlcmFnZT86IGJvb2xlYW47XG4gIGRlYnVnPzogYm9vbGVhbjtcbiAgbm9kZUVudj86IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHByb2plY3QgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIHJ1bm5pbmcgb24gYW5kIGl0J3Mgc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdFdvcmtzcGFjZSB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgcm9vdCBvZiB0aGUgcHJvamVjdCdzIHdvcmtzcGFjZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcm9vdFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbW1hbmQgdG8gZXhlY3V0ZSBKZXN0IG9uIHRoZSBjb21tYW5kIGxpbmUsIHRoaXMgaXMgbm9ybWFsbHkgYSBmaWxlIHBhdGggbGlrZVxuICAgKiBgbm9kZV9tb2R1bGVzLy5iaW4vamVzdGAgYnV0IHlvdSBzaG91bGQgbm90IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCBpdCBpcyBhbHdheXMgYSBkaXJlY3RcbiAgICogZmlsZSBwYXRoLCBhcyBpbiBhIGNyZWF0ZS1yZWFjdCBhcHAgaXQgd291bGQgbG9vayBsaWtlIGBucG0gdGVzdCAtLWAuXG4gICAqXG4gICAqIFRoaXMgbWVhbnMgd2hlbiBsYXVuY2hpbmcgYSBwcm9jZXNzLCB5b3Ugd2lsbCBuZWVkIHRvIHNwbGl0IG9uIHRoZSBmaXJzdFxuICAgKiBzcGFjZSwgYW5kIHRoZW4gbW92ZSBhbnkgb3RoZXIgYXJncyBpbnRvIHRoZSBhcmdzIG9mIHRoZSBwcm9jZXNzLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgamVzdENvbW1hbmRMaW5lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgYGplc3RDb21tYW5kTGluZWAgaW5zdGVhZC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZz99XG4gICAqL1xuICBnZXQgcGF0aFRvSmVzdCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignVXNlIG9mIFByb2plY3RXb3Jrc3BhY2UucGF0aFRvSmVzdCBpcyBkZXByZWNhdGVkLiAgUGxlYXNlIHVzZSBqZXN0Q29tbWFuZExpbmUgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy5qZXN0Q29tbWFuZExpbmU7XG4gIH1cblxuICBzZXQgcGF0aFRvSmVzdChjb21tYW5kTGluZTogc3RyaW5nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ1VzZSBvZiBQcm9qZWN0V29ya3NwYWNlLnBhdGhUb0plc3QgaXMgZGVwcmVjYXRlZC4gIFBsZWFzZSB1c2UgamVzdENvbW1hbmRMaW5lIGluc3RlYWQuJyk7XG4gICAgdGhpcy5qZXN0Q29tbWFuZExpbmUgPSBjb21tYW5kTGluZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGEgbG9jYWwgSmVzdCBjb25maWcgZmlsZS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHBhdGhUb0NvbmZpZzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBsb2NhbCBKZXN0IG1ham9yIHJlbGVhc2UgdmVyc2lvbiwgYXMgdGhlIHJ1bm5lciBjb3VsZCBydW4gYWdhaW5zdFxuICAgKiBhbnkgdmVyc2lvbiBvZiBKZXN0LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbG9jYWxKZXN0TWFqb3JWZXJzaW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGVzdCBjb3ZlcmFnZSBzaG91bGQgYmUgKGF1dG9tYXRpY2FsbHkpIGNvbGxlY3RlZC5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjb2xsZWN0Q292ZXJhZ2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBpZiB0byBvdXRwdXQgbW9yZSBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2UuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZGVidWc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdWZmaXggc3RyaW5nIHVzZWQgYXMgcGFydCBvZiB0aGUgb3V0cHV0IGZpbGUgcGF0aCwgdGhpcyBpcyB0byBzdXBwb3J0IGNvbmN1cnJlbnQgUnVubmVycy5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFByb2plY3RXb3Jrc3BhY2VcbiAgICovXG4gIG91dHB1dEZpbGVTdWZmaXg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG9wdGlvbmFsIGFkZGl0aW9uYWwgbm9kZSBlbnYgdmFyaWFibGVzXG4gICAqL1xuICBub2RlRW52Pzoge1trZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcm9vdFBhdGg6IHN0cmluZyxcbiAgICBqZXN0Q29tbWFuZExpbmU6IHN0cmluZyxcbiAgICBwYXRoVG9Db25maWc6IHN0cmluZyxcbiAgICBsb2NhbEplc3RNYWpvclZlcnNpb246IG51bWJlcixcbiAgICBvdXRwdXRGaWxlU3VmZml4Pzogc3RyaW5nLFxuICAgIGNvbGxlY3RDb3ZlcmFnZT86IGJvb2xlYW4sXG4gICAgZGVidWc/OiBib29sZWFuLFxuICAgIG5vZGVFbnY/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkfVxuICApIHtcbiAgICB0aGlzLnJvb3RQYXRoID0gcm9vdFBhdGg7XG4gICAgdGhpcy5qZXN0Q29tbWFuZExpbmUgPSBqZXN0Q29tbWFuZExpbmU7XG4gICAgdGhpcy5wYXRoVG9Db25maWcgPSBwYXRoVG9Db25maWc7XG4gICAgdGhpcy5sb2NhbEplc3RNYWpvclZlcnNpb24gPSBsb2NhbEplc3RNYWpvclZlcnNpb247XG4gICAgdGhpcy5vdXRwdXRGaWxlU3VmZml4ID0gb3V0cHV0RmlsZVN1ZmZpeCA/IG91dHB1dEZpbGVTdWZmaXgucmVwbGFjZSgvW15hLXowLTldL2dpLCAnXycpLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xsZWN0Q292ZXJhZ2UgPSBjb2xsZWN0Q292ZXJhZ2U7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIHRoaXMubm9kZUVudiA9IG5vZGVFbnY7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGZhY3RvcnkgdG8gY3JlYXRlIGEgUHJvamVjdFdvcmtzcGFjZSBpbnN0YW5jZSBmcm9tIGEgUHJvamVjdFdvcmtzcGFjZUNvbmZpZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9qZWN0V29ya3NwYWNlID0gKGNvbmZpZzogUHJvamVjdFdvcmtzcGFjZUNvbmZpZyk6IFByb2plY3RXb3Jrc3BhY2UgPT4ge1xuICAvLyBOb3RlIGZvciBwYXRoVG9Db25maWcgd2UgYXJlIGZvcmNpbmcgdGhlIFRTIGNvbXBpbGVyIHRvIGFjY2VwdCB1bmRlZmluZWQgZm9yIFByb2plY3RXb3Jrc3BhY2UucGF0aFRvQ29uZmlnLlxuICAvLyBUaGlzIHByb3BlcnR5IHNob3VsZCBiZSBhbGxvd2VkIHRvIGJlIG9wdGlvbmFsLCBzaW5jZSBKZXN0IHdpbGwgd29yayBmaW5lIGlmIG5vIGNvbmZpZyBmaWxlIGlzIHByb3ZpZGVkLiAgSXRcbiAgLy8gd2lsbCBqdXN0IHVzZSBkZWZhdWx0cy5cbiAgcmV0dXJuIG5ldyBQcm9qZWN0V29ya3NwYWNlKFxuICAgIGNvbmZpZy5yb290UGF0aCxcbiAgICBjb25maWcuamVzdENvbW1hbmRMaW5lLFxuICAgIChjb25maWcucGF0aFRvQ29uZmlnIGFzIHVua25vd24pIGFzIHN0cmluZyxcbiAgICBjb25maWcubG9jYWxKZXN0TWFqb3JWZXJzaW9uLFxuICAgIGNvbmZpZy5vdXRwdXRGaWxlU3VmZml4LFxuICAgIGNvbmZpZy5jb2xsZWN0Q292ZXJhZ2UsXG4gICAgY29uZmlnLmRlYnVnLFxuICAgIGNvbmZpZy5ub2RlRW52XG4gICk7XG59O1xuIl19