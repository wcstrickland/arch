"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDeploy = void 0;
const graceful_fs_1 = require("graceful-fs");
const path_1 = require("path");
const errors_1 = require("../../errors");
// tslint:disable-next-line:no-var-requires
const DOMParser = require('xmldom-sfdx-encoding').DOMParser;
class BaseDeploy {
    constructor(connection) {
        this.connection = connection;
    }
    buildMetadataField(metadataContent) {
        try {
            const parser = new DOMParser();
            const document = parser.parseFromString(metadataContent, 'text/xml');
            const apiVersion = document.getElementsByTagName('apiVersion')[0].textContent;
            const statusNode = document.getElementsByTagName('status')[0];
            const packageNode = document.getElementsByTagName('packageVersions')[0];
            const descriptionNode = document.getElementsByTagName('description')[0];
            const labelNode = document.getElementsByTagName('label')[0];
            const metadataField = Object.assign(Object.assign(Object.assign(Object.assign({ apiVersion }, (statusNode ? { status: statusNode.textContent } : {})), (packageNode ? { packageVersions: packageNode.textContent } : {})), (descriptionNode ? { description: descriptionNode.textContent } : {})), (labelNode ? { label: labelNode.textContent } : {}));
            return metadataField;
        }
        catch (e) {
            throw new errors_1.DeployError('error_parsing_metadata_file');
        }
    }
    // If bundle already exists then use Id and update existing
    // else, create a new bundle
    upsertBundle(Id) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataContent = graceful_fs_1.readFileSync(this.component.xml, 'utf8');
            const metadataField = this.buildMetadataField(metadataContent);
            let bundleResult;
            if (Id) {
                const bundleObject = { Id, Metadata: metadataField };
                bundleResult = (yield this.connection.tooling.update(this.component.type.name, bundleObject));
            }
            else {
                const bundleObject = {
                    FullName: this.component.fullName,
                    Metadata: metadataField,
                };
                bundleResult = yield this.toolingCreate(this.component.type.name, bundleObject);
            }
            if (!bundleResult.success) {
                throw new errors_1.DeployError('error_creating_metadata_type', this.component.type.name);
            }
            return bundleResult;
        });
    }
    toolingCreate(type, record) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.connection.tooling.create(type, record));
        });
    }
    getFormattedPaths(filepath) {
        const pathParts = filepath.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex((part) => part === this.component.type.directoryName);
        return [
            pathParts.slice(typeFolderIndex).join(BaseDeploy.TOOLING_PATH_SEP),
            pathParts.slice(typeFolderIndex + 1).join(BaseDeploy.TOOLING_PATH_SEP),
        ];
    }
}
exports.BaseDeploy = BaseDeploy;
BaseDeploy.TOOLING_PATH_SEP = '/';
//# sourceMappingURL=baseDeploy.js.map