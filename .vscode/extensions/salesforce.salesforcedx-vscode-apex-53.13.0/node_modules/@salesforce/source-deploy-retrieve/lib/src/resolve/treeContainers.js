"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualTreeContainer = exports.ZipTreeContainer = exports.NodeFSTreeContainer = exports.TreeContainer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const utils_1 = require("../utils");
const graceful_fs_1 = require("graceful-fs");
const errors_1 = require("../errors");
const unzipper = require("unzipper");
/**
 * A container for interacting with a file system. Operations such as component resolution,
 * conversion, and packaging perform I/O against `TreeContainer` abstractions.
 *
 * Extend this base class to implement a custom container.
 */
class TreeContainer {
    /**
     * Searches for a metadata component file in a container directory.
     *
     * @param fileType - The type of component file
     * @param name - The name of the file without a suffix
     * @param directory - The directory to search in
     * @returns The first path that meets the criteria, or `undefined` if none were found
     */
    find(fileType, name, directory) {
        const fileName = this.readDirectory(directory).find((entry) => {
            const parsed = utils_1.parseMetadataXml(path_1.join(directory, entry));
            const metaXmlCondition = fileType === 'metadataXml' ? !!parsed : !parsed;
            return utils_1.baseName(entry) === name && metaXmlCondition;
        });
        if (fileName) {
            return path_1.join(directory, fileName);
        }
    }
}
exports.TreeContainer = TreeContainer;
/**
 * A {@link TreeContainer} that wraps the NodeJS `fs` module.
 */
class NodeFSTreeContainer extends TreeContainer {
    isDirectory(fsPath) {
        return graceful_fs_1.lstatSync(fsPath).isDirectory();
    }
    exists(fsPath) {
        return graceful_fs_1.existsSync(fsPath);
    }
    readDirectory(fsPath) {
        return graceful_fs_1.readdirSync(fsPath);
    }
    readFile(fsPath) {
        // significant enough performance increase using sync instead of fs.promise version
        return Promise.resolve(graceful_fs_1.readFileSync(fsPath));
    }
    readFileSync(fsPath) {
        return graceful_fs_1.readFileSync(fsPath);
    }
    stream(fsPath) {
        return graceful_fs_1.createReadStream(fsPath);
    }
}
exports.NodeFSTreeContainer = NodeFSTreeContainer;
/**
 * A {@link TreeContainer} that utilizes the central directory of a zip file
 * to perform I/O without unzipping it to the disk first.
 */
class ZipTreeContainer extends TreeContainer {
    constructor(directory) {
        super();
        this.tree = new Map();
        this.populate(directory);
    }
    /**
     * Creates a `ZipTreeContainer` from a Buffer of a zip file.
     *
     * @param buffer - Buffer of the zip file
     * @returns A Promise of a `ZipTreeContainer`
     */
    static create(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            const directory = yield unzipper.Open.buffer(buffer);
            return new ZipTreeContainer(directory);
        });
    }
    exists(fsPath) {
        return this.tree.has(fsPath);
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return Array.isArray(this.tree.get(fsPath));
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).map((entry) => path_1.basename(entry.path));
        }
        throw new errors_1.LibraryError('error_expected_directory_path', fsPath);
    }
    readFile(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).buffer();
        }
        throw new errors_1.LibraryError('error_expected_file_path', fsPath);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    readFileSync(fsPath) {
        throw new Error('Method not implemented');
    }
    stream(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).stream();
        }
        throw new errors_1.LibraryError('error_no_directory_stream', this.constructor.name);
    }
    populate(directory) {
        for (const { path, type, stream, buffer } of directory.files) {
            if (type === 'File') {
                // normalize path to use OS separator since zip entries always use forward slash
                const entry = { path: path_1.normalize(path), stream, buffer };
                this.tree.set(entry.path, entry);
                this.ensureDirPathExists(entry);
            }
        }
    }
    ensureDirPathExists(entry) {
        const dirPath = path_1.dirname(entry.path);
        if (dirPath === entry.path) {
            return;
        }
        else if (!this.exists(dirPath)) {
            this.tree.set(dirPath, [entry]);
            this.ensureDirPathExists({ path: dirPath });
        }
        else {
            this.tree.get(dirPath).push(entry);
        }
    }
}
exports.ZipTreeContainer = ZipTreeContainer;
/**
 * A {@link TreeContainer} useful for mocking a file system.
 */
class VirtualTreeContainer extends TreeContainer {
    constructor(virtualFs) {
        super();
        this.tree = new Map();
        this.fileContents = new Map();
        this.populate(virtualFs);
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return this.tree.has(fsPath);
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    exists(fsPath) {
        const files = this.tree.get(path_1.dirname(fsPath));
        const isFile = files && files.has(fsPath);
        return isFile || this.tree.has(fsPath);
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return Array.from(this.tree.get(fsPath)).map((p) => path_1.basename(p));
        }
        throw new errors_1.LibraryError('error_expected_directory_path', fsPath);
    }
    readFile(fsPath) {
        return Promise.resolve(this.readFileSync(fsPath));
    }
    readFileSync(fsPath) {
        if (this.exists(fsPath)) {
            let data = this.fileContents.get(fsPath);
            if (!data) {
                data = Buffer.from('');
                this.fileContents.set(fsPath, data);
            }
            return data;
        }
        throw new errors_1.LibraryError('error_path_not_found', fsPath);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stream(fsPath) {
        throw new Error('Method not implemented');
    }
    populate(virtualFs) {
        for (const dir of virtualFs) {
            const { dirPath, children } = dir;
            this.tree.set(dirPath, new Set());
            for (const child of children) {
                let childPath;
                let childData;
                if (typeof child === 'string') {
                    childPath = path_1.join(dirPath, child);
                }
                else {
                    childPath = path_1.join(dirPath, child.name);
                    childData = child.data;
                }
                this.tree.get(dirPath).add(childPath);
                if (childData) {
                    this.fileContents.set(childPath, childData);
                }
            }
        }
    }
}
exports.VirtualTreeContainer = VirtualTreeContainer;
//# sourceMappingURL=treeContainers.js.map