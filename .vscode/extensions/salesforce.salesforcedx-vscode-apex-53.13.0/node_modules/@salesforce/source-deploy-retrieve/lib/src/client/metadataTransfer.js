"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTransfer = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const events_1 = require("events");
const collections_1 = require("../collections");
const errors_1 = require("../errors");
const types_1 = require("./types");
const convert_1 = require("../convert");
const path_1 = require("path");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const fs = require("graceful-fs");
class MetadataTransfer {
    constructor({ usernameOrConnection, components, apiVersion, id }) {
        this.canceled = false;
        this.event = new events_1.EventEmitter();
        this.usernameOrConnection = usernameOrConnection;
        this.components = components;
        this.apiVersion = apiVersion;
        this._id = id;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    get id() {
        return this._id;
    }
    /**
     * Send the metadata transfer request to the org.
     *
     * @returns AsyncResult from the deploy or retrieve response.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.canceled = false;
            const asyncResult = yield this.pre();
            this._id = asyncResult.id;
            this.logger.debug(`Started metadata transfer. ID = ${this.id}`);
            return asyncResult;
        });
    }
    pollStatus(frequencyOrOptions, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            let pollingOptions = {
                frequency: kit_1.Duration.milliseconds(100),
                timeout: kit_1.Duration.minutes(60),
                poll: this.poll.bind(this),
            };
            if (ts_types_1.isNumber(frequencyOrOptions)) {
                pollingOptions.frequency = kit_1.Duration.milliseconds(frequencyOrOptions);
            }
            else if (frequencyOrOptions !== undefined) {
                pollingOptions = Object.assign(Object.assign({}, pollingOptions), frequencyOrOptions);
            }
            if (ts_types_1.isNumber(timeout)) {
                pollingOptions.timeout = kit_1.Duration.seconds(timeout);
            }
            const pollingClient = yield core_1.PollingClient.create(pollingOptions);
            try {
                this.logger.debug(`Polling for metadata transfer status. ID = ${this.id}`);
                this.logger.debug(`Polling frequency (ms): ${pollingOptions.frequency.milliseconds}`);
                this.logger.debug(`Polling timeout (min): ${pollingOptions.timeout.minutes}`);
                const completedMdapiStatus = (yield pollingClient.subscribe());
                const result = yield this.post(completedMdapiStatus);
                if (completedMdapiStatus.status === types_1.RequestStatus.Canceled) {
                    this.event.emit('cancel', completedMdapiStatus);
                }
                else {
                    this.event.emit('finish', result);
                }
                return result;
            }
            catch (e) {
                const error = new errors_1.MetadataTransferError('md_request_fail', e.message);
                if (error.stack && e.stack) {
                    // append the original stack to this new error
                    error.stack += `\nDUE TO:\n${e.stack}`;
                }
                if (this.event.listenerCount('error') === 0) {
                    throw error;
                }
                this.event.emit('error', error);
            }
        });
    }
    onUpdate(subscriber) {
        this.event.on('update', subscriber);
    }
    onFinish(subscriber) {
        this.event.on('finish', subscriber);
    }
    onCancel(subscriber) {
        this.event.on('cancel', subscriber);
    }
    onError(subscriber) {
        this.event.on('error', subscriber);
    }
    maybeSaveTempDirectory(target, cs) {
        return __awaiter(this, void 0, void 0, function* () {
            const mdapiTempDir = process.env.SFDX_MDAPI_TEMP_DIR;
            if (mdapiTempDir) {
                process.emitWarning('The SFDX_MDAPI_TEMP_DIR environment variable is set, which may degrade performance');
                this.logger.debug(`Converting metadata to: ${mdapiTempDir} because the SFDX_MDAPI_TEMP_DIR environment variable is set`);
                try {
                    const source = cs || this.components || new collections_1.ComponentSet();
                    const converter = new convert_1.MetadataConverter();
                    yield converter.convert(source, target, {
                        type: 'directory',
                        outputDirectory: mdapiTempDir,
                    });
                    if (target === 'source') {
                        // for source convert the package.xml isn't included so write it separately
                        fs.writeFileSync(path_1.join(mdapiTempDir, 'package.xml'), source.getPackageXml());
                    }
                }
                catch (e) {
                    this.logger.debug(e);
                }
            }
        });
    }
    getConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.usernameOrConnection === 'string') {
                this.usernameOrConnection = yield core_1.Connection.create({
                    authInfo: yield core_1.AuthInfo.create({ username: this.usernameOrConnection }),
                });
                if (this.apiVersion && this.apiVersion !== this.usernameOrConnection.version) {
                    this.usernameOrConnection.setApiVersion(this.apiVersion);
                    this.logger.debug(`Overriding apiVersion to: ${this.apiVersion}`);
                }
            }
            return this.usernameOrConnection;
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function* () {
            let completed = false;
            let mdapiStatus;
            if (this.canceled) {
                // This only happens for a canceled retrieve. Canceled deploys are
                // handled via checkStatus response.
                if (!mdapiStatus) {
                    mdapiStatus = { id: this.id, success: false, done: true };
                }
                mdapiStatus.status = types_1.RequestStatus.Canceled;
                completed = true;
                this.canceled = false;
            }
            else {
                mdapiStatus = yield this.checkStatus();
                completed = mdapiStatus === null || mdapiStatus === void 0 ? void 0 : mdapiStatus.done;
                if (!completed) {
                    this.event.emit('update', mdapiStatus);
                }
            }
            this.logger.debug(`MDAPI status update: ${mdapiStatus.status}`);
            return { completed, payload: mdapiStatus };
        });
    }
}
exports.MetadataTransfer = MetadataTransfer;
//# sourceMappingURL=metadataTransfer.js.map