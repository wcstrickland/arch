"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const common_1 = require("../../common");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
const path_1 = require("../../utils/path");
const path_2 = require("path");
const utils_1 = require("../../utils");
const ORIGINAL_SUFFIX_REGEX = new RegExp('(.)([a-zA-Z]+)(' + common_1.META_XML_SUFFIX + ')$');
/**
 * The default metadata transformer.
 *
 * If a metadata type doesn't have a transformer assigned to it, this one is used
 * during the conversion process. It leaves the component's metadata xml and source
 * files as-is.
 */
class DefaultMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    toMetadataFormat(component) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWriteInfos(component, 'metadata');
        });
    }
    toSourceFormat(component, mergeWith) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWriteInfos(component, 'source', mergeWith);
        });
    }
    getWriteInfos(component, targetFormat, mergeWith) {
        const writeInfos = [];
        if (component.content) {
            for (const source of component.walkContent()) {
                writeInfos.push({
                    source: component.tree.stream(source),
                    output: this.getContentSourceDestination(source, targetFormat, component, mergeWith),
                });
            }
        }
        if (component.xml) {
            writeInfos.push({
                source: component.tree.stream(component.xml),
                output: this.getXmlDestination(targetFormat, component, mergeWith),
            });
        }
        return writeInfos;
    }
    // assumes component has content
    getContentSourceDestination(source, targetFormat, component, mergeWith) {
        if (mergeWith === null || mergeWith === void 0 ? void 0 : mergeWith.content) {
            if (component.tree.isDirectory(component.content)) {
                const relative = path_1.trimUntil(source, path_2.basename(component.content));
                return path_2.join(path_2.dirname(mergeWith.content), relative);
            }
            return mergeWith.content;
        }
        return component.getPackageRelativePath(source, targetFormat);
    }
    // assumes component has xml
    getXmlDestination(targetFormat, component, mergeWith) {
        if ((mergeWith === null || mergeWith === void 0 ? void 0 : mergeWith.xml) && targetFormat === 'source') {
            return mergeWith.xml;
        }
        const { folderContentType, suffix, legacySuffix } = component.type;
        let xmlDestination = component.getPackageRelativePath(component.xml, targetFormat);
        // quirks:
        // - append or strip the -meta.xml suffix to the path if there's no content
        //  for folder components:
        //    - remove file extension but preserve -meta.xml suffix if folder type and to 'metadata format'
        //    - insert file extension behind the -meta.xml suffix if folder type and to 'source format'
        if (!component.content) {
            if (targetFormat === 'metadata') {
                xmlDestination = folderContentType
                    ? xmlDestination.replace(`.${suffix}`, '')
                    : xmlDestination.slice(0, xmlDestination.lastIndexOf(common_1.META_XML_SUFFIX));
            }
            else {
                xmlDestination = folderContentType
                    ? xmlDestination.replace(common_1.META_XML_SUFFIX, `.${suffix}${common_1.META_XML_SUFFIX}`)
                    : `${xmlDestination}${common_1.META_XML_SUFFIX}`;
            }
        }
        else if (suffix) {
            if (component.type.name === 'Document' && targetFormat === 'metadata') {
                xmlDestination = xmlDestination.replace(new RegExp('.' + suffix + common_1.META_XML_SUFFIX + '$'), '.' + utils_1.extName(component.content) + common_1.META_XML_SUFFIX);
            }
            else {
                xmlDestination = xmlDestination.replace(ORIGINAL_SUFFIX_REGEX, '.' + suffix + common_1.META_XML_SUFFIX);
            }
        }
        if (legacySuffix && suffix && xmlDestination.includes(legacySuffix)) {
            xmlDestination = xmlDestination.replace(legacySuffix, suffix);
        }
        return xmlDestination;
    }
}
exports.DefaultMetadataTransformer = DefaultMetadataTransformer;
//# sourceMappingURL=defaultMetadataTransformer.js.map