"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataApiRetrieve = exports.RetrieveResult = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const convert_1 = require("../convert");
const collections_1 = require("../collections");
const resolve_1 = require("../resolve");
const types_1 = require("./types");
const metadataTransfer_1 = require("./metadataTransfer");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const ts_types_1 = require("@salesforce/ts-types");
class RetrieveResult {
    /**
     * @param response The metadata retrieve response from the server
     * @param components The ComponentSet of retrieved source components
     * @param localComponents The ComponentSet used to create the retrieve request
     */
    constructor(response, components, localComponents) {
        this.response = response;
        this.components = components;
        this.localComponents = new collections_1.ComponentSet(localComponents === null || localComponents === void 0 ? void 0 : localComponents.getSourceComponents());
    }
    getFileResponses() {
        if (this.response && this.fileResponses) {
            return this.fileResponses;
        }
        this.fileResponses = [];
        // construct failures
        if (this.response.messages) {
            const retrieveMessages = utils_1.normalizeToArray(this.response.messages);
            for (const message of retrieveMessages) {
                // match type name and fullname of problem component
                const matches = message.problem.match(/.+'(.+)'.+'(.+)'/);
                if (matches) {
                    const [typeName, fullName] = matches.slice(1);
                    this.fileResponses.push({
                        fullName,
                        type: typeName,
                        state: types_1.ComponentStatus.Failed,
                        error: message.problem,
                        problemType: 'Error',
                    });
                }
                else {
                    this.fileResponses.push({
                        fullName: '',
                        type: '',
                        problemType: 'Error',
                        state: types_1.ComponentStatus.Failed,
                        error: message.problem,
                    });
                }
            }
        }
        // construct successes
        for (const retrievedComponent of this.components.getSourceComponents()) {
            const { fullName, type, xml } = retrievedComponent;
            const baseResponse = {
                fullName,
                type: type.name,
                state: this.localComponents.has(retrievedComponent)
                    ? types_1.ComponentStatus.Changed
                    : types_1.ComponentStatus.Created,
            };
            if (!type.children) {
                for (const filePath of retrievedComponent.walkContent()) {
                    this.fileResponses.push(Object.assign({}, baseResponse, { filePath }));
                }
            }
            if (xml) {
                this.fileResponses.push(Object.assign({}, baseResponse, { filePath: xml }));
            }
        }
        return this.fileResponses;
    }
}
exports.RetrieveResult = RetrieveResult;
class MetadataApiRetrieve extends metadataTransfer_1.MetadataTransfer {
    constructor(options) {
        super(options);
        this.options = Object.assign({}, MetadataApiRetrieve.DEFAULT_OPTIONS, options);
    }
    /**
     * Check the status of the retrieve operation.
     *
     * @returns Status of the retrieve
     */
    checkStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.id) {
                throw new errors_1.MissingJobIdError('retrieve');
            }
            const coerceBoolean = (field) => {
                if (ts_types_1.isString(field)) {
                    return field.toLowerCase() === 'true';
                }
                return ts_types_1.asBoolean(field, false);
            };
            const connection = yield this.getConnection();
            // Cast RetrieveResult returned by jsForce to MetadataApiRetrieveStatus
            const status = (yield connection.metadata.checkRetrieveStatus(this.id));
            status.fileProperties = utils_1.normalizeToArray(status.fileProperties);
            status.success = coerceBoolean(status.success);
            status.done = coerceBoolean(status.done);
            return status;
        });
    }
    /**
     * Cancel the retrieve operation.
     *
     * Canceling a retrieve occurs immediately and requires no additional status
     * checks to the org, unlike {@link MetadataApiDeploy.cancel}.
     */
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            this.canceled = true;
        });
    }
    pre() {
        return __awaiter(this, void 0, void 0, function* () {
            const packageNames = this.getPackageNames();
            if (this.components.size === 0 && !(packageNames === null || packageNames === void 0 ? void 0 : packageNames.length)) {
                throw new errors_1.MetadataApiRetrieveError('error_no_components_to_retrieve');
            }
            const connection = yield this.getConnection();
            const requestBody = {
                apiVersion: this.components.apiVersion,
                unpackaged: this.components.getObject().Package,
            };
            // if we're retrieving with packageNames add it
            // otherwise don't - it causes errors if undefined or an empty array
            if (packageNames === null || packageNames === void 0 ? void 0 : packageNames.length) {
                requestBody.packageNames = packageNames;
            }
            // @ts-ignore required callback
            return connection.metadata.retrieve(requestBody);
        });
    }
    post(result) {
        return __awaiter(this, void 0, void 0, function* () {
            let components;
            if (result.status === types_1.RequestStatus.Succeeded) {
                components = yield this.extract(Buffer.from(result.zipFile, 'base64'));
            }
            components = components !== null && components !== void 0 ? components : new collections_1.ComponentSet(undefined, this.options.registry);
            yield this.maybeSaveTempDirectory('source', components);
            return new RetrieveResult(result, components, this.components);
        });
    }
    getPackageNames() {
        var _a;
        return (_a = this.getPackageOptions()) === null || _a === void 0 ? void 0 : _a.map((pkg) => pkg.name);
    }
    getPackageOptions() {
        const { packageOptions } = this.options;
        if (packageOptions === null || packageOptions === void 0 ? void 0 : packageOptions.length) {
            if (ts_types_1.isString(packageOptions[0])) {
                const packageNames = packageOptions;
                return packageNames.map((pkg) => ({ name: pkg, outputDir: pkg }));
            }
            else {
                const pkgs = packageOptions;
                // If there isn't an outputDir specified, use the package name.
                return pkgs.map(({ name, outputDir }) => ({ name, outputDir: outputDir || name }));
            }
        }
    }
    extract(zip) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const components = [];
            const { merge, output, registry } = this.options;
            const converter = new convert_1.MetadataConverter(registry);
            const tree = yield resolve_1.ZipTreeContainer.create(zip);
            const packages = [
                { zipTreeLocation: 'unpackaged', outputDir: output },
            ];
            const packageOpts = this.getPackageOptions();
            packageOpts === null || packageOpts === void 0 ? void 0 : packageOpts.forEach(({ name, outputDir }) => {
                packages.push({ zipTreeLocation: name, outputDir });
            });
            for (const pkg of packages) {
                const outputConfig = merge
                    ? {
                        type: 'merge',
                        mergeWith: this.components.getSourceComponents(),
                        defaultDirectory: pkg.outputDir,
                        forceIgnoredPaths: (_a = this.components.forceIgnoredPaths) !== null && _a !== void 0 ? _a : new Set(),
                    }
                    : {
                        type: 'directory',
                        outputDirectory: pkg.outputDir,
                    };
                const zipComponents = collections_1.ComponentSet.fromSource({
                    fsPaths: [pkg.zipTreeLocation],
                    registry,
                    tree,
                })
                    .getSourceComponents()
                    .toArray();
                const convertResult = yield converter.convert(zipComponents, 'source', outputConfig);
                if (convertResult) {
                    components.push(...convertResult.converted);
                }
            }
            return new collections_1.ComponentSet(components, registry);
        });
    }
}
exports.MetadataApiRetrieve = MetadataApiRetrieve;
MetadataApiRetrieve.DEFAULT_OPTIONS = { merge: false };
//# sourceMappingURL=metadataApiRetrieve.js.map