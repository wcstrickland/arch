"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolingApi = exports.deployTypes = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const deployStrategies_1 = require("./deployStrategies");
const errors_1 = require("../errors");
const i18n_1 = require("../i18n");
const retrieveUtil_1 = require("./retrieveUtil");
const utils_1 = require("../utils");
const types_1 = require("./types");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
const retrieveTypes = new Set([
    'ApexClass',
    'ApexTrigger',
    'ApexPage',
    'ApexComponent',
    'AuraDefinitionBundle',
    'LightningComponentBundle',
]);
exports.deployTypes = new Map([
    ['ApexClass', 'ApexClassMember'],
    ['ApexTrigger', 'ApexTriggerMember'],
    ['ApexPage', 'ApexPageMember'],
    ['ApexComponent', 'ApexComponentMember'],
    ['AuraDefinitionBundle', 'AuraDefinition'],
    ['LightningComponentBundle', 'LightningComponentResource'],
]);
class ToolingApi {
    constructor(connection, resolver, registry = new registry_1.RegistryAccess()) {
        this.connection = connection;
        this.resolver = resolver;
        this.registry = registry;
    }
    retrieveWithPaths(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.retrieve({
                output: options.output,
                namespace: options.namespace,
                components: collections_1.ComponentSet.fromSource({ fsPaths: [options.paths[0]], registry: this.registry }),
            });
        });
    }
    retrieve(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let retrieveResult;
            if (options.components.size > 1) {
                const retrieveError = new Error();
                retrieveError.message = i18n_1.nls.localize('tapi_retrieve_component_limit_error');
                retrieveError.name = 'MetadataRetrieveLimit';
                throw retrieveError;
            }
            const mdComponent = options.components.getSourceComponents().first();
            if (!retrieveTypes.has(mdComponent.type.name)) {
                const retrieveError = new Error();
                retrieveError.message = i18n_1.nls.localize('beta_tapi_membertype_unsupported_error', mdComponent.type.name);
                retrieveError.name = 'MetadataTypeUnsupported';
                throw retrieveError;
            }
            try {
                const queryResult = (yield this.connection.tooling.query(retrieveUtil_1.buildQuery(mdComponent, options.namespace)));
                if (queryResult && queryResult.records.length === 0) {
                    return {
                        status: types_1.RequestStatus.Failed,
                        success: false,
                        successes: [],
                        failures: [
                            {
                                component: {
                                    fullName: mdComponent.fullName,
                                    type: mdComponent.type,
                                },
                                message: i18n_1.nls.localize('error_md_not_present_in_org', mdComponent.fullName),
                            },
                        ],
                    };
                }
                const saveFilesMap = retrieveUtil_1.queryToFileMap(queryResult, mdComponent, options.output);
                utils_1.createFiles(saveFilesMap);
                retrieveResult = {
                    status: types_1.RequestStatus.Succeeded,
                    success: true,
                    successes: [{ component: mdComponent }],
                    failures: [],
                };
            }
            catch (err) {
                throw new Error(i18n_1.nls.localize('error_in_tooling_retrieve', err));
            }
            return retrieveResult;
        });
    }
    deploy(components, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let mdComponent;
            if (Array.isArray(components)) {
                if (components.length > 1) {
                    const deployError = new errors_1.SourceClientError('tapi_deploy_component_limit_error');
                    throw deployError;
                }
                mdComponent = components[0];
            }
            else {
                mdComponent = components;
            }
            const metadataType = mdComponent.type.name;
            if (!exports.deployTypes.get(metadataType)) {
                throw new errors_1.SourceClientError('beta_tapi_membertype_unsupported_error', metadataType);
            }
            const deployStrategy = deployStrategies_1.getDeployStrategy(metadataType, this.connection);
            const namespace = options && options.namespace ? options.namespace : '';
            return deployStrategy.deploy(mdComponent, namespace);
        });
    }
    deployWithPaths(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.deploy(this.resolver.getComponentsFromPath(path), options);
        });
    }
}
exports.ToolingApi = ToolingApi;
//# sourceMappingURL=toolingApi.js.map