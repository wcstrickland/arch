import { WriteInfo, WriterFormat } from './types';
import { MetadataComponent, SourceComponent } from '../resolve';
import { JsonMap } from '@salesforce/ts-types';
import { ComponentSet } from '../collections';
declare abstract class ConvertTransactionFinalizer<T> {
    protected abstract _state: T;
    setState(props: (state: T) => void): void;
    get state(): T;
    abstract finalize(defaultDirectory?: string): Promise<WriterFormat[]>;
}
export interface RecompositionState {
    [componentKey: string]: {
        /**
         * Parent component that children are rolled up into
         */
        component?: SourceComponent;
        /**
         * Children to be rolled up into the parent file
         */
        children?: ComponentSet;
    };
}
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 */
declare class RecompositionFinalizer extends ConvertTransactionFinalizer<RecompositionState> {
    protected _state: RecompositionState;
    private parsedXmlCache;
    finalize(): Promise<WriterFormat[]>;
    private recompose;
}
export interface DecompositionState {
    [componentKey: string]: {
        foundMerge?: boolean;
        writeInfo?: WriteInfo;
        origin?: MetadataComponent;
    };
}
/**
 * Creates write infos for any children that haven't been written yet. Children may
 * delay being written in order to find potential existing children to merge
 * with in the conversion pipeline.
 */
declare class DecompositionFinalizer extends ConvertTransactionFinalizer<DecompositionState> {
    protected _state: DecompositionState;
    finalize(): Promise<WriterFormat[]>;
}
export interface NonDecompositionState {
    claimed: ChildIndex;
    unclaimed: ChildIndex;
}
declare type ChildIndex = {
    [componentKey: string]: {
        parent: SourceComponent;
        children: {
            [childName: string]: JsonMap;
        };
    };
};
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 *
 * Inserts unclaimed child components into the parent that belongs to the default package
 */
declare class NonDecompositionFinalizer extends ConvertTransactionFinalizer<NonDecompositionState> {
    protected _state: NonDecompositionState;
    finalize(defaultDirectory: string): Promise<WriterFormat[]>;
    /**
     * This method finalizes the state by:
     * - finding any "unprocessed components" (nondecomposed metadata types can exist in multiple locations under the same name
     *   so we have to find all components that could potentially claim children)
     * - removing any children from the unclaimed state that have been claimed by the unprocessed components
     * - removing any children from the unclaimed state that have already been claimed by a prent in the claimed state
     * - merging the remaining unclaimed children into the default parent component (either the component that matches the
     *   defaultDirectory or the first parent component)
     */
    private finalizeState;
    /**
     * Returns the "unprocessed components"
     *
     * An unprocessed component is a component that was not resolved during component resolution.
     * This typically only happens when a specific source path was resolved. This is problematic for
     * nondecomposed metadata types (like CustomLabels) because we need to know the location of each
     * child type before recomposing the final xml. So in order for each of the children to be properly
     * claimed, we have to create new ComponentSet that will have all the parent components.
     */
    private getUnprocessedComponents;
    /**
     * Returns the children of "unprocessed components"
     */
    private getChildrenOfUnprocessedComponents;
    private recompose;
    private getDefaultOutput;
    private getClaimedChildrenNames;
    private getParentsOfClaimedChildren;
}
/**
 * A state manager over the course of a single metadata conversion call.
 */
export declare class ConvertContext {
    readonly decomposition: DecompositionFinalizer;
    readonly recomposition: RecompositionFinalizer;
    readonly nonDecomposition: NonDecompositionFinalizer;
    executeFinalizers(defaultDirectory?: string): AsyncIterable<WriterFormat[]>;
}
export {};
